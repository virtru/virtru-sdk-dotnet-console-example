<?xml version="1.0"?>
<doc>
    <assembly>
        <name>bc-fips-1.0.1</name>
    </assembly>
    <members>
        <member name="M:Org.BouncyCastle.Asn1.Anssi.AnssiNamedCurves.GetByOid(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
             return the X9ECParameters object for the named curve represented by
             the passed in object identifier. Null if the curve isn't present.
            
             @param oid an object identifier representing a named curve, if present.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Anssi.AnssiNamedCurves.GetOid(System.String)">
             return the object identifier signified by the passed in name. Null
             if there is no object identifier associated with name.
            
             @return the object identifier associated with name, if present.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Anssi.AnssiNamedCurves.GetName(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            return the named curve name represented by the given object identifier.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.Anssi.AnssiNamedCurves.Names">
            returns an enumeration containing the name strings for curves
            contained in this structure.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Encodable.GetDerEncoded">
             Return the DER encoding of the object, null if the DER encoding can not be made.
            
             @return a DER byte array, null otherwise.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Asn1InputStream">
            a general purpose ASN.1 decoder - note: this class differs from the
            others in that it returns null after it has read the last object in
            the stream. If an ASN.1 Null is encountered a Der/BER Null object is
            returned.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1InputStream.#ctor(System.IO.Stream,System.Int32)">
             Create an ASN1InputStream where no DER object will be longer than limit.
            
             @param input stream containing ASN.1 encoded data.
             @param limit maximum size of a DER encoded object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1InputStream.#ctor(System.Byte[])">
             Create an ASN1InputStream based on the input byte array. The length of DER objects in
             the stream is automatically limited to the length of the input array.
            
             @param input array containing ASN.1 encoded data.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1InputStream.BuildObject(System.Int32,System.Int32,System.Int32)">
            build an object given its tag and the number of bytes to construct it from.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Asn1Null">
            A Null object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Object.FromByteArray(System.Byte[])">
            <summary>Create a base ASN.1 object from a byte array.</summary>
            <param name="data">The byte array to parse.</param>
            <returns>The base ASN.1 object represented by the byte array.</returns>
            <exception cref="T:System.IO.IOException">If there is a problem parsing the data.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Object.FromStream(System.IO.Stream)">
            <summary>Read a base ASN.1 object from a stream.</summary>
            <param name="inStr">The stream to parse.</param>
            <returns>The base ASN.1 object represented by the byte array.</returns>
            <exception cref="T:System.IO.IOException">If there is a problem parsing the data.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1OctetString.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an Octet string from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                          be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1OctetString.GetInstance(System.Object)">
             return an Octet string from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1OctetString.#ctor(System.Byte[])">
            @param string the octets making up the octet string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Sequence.GetInstance(System.Object)">
             return an Asn1Sequence from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Sequence.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             Return an ASN1 sequence from a tagged object. There is a special
             case here, if an object appears to have been explicitly tagged on
             reading but we were expecting it to be implicitly tagged in the
             normal course of events it indicates that we lost the surrounding
             sequence - so we need to add it back (this will happen if the tagged
             object is a sequence that contains other sequences). If you are
             dealing with implicitly tagged sequences you really <b>should</b>
             be using this method.
            
             @param obj the tagged object.
             @param explicitly true if the object is meant to be explicitly tagged,
                      false otherwise.
             @exception ArgumentException if the tagged object cannot
                      be converted.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.Asn1Sequence.Item(System.Int32)">
             return the object at the sequence position indicated by index.
            
             @param index the sequence number (starting at zero) of the object
             @return the object at the sequence position indicated by index.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Set.GetInstance(System.Object)">
             return an ASN1Set from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Set.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             Return an ASN1 set from a tagged object. There is a special
             case here, if an object appears to have been explicitly tagged on
             reading but we were expecting it to be implicitly tagged in the
             normal course of events it indicates that we lost the surrounding
             set - so we need to add it back (this will happen if the tagged
             object is a sequence that contains other sequences). If you are
             dealing with implicitly tagged sets you really <b>should</b>
             be using this method.
            
             @param obj the tagged object.
             @param explicitly true if the object is meant to be explicitly tagged
                      false otherwise.
             @exception ArgumentException if the tagged object cannot
                      be converted.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.Asn1Set.Item(System.Int32)">
             return the object at the set position indicated by index.
            
             @param index the set number (starting at zero) of the object
             @return the object at the set position indicated by index.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Asn1TaggedObject">
            ASN.1 TaggedObject - in ASN.1 notation this is any object preceded by
            a [n] where n is some number - these are assumed to follow the construction
            rules (as with sequences).
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1TaggedObject.#ctor(System.Int32,Org.BouncyCastle.Asn1.Asn1Encodable)">
            @param tagNo the tag number for this object.
            @param obj the tagged object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1TaggedObject.#ctor(System.Boolean,System.Int32,Org.BouncyCastle.Asn1.Asn1Encodable)">
            @param explicitly true if the object is explicitly tagged.
            @param tagNo the tag number for this object.
            @param obj the tagged object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1TaggedObject.IsExplicit">
            return whether or not the object may be explicitly tagged.
            <p>
            Note: if the object has been read from an input stream, the only
            time you can be sure if isExplicit is returning the true state of
            affairs is if it returns false. An implicitly tagged object may appear
            to be explicitly tagged, so you need to understand the context under
            which the reading was done as well, see GetObject below.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1TaggedObject.GetObject">
            return whatever was following the tag.
            <p>
            Note: tagged objects are generally context dependent if you're
            trying to extract a tagged object you should be going via the
            appropriate GetInstance method.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1TaggedObject.GetObjectParser(System.Int32,System.Boolean)">
            Return the object held in this tagged object as a parser assuming it has
            the type of the passed in tag. If the object doesn't have a parser
            associated with it, the base object is returned.
        </member>
        <member name="F:Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc">
              iso.org.dod.internet.private.enterprise.legion-of-the-bouncy-castle
            <p/>
              1.3.6.1.4.1.22554
        </member>
        <member name="F:Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_pbe">
            pbe(1) algorithms
            <p/>
            1.3.6.1.4.1.22554.1
        </member>
        <member name="F:Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_pbe_sha1">
            SHA-1(1)
            <p/>
            1.3.6.1.4.1.22554.1.1
        </member>
        <member name="F:Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_pbe_sha256">
            SHA-2.SHA-256; 1.3.6.1.4.1.22554.1.2.1 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_pbe_sha384">
            SHA-2.SHA-384; 1.3.6.1.4.1.22554.1.2.2 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_pbe_sha512">
            SHA-2.SHA-512; 1.3.6.1.4.1.22554.1.2.3 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_pbe_sha224">
            SHA-2.SHA-224; 1.3.6.1.4.1.22554.1.2.4 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_pbe_sha1_pkcs5">
            PKCS-5(1)|PKCS-12(2)
            SHA-1.PKCS5;  1.3.6.1.4.1.22554.1.1.1 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_pbe_sha1_pkcs12">
            SHA-1.PKCS12; 1.3.6.1.4.1.22554.1.1.2 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_pbe_sha256_pkcs5">
            SHA-256.PKCS12; 1.3.6.1.4.1.22554.1.2.1.1 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_pbe_sha256_pkcs12">
            SHA-256.PKCS12; 1.3.6.1.4.1.22554.1.2.1.2 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_pbe_sha1_pkcs12_aes128_cbc">
            AES(1) . (CBC-128(2)|CBC-192(22)|CBC-256(42))
            1.3.6.1.4.1.22554.1.1.2.1.2 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_pbe_sha1_pkcs12_aes192_cbc">
            1.3.6.1.4.1.22554.1.1.2.1.22 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_pbe_sha1_pkcs12_aes256_cbc">
            1.3.6.1.4.1.22554.1.1.2.1.42 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_pbe_sha256_pkcs12_aes128_cbc">
            1.3.6.1.4.1.22554.1.1.2.2.2 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_pbe_sha256_pkcs12_aes192_cbc">
            1.3.6.1.4.1.22554.1.1.2.2.22 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_pbe_sha256_pkcs12_aes256_cbc">
            1.3.6.1.4.1.22554.1.1.2.2.42 
        </member>
        <member name="F:Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_sig">
            signature(2) algorithms
        </member>
        <member name="F:Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.sphincs256">
            Sphincs-256
        </member>
        <member name="F:Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.bc_exch">
            key_exchange(3) algorithms
        </member>
        <member name="F:Org.BouncyCastle.Asn1.BC.BCObjectIdentifiers.newHope">
            NewHope
        </member>
        <member name="T:Org.BouncyCastle.Asn1.BerNull">
            A BER Null object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerOctetString.ToBytes(System.Collections.IEnumerable)">
            convert a vector of octet strings into a single byte string
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerOctetString.#ctor(System.Byte[])">
            <param name="str">The octets making up the octet string.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerOctetString.GetEnumerator">
            return the DER octets that make up this string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerSequence.#ctor">
            create an empty sequence
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerSequence.#ctor(Org.BouncyCastle.Asn1.Asn1Encodable)">
            create a sequence containing one object
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerSequence.#ctor(Org.BouncyCastle.Asn1.Asn1EncodableVector)">
            create a sequence containing a vector of objects.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerSet.#ctor">
            create an empty sequence
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerSet.#ctor(Org.BouncyCastle.Asn1.Asn1Encodable)">
            create a set containing one object
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerSet.#ctor(Org.BouncyCastle.Asn1.Asn1EncodableVector)">
            create a set containing a vector of objects.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.BerTaggedObject">
            BER TaggedObject - in ASN.1 notation this is any object preceded by
            a [n] where n is some number - these are assumed to follow the construction
            rules (as with sequences).
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerTaggedObject.#ctor(System.Int32,Org.BouncyCastle.Asn1.Asn1Encodable)">
            @param tagNo the tag number for this object.
            @param obj the tagged object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerTaggedObject.#ctor(System.Boolean,System.Int32,Org.BouncyCastle.Asn1.Asn1Encodable)">
            @param explicitly true if an explicitly tagged object.
            @param tagNo the tag number for this object.
            @param obj the tagged object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerTaggedObject.#ctor(System.Int32)">
            create an implicitly tagged object that contains a zero
            length sequence.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.CAKeyUpdAnnContent.ToAsn1Object">
            <pre>
            CAKeyUpdAnnContent ::= SEQUENCE {
                                        oldWithNew   CmpCertificate, -- old pub signed with new priv
                                        newWithOld   CmpCertificate, -- new pub signed with old priv
                                        newWithNew   CmpCertificate  -- new pub signed with new priv
             }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.CertConfirmContent.ToAsn1Object">
            <pre>
            CertConfirmContent ::= SEQUENCE OF CertStatus
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.CertifiedKeyPair.ToAsn1Object">
            <pre>
            CertifiedKeyPair ::= SEQUENCE {
                                             certOrEncCert       CertOrEncCert,
                                             privateKey      [0] EncryptedValue      OPTIONAL,
                                             -- see [CRMF] for comment on encoding
                                             publicationInfo [1] PKIPublicationInfo  OPTIONAL
                  }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.CertOrEncCert.ToAsn1Object">
            <pre>
            CertOrEncCert ::= CHOICE {
                                 certificate     [0] CMPCertificate,
                                 encryptedCert   [1] EncryptedValue
                      }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.CertRepMessage.ToAsn1Object">
            <pre>
            CertRepMessage ::= SEQUENCE {
                                     caPubs       [1] SEQUENCE SIZE (1..MAX) OF CMPCertificate
                                                                                        OPTIONAL,
                                     response         SEQUENCE OF CertResponse
            }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.CertResponse.ToAsn1Object">
            <pre>
            CertResponse ::= SEQUENCE {
                                       certReqId           INTEGER,
                                       -- to match this response with corresponding request (a value
                                       -- of -1 is to be used if certReqId is not specified in the
                                       -- corresponding request)
                                       status              PKIStatusInfo,
                                       certifiedKeyPair    CertifiedKeyPair    OPTIONAL,
                                       rspInfo             OCTET STRING        OPTIONAL
                                       -- analogous to the id-regInfo-utf8Pairs string defined
                                       -- for regInfo in CertReqMsg [CRMF]
                        }
            </pre> 
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.CertStatus.ToAsn1Object">
            <pre>
            CertStatus ::= SEQUENCE {
                              certHash    OCTET STRING,
                              -- the hash of the certificate, using the same hash algorithm
                              -- as is used to create and verify the certificate signature
                              certReqId   INTEGER,
                              -- to match this confirmation with the corresponding req/rep
                              statusInfo  PKIStatusInfo OPTIONAL
            }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.Challenge.ToAsn1Object">
             <pre>
             Challenge ::= SEQUENCE {
                             owf                 AlgorithmIdentifier  OPTIONAL,
            
                             -- MUST be present in the first Challenge; MAY be omitted in
                             -- any subsequent Challenge in POPODecKeyChallContent (if
                             -- omitted, then the owf used in the immediately preceding
                             -- Challenge is to be used).
            
                             witness             OCTET STRING,
                             -- the result of applying the one-way function (owf) to a
                             -- randomly-generated INTEGER, A.  [Note that a different
                             -- INTEGER MUST be used for each Challenge.]
                             challenge           OCTET STRING
                             -- the encryption (under the public key for which the cert.
                             -- request is being made) of Rand, where Rand is specified as
                             --   Rand ::= SEQUENCE {
                             --      int      INTEGER,
                             --       - the randomly-generated INTEGER A (above)
                             --      sender   GeneralName
                             --       - the sender's name (as included in PKIHeader)
                             --   }
                  }
             </pre>
             @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.CmpCertificate.#ctor(Org.BouncyCastle.Asn1.X509.AttributeCertificate)">
            Note: the addition of attribute certificates is a BC extension.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.CmpCertificate.ToAsn1Object">
             <pre>
             CMPCertificate ::= CHOICE {
                        x509v3PKCert        Certificate
                        x509v2AttrCert      [1] AttributeCertificate
              }
             </pre>
             Note: the addition of attribute certificates is a BC extension.
            
             @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.CrlAnnContent.ToAsn1Object">
            <pre>
            CrlAnnContent ::= SEQUENCE OF CertificateList
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.ErrorMsgContent.ToAsn1Object">
            <pre>
            ErrorMsgContent ::= SEQUENCE {
                                   pKIStatusInfo          PKIStatusInfo,
                                   errorCode              INTEGER           OPTIONAL,
                                   -- implementation-specific error codes
                                   errorDetails           PKIFreeText       OPTIONAL
                                   -- implementation-specific error details
            }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.GenMsgContent.ToAsn1Object">
            <pre>
            GenMsgContent ::= SEQUENCE OF InfoTypeAndValue
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.GenRepContent.ToAsn1Object">
            <pre>
            GenRepContent ::= SEQUENCE OF InfoTypeAndValue
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Cmp.InfoTypeAndValue">
             Example InfoTypeAndValue contents include, but are not limited
             to, the following (un-comment in this ASN.1 module and use as
             appropriate for a given environment):
             <pre>
               id-it-caProtEncCert    OBJECT IDENTIFIER ::= {id-it 1}
                  CAProtEncCertValue      ::= CMPCertificate
               id-it-signKeyPairTypes OBJECT IDENTIFIER ::= {id-it 2}
                 SignKeyPairTypesValue   ::= SEQUENCE OF AlgorithmIdentifier
               id-it-encKeyPairTypes  OBJECT IDENTIFIER ::= {id-it 3}
                 EncKeyPairTypesValue    ::= SEQUENCE OF AlgorithmIdentifier
               id-it-preferredSymmAlg OBJECT IDENTIFIER ::= {id-it 4}
                  PreferredSymmAlgValue   ::= AlgorithmIdentifier
               id-it-caKeyUpdateInfo  OBJECT IDENTIFIER ::= {id-it 5}
                  CAKeyUpdateInfoValue    ::= CAKeyUpdAnnContent
               id-it-currentCRL       OBJECT IDENTIFIER ::= {id-it 6}
                  CurrentCRLValue         ::= CertificateList
               id-it-unsupportedOIDs  OBJECT IDENTIFIER ::= {id-it 7}
                  UnsupportedOIDsValue    ::= SEQUENCE OF OBJECT IDENTIFIER
               id-it-keyPairParamReq  OBJECT IDENTIFIER ::= {id-it 10}
                  KeyPairParamReqValue    ::= OBJECT IDENTIFIER
               id-it-keyPairParamRep  OBJECT IDENTIFIER ::= {id-it 11}
                  KeyPairParamRepValue    ::= AlgorithmIdentifer
               id-it-revPassphrase    OBJECT IDENTIFIER ::= {id-it 12}
                  RevPassphraseValue      ::= EncryptedValue
               id-it-implicitConfirm  OBJECT IDENTIFIER ::= {id-it 13}
                  ImplicitConfirmValue    ::= NULL
               id-it-confirmWaitTime  OBJECT IDENTIFIER ::= {id-it 14}
                  ConfirmWaitTimeValue    ::= GeneralizedTime
               id-it-origPKIMessage   OBJECT IDENTIFIER ::= {id-it 15}
                  OrigPKIMessageValue     ::= PKIMessages
               id-it-suppLangTags     OBJECT IDENTIFIER ::= {id-it 16}
                  SuppLangTagsValue       ::= SEQUENCE OF UTF8String
            
             where
            
               id-pkix OBJECT IDENTIFIER ::= {
                  iso(1) identified-organization(3)
                  dod(6) internet(1) security(5) mechanisms(5) pkix(7)}
             and
                  id-it   OBJECT IDENTIFIER ::= {id-pkix 4}
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.InfoTypeAndValue.ToAsn1Object">
            <pre>
            InfoTypeAndValue ::= SEQUENCE {
                                    infoType               OBJECT IDENTIFIER,
                                    infoValue              ANY DEFINED BY infoType  OPTIONAL
            }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.KeyRecRepContent.ToAsn1Object">
            <pre>
            KeyRecRepContent ::= SEQUENCE {
                                    status                  PKIStatusInfo,
                                    newSigCert          [0] CMPCertificate OPTIONAL,
                                    caCerts             [1] SEQUENCE SIZE (1..MAX) OF
                                                                      CMPCertificate OPTIONAL,
                                    keyPairHist         [2] SEQUENCE SIZE (1..MAX) OF
                                                                      CertifiedKeyPair OPTIONAL
                         }
            </pre> 
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.OobCertHash.ToAsn1Object">
            <pre>
            OobCertHash ::= SEQUENCE {
                                 hashAlg     [0] AlgorithmIdentifier     OPTIONAL,
                                 certId      [1] CertId                  OPTIONAL,
                                 hashVal         BIT STRING
                                 -- hashVal is calculated over the Der encoding of the
                                 -- self-signed certificate with the identifier certID.
                  }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.PbmParameter.ToAsn1Object">
            <pre>
             PbmParameter ::= SEQUENCE {
                                   salt                OCTET STRING,
                                   -- note:  implementations MAY wish to limit acceptable sizes
                                   -- of this string to values appropriate for their environment
                                   -- in order to reduce the risk of denial-of-service attacks
                                   owf                 AlgorithmIdentifier,
                                   -- AlgId for a One-Way Function (SHA-1 recommended)
                                   iterationCount      INTEGER,
                                   -- number of times the OWF is applied
                                   -- note:  implementations MAY wish to limit acceptable sizes
                                   -- of this integer to values appropriate for their environment
                                   -- in order to reduce the risk of denial-of-service attacks
                                   mac                 AlgorithmIdentifier
                                   -- the MAC AlgId (e.g., DES-MAC, Triple-DES-MAC [PKCS11],
               }   -- or HMAC [RFC2104, RFC2202])
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.PkiBody.#ctor(System.Int32,Org.BouncyCastle.Asn1.Asn1Encodable)">
            Creates a new PkiBody.
            @param type one of the TYPE_* constants
            @param content message content
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.PkiBody.ToAsn1Object">
            <pre>
            PkiBody ::= CHOICE {       -- message-specific body elements
                   ir       [0]  CertReqMessages,        --Initialization Request
                   ip       [1]  CertRepMessage,         --Initialization Response
                   cr       [2]  CertReqMessages,        --Certification Request
                   cp       [3]  CertRepMessage,         --Certification Response
                   p10cr    [4]  CertificationRequest,   --imported from [PKCS10]
                   popdecc  [5]  POPODecKeyChallContent, --pop Challenge
                   popdecr  [6]  POPODecKeyRespContent,  --pop Response
                   kur      [7]  CertReqMessages,        --Key Update Request
                   kup      [8]  CertRepMessage,         --Key Update Response
                   krr      [9]  CertReqMessages,        --Key Recovery Request
                   krp      [10] KeyRecRepContent,       --Key Recovery Response
                   rr       [11] RevReqContent,          --Revocation Request
                   rp       [12] RevRepContent,          --Revocation Response
                   ccr      [13] CertReqMessages,        --Cross-Cert. Request
                   ccp      [14] CertRepMessage,         --Cross-Cert. Response
                   ckuann   [15] CAKeyUpdAnnContent,     --CA Key Update Ann.
                   cann     [16] CertAnnContent,         --Certificate Ann.
                   rann     [17] RevAnnContent,          --Revocation Ann.
                   crlann   [18] CRLAnnContent,          --CRL Announcement
                   pkiconf  [19] PKIConfirmContent,      --Confirmation
                   nested   [20] NestedMessageContent,   --Nested Message
                   genm     [21] GenMsgContent,          --General Message
                   genp     [22] GenRepContent,          --General Response
                   error    [23] ErrorMsgContent,        --Error Message
                   certConf [24] CertConfirmContent,     --Certificate confirm
                   pollReq  [25] PollReqContent,         --Polling request
                   pollRep  [26] PollRepContent          --Polling response
            }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.PkiConfirmContent.ToAsn1Object">
            <pre>
            PkiConfirmContent ::= NULL
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Cmp.PkiFailureInfo">
            <pre>
            PKIFailureInfo ::= BIT STRING {
            badAlg               (0),
              -- unrecognized or unsupported Algorithm Identifier
            badMessageCheck      (1), -- integrity check failed (e.g., signature did not verify)
            badRequest           (2),
              -- transaction not permitted or supported
            badTime              (3), -- messageTime was not sufficiently close to the system time, as defined by local policy
            badCertId            (4), -- no certificate could be found matching the provided criteria
            badDataFormat        (5),
              -- the data submitted has the wrong format
            wrongAuthority       (6), -- the authority indicated in the request is different from the one creating the response token
            incorrectData        (7), -- the requester's data is incorrect (for notary services)
            missingTimeStamp     (8), -- when the timestamp is missing but should be there (by policy)
            badPOP               (9)  -- the proof-of-possession failed
            certRevoked         (10),
            certConfirmed       (11),
            wrongIntegrity      (12),
            badRecipientNonce   (13), 
            timeNotAvailable    (14),
              -- the TSA's time source is not available
            unacceptedPolicy    (15),
              -- the requested TSA policy is not supported by the TSA
            unacceptedExtension (16),
              -- the requested extension is not supported by the TSA
            addInfoNotAvailable (17)
              -- the additional information requested could not be understood
              -- or is not available
            badSenderNonce      (18),
            badCertTemplate     (19),
            signerNotTrusted    (20),
            transactionIdInUse  (21),
            unsupportedVersion  (22),
            notAuthorized       (23),
            systemUnavail       (24),    
            systemFailure       (25),
              -- the request cannot be handled due to system failure
            duplicateCertReq    (26) 
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.PkiFailureInfo.#ctor(System.Int32)">
            Basic constructor.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.Cmp.PkiFreeText.Count">
            <summary>
            Return the number of string elements present
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Asn1.Cmp.PkiFreeText.Item(System.Int32)">
             Return the UTF8STRING at index.
            
             @param index index of the string of interest
             @return the string at index.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.PkiFreeText.ToAsn1Object">
            <pre>
            PkiFreeText ::= SEQUENCE SIZE (1..MAX) OF UTF8String
            </pre>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Cmp.PkiHeader.NULL_NAME">
            Value for a "null" recipient or sender.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.PkiHeader.ToAsn1Object">
            <pre>
             PkiHeader ::= SEQUENCE {
                       pvno                INTEGER     { cmp1999(1), cmp2000(2) },
                       sender              GeneralName,
                       -- identifies the sender
                       recipient           GeneralName,
                       -- identifies the intended recipient
                       messageTime     [0] GeneralizedTime         OPTIONAL,
                       -- time of production of this message (used when sender
                       -- believes that the transport will be "suitable"; i.e.,
                       -- that the time will still be meaningful upon receipt)
                       protectionAlg   [1] AlgorithmIdentifier     OPTIONAL,
                       -- algorithm used for calculation of protection bits
                       senderKID       [2] KeyIdentifier           OPTIONAL,
                       recipKID        [3] KeyIdentifier           OPTIONAL,
                       -- to identify specific keys used for protection
                       transactionID   [4] OCTET STRING            OPTIONAL,
                       -- identifies the transaction; i.e., this will be the same in
                       -- corresponding request, response, certConf, and PKIConf
                       -- messages
                       senderNonce     [5] OCTET STRING            OPTIONAL,
                       recipNonce      [6] OCTET STRING            OPTIONAL,
                       -- nonces used to provide replay protection, senderNonce
                       -- is inserted by the creator of this message; recipNonce
                       -- is a nonce previously inserted in a related message by
                       -- the intended recipient of this message
                       freeText        [7] PKIFreeText             OPTIONAL,
                       -- this may be used to indicate context-specific instructions
                       -- (this field is intended for human consumption)
                       generalInfo     [8] SEQUENCE SIZE (1..MAX) OF
                                            InfoTypeAndValue     OPTIONAL
                       -- this may be used to convey context-specific information
                       -- (this field not primarily intended for human consumption)
            }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.PkiHeaderBuilder.Build">
            <pre>
             PKIHeader ::= SEQUENCE {
                       pvno                INTEGER     { cmp1999(1), cmp2000(2) },
                       sender              GeneralName,
                       -- identifies the sender
                       recipient           GeneralName,
                       -- identifies the intended recipient
                       messageTime     [0] GeneralizedTime         OPTIONAL,
                       -- time of production of this message (used when sender
                       -- believes that the transport will be "suitable"; i.e.,
                       -- that the time will still be meaningful upon receipt)
                       protectionAlg   [1] AlgorithmIdentifier     OPTIONAL,
                       -- algorithm used for calculation of protection bits
                       senderKID       [2] KeyIdentifier           OPTIONAL,
                       recipKID        [3] KeyIdentifier           OPTIONAL,
                       -- to identify specific keys used for protection
                       transactionID   [4] OCTET STRING            OPTIONAL,
                       -- identifies the transaction; i.e., this will be the same in
                       -- corresponding request, response, certConf, and PKIConf
                       -- messages
                       senderNonce     [5] OCTET STRING            OPTIONAL,
                       recipNonce      [6] OCTET STRING            OPTIONAL,
                       -- nonces used to provide replay protection, senderNonce
                       -- is inserted by the creator of this message; recipNonce
                       -- is a nonce previously inserted in a related message by
                       -- the intended recipient of this message
                       freeText        [7] PKIFreeText             OPTIONAL,
                       -- this may be used to indicate context-specific instructions
                       -- (this field is intended for human consumption)
                       generalInfo     [8] SEQUENCE SIZE (1..MAX) OF
                                            InfoTypeAndValue     OPTIONAL
                       -- this may be used to convey context-specific information
                       -- (this field not primarily intended for human consumption)
            }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.PkiMessage.#ctor(Org.BouncyCastle.Asn1.Cmp.PkiHeader,Org.BouncyCastle.Asn1.Cmp.PkiBody,Org.BouncyCastle.Asn1.DerBitString,Org.BouncyCastle.Asn1.Cmp.CmpCertificate[])">
             Creates a new PkiMessage.
            
             @param header message header
             @param body message body
             @param protection message protection (may be null)
             @param extraCerts extra certificates (may be null)
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.PkiMessage.ToAsn1Object">
            <pre>
            PkiMessage ::= SEQUENCE {
                             header           PKIHeader,
                             body             PKIBody,
                             protection   [0] PKIProtection OPTIONAL,
                             extraCerts   [1] SEQUENCE SIZE (1..MAX) OF CMPCertificate
                                                                                OPTIONAL
            }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.PkiMessages.ToAsn1Object">
            <pre>
            PkiMessages ::= SEQUENCE SIZE (1..MAX) OF PkiMessage
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.PkiStatusInfo.#ctor(System.Int32)">
            @param status
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.PkiStatusInfo.#ctor(System.Int32,Org.BouncyCastle.Asn1.Cmp.PkiFreeText)">
            @param status
            @param statusString
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.PkiStatusInfo.ToAsn1Object">
             <pre>
             PkiStatusInfo ::= SEQUENCE {
                 status        PKIStatus,                (INTEGER)
                 statusString  PkiFreeText     OPTIONAL,
                 failInfo      PkiFailureInfo  OPTIONAL  (BIT STRING)
             }
            
             PKIStatus:
               granted                (0), -- you got exactly what you asked for
               grantedWithMods        (1), -- you got something like what you asked for
               rejection              (2), -- you don't get it, more information elsewhere in the message
               waiting                (3), -- the request body part has not yet been processed, expect to hear more later
               revocationWarning      (4), -- this message contains a warning that a revocation is imminent
               revocationNotification (5), -- notification that a revocation has occurred
               keyUpdateWarning       (6)  -- update already done for the oldCertId specified in CertReqMsg
            
             PkiFailureInfo:
               badAlg           (0), -- unrecognized or unsupported Algorithm Identifier
               badMessageCheck  (1), -- integrity check failed (e.g., signature did not verify)
               badRequest       (2), -- transaction not permitted or supported
               badTime          (3), -- messageTime was not sufficiently close to the system time, as defined by local policy
               badCertId        (4), -- no certificate could be found matching the provided criteria
               badDataFormat    (5), -- the data submitted has the wrong format
               wrongAuthority   (6), -- the authority indicated in the request is different from the one creating the response token
               incorrectData    (7), -- the requester's data is incorrect (for notary services)
               missingTimeStamp (8), -- when the timestamp is missing but should be there (by policy)
               badPOP           (9)  -- the proof-of-possession failed
            
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.PollRepContent.ToAsn1Object">
            <pre>
            PollRepContent ::= SEQUENCE OF SEQUENCE {
                    certReqId              INTEGER,
                    checkAfter             INTEGER,  -- time in seconds
                    reason                 PKIFreeText OPTIONAL
                }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.PollReqContent.ToAsn1Object">
            <pre>
            PollReqContent ::= SEQUENCE OF SEQUENCE {
                                   certReqId              INTEGER
            }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.PopoDecKeyChallContent.ToAsn1Object">
            <pre>
            PopoDecKeyChallContent ::= SEQUENCE OF Challenge
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.PopoDecKeyRespContent.ToAsn1Object">
            <pre>
            PopoDecKeyRespContent ::= SEQUENCE OF INTEGER
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.ProtectedPart.ToAsn1Object">
            <pre>
            ProtectedPart ::= SEQUENCE {
                               header    PKIHeader,
                               body      PKIBody
            }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.RevAnnContent.ToAsn1Object">
            <pre>
            RevAnnContent ::= SEQUENCE {
                  status              PKIStatus,
                  certId              CertId,
                  willBeRevokedAt     GeneralizedTime,
                  badSinceDate        GeneralizedTime,
                  crlDetails          Extensions  OPTIONAL
                   -- extra CRL details (e.g., crl number, reason, location, etc.)
            }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.RevDetails.ToAsn1Object">
            <pre>
            RevDetails ::= SEQUENCE {
                             certDetails         CertTemplate,
                              -- allows requester to specify as much as they can about
                              -- the cert. for which revocation is requested
                              -- (e.g., for cases in which serialNumber is not available)
                              crlEntryDetails     Extensions       OPTIONAL
                              -- requested crlEntryExtensions
                        }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.RevRepContent.ToAsn1Object">
            <pre>
            RevRepContent ::= SEQUENCE {
                   status       SEQUENCE SIZE (1..MAX) OF PKIStatusInfo,
                   -- in same order as was sent in RevReqContent
                   revCerts [0] SEQUENCE SIZE (1..MAX) OF CertId OPTIONAL,
                   -- IDs for which revocation was requested
                   -- (same order as status)
                   crls     [1] SEQUENCE SIZE (1..MAX) OF CertificateList OPTIONAL
                   -- the resulting CRLs (there may be more than one)
              }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.RevReqContent.ToAsn1Object">
            <pre>
            RevReqContent ::= SEQUENCE OF RevDetails
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.Attribute.GetInstance(System.Object)">
             return an Attribute object from the given object.
            
             @param o the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.Attribute.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            Attribute ::= SEQUENCE {
                attrType OBJECT IDENTIFIER,
                attrValues SET OF AttributeValue
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.Attributes.ToAsn1Object">
            <pre>
            Attributes ::=
              SET SIZE(1..MAX) OF Attribute -- according to RFC 5652
            </pre>
            @return
        </member>
        <member name="P:Org.BouncyCastle.Asn1.Cms.AttributeTable.Item(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Return the first attribute matching the given OBJECT IDENTIFIER</summary>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.AttributeTable.GetAll(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
             Return all the attributes matching the OBJECT IDENTIFIER oid. The vector will be
             empty if there are no attributes of the required type present.
            
             @param oid type of attribute required.
             @return a vector of all the attributes found of type oid.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.AttributeTable.Add(Org.BouncyCastle.Asn1.DerObjectIdentifier,Org.BouncyCastle.Asn1.Asn1Encodable)">
             Return a new table with the passed in attribute added.
            
             @param attrType
             @param attrValue
             @return
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.AuthenticatedData.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an AuthenticatedData object from a tagged object.
            
             @param obj      the tagged object holding the object we want.
             @param isExplicit true if the object is meant to be explicitly
                             tagged false otherwise.
             @throws ArgumentException if the object held by the
                                              tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.AuthenticatedData.GetInstance(System.Object)">
             return an AuthenticatedData object from the given object.
            
             @param obj the object we want converted.
             @throws ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.AuthenticatedData.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <pre>
             AuthenticatedData ::= SEQUENCE {
                   version CMSVersion,
                   originatorInfo [0] IMPLICIT OriginatorInfo OPTIONAL,
                   recipientInfos RecipientInfos,
                   macAlgorithm MessageAuthenticationCodeAlgorithm,
                   digestAlgorithm [1] DigestAlgorithmIdentifier OPTIONAL,
                   encapContentInfo EncapsulatedContentInfo,
                   authAttrs [2] IMPLICIT AuthAttributes OPTIONAL,
                   mac MessageAuthenticationCode,
                   unauthAttrs [3] IMPLICIT UnauthAttributes OPTIONAL }
            
             AuthAttributes ::= SET SIZE (1..MAX) OF Attribute
            
             UnauthAttributes ::= SET SIZE (1..MAX) OF Attribute
            
             MessageAuthenticationCode ::= OCTET STRING
             </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Cms.AuthenticatedDataParser">
             Produce an object suitable for an Asn1OutputStream.
             <pre>
             AuthenticatedData ::= SEQUENCE {
                   version CMSVersion,
                   originatorInfo [0] IMPLICIT OriginatorInfo OPTIONAL,
                   recipientInfos RecipientInfos,
                   macAlgorithm MessageAuthenticationCodeAlgorithm,
                   digestAlgorithm [1] DigestAlgorithmIdentifier OPTIONAL,
                   encapContentInfo EncapsulatedContentInfo,
                   authAttrs [2] IMPLICIT AuthAttributes OPTIONAL,
                   mac MessageAuthenticationCode,
                   unauthAttrs [3] IMPLICIT UnauthAttributes OPTIONAL }
            
             AuthAttributes ::= SET SIZE (1..MAX) OF Attribute
            
             UnauthAttributes ::= SET SIZE (1..MAX) OF Attribute
            
             MessageAuthenticationCode ::= OCTET STRING
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.AuthEnvelopedData.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an AuthEnvelopedData object from a tagged object.
            
             @param obj      the tagged object holding the object we want.
             @param isExplicit true if the object is meant to be explicitly
                             tagged false otherwise.
             @throws ArgumentException if the object held by the
                                              tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.AuthEnvelopedData.GetInstance(System.Object)">
             return an AuthEnvelopedData object from the given object.
            
             @param obj the object we want converted.
             @throws ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.AuthEnvelopedData.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            AuthEnvelopedData ::= SEQUENCE {
              version CMSVersion,
              originatorInfo [0] IMPLICIT OriginatorInfo OPTIONAL,
              recipientInfos RecipientInfos,
              authEncryptedContentInfo EncryptedContentInfo,
              authAttrs [1] IMPLICIT AuthAttributes OPTIONAL,
              mac MessageAuthenticationCode,
              unauthAttrs [2] IMPLICIT UnauthAttributes OPTIONAL }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Cms.AuthEnvelopedDataParser">
            Produce an object suitable for an Asn1OutputStream.
            
            <pre>
            AuthEnvelopedData ::= SEQUENCE {
              version CMSVersion,
              originatorInfo [0] IMPLICIT OriginatorInfo OPTIONAL,
              recipientInfos RecipientInfos,
              authEncryptedContentInfo EncryptedContentInfo,
              authAttrs [1] IMPLICIT AuthAttributes OPTIONAL,
              mac MessageAuthenticationCode,
              unauthAttrs [2] IMPLICIT UnauthAttributes OPTIONAL }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Cms.CmsAlgorithmProtection">
            From RFC 6211
            <pre>
            CMSAlgorithmProtection ::= SEQUENCE {
               digestAlgorithm         DigestAlgorithmIdentifier,
               signatureAlgorithm  [1] SignatureAlgorithmIdentifier OPTIONAL,
               macAlgorithm        [2] MessageAuthenticationCodeAlgorithm
                                                OPTIONAL
            }
            (WITH COMPONENTS { signatureAlgorithm PRESENT,
                               macAlgorithm ABSENT } |
             WITH COMPONENTS { signatureAlgorithm ABSENT,
                               macAlgorithm PRESENT })
            </pre>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Cms.CmsObjectIdentifiers.id_ri">
            The other Revocation Info arc
            id-ri OBJECT IDENTIFIER ::= { iso(1) identified-organization(3)
                                              dod(6) internet(1) security(5) mechanisms(5) pkix(7) ri(16) }
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Cms.CompressedData">
            RFC 3274 - CMS Compressed Data.
            <pre>
            CompressedData ::= Sequence {
             version CMSVersion,
             compressionAlgorithm CompressionAlgorithmIdentifier,
             encapContentInfo EncapsulatedContentInfo
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.CompressedData.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a CompressedData object from a tagged object.
            
             @param ato the tagged object holding the object we want.
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.CompressedData.GetInstance(System.Object)">
             return a CompressedData object from the given object.
            
             @param _obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Cms.CompressedDataParser">
            RFC 3274 - CMS Compressed Data.
            <pre>
            CompressedData ::= SEQUENCE {
             version CMSVersion,
             compressionAlgorithm CompressionAlgorithmIdentifier,
             encapContentInfo EncapsulatedContentInfo
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.ContentInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            ContentInfo ::= Sequence {
                     contentType ContentType,
                     content
                     [0] EXPLICIT ANY DEFINED BY contentType OPTIONAL }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Cms.ContentInfoParser">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            ContentInfo ::= SEQUENCE {
                     contentType ContentType,
                     content
                     [0] EXPLICIT ANY DEFINED BY contentType OPTIONAL }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.Ecc.MQVuserKeyingMaterial.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an AuthEnvelopedData object from a tagged object.
            
             @param obj      the tagged object holding the object we want.
             @param isExplicit true if the object is meant to be explicitly
                             tagged false otherwise.
             @throws ArgumentException if the object held by the
                                              tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.Ecc.MQVuserKeyingMaterial.GetInstance(System.Object)">
             return an AuthEnvelopedData object from the given object.
            
             @param obj the object we want converted.
             @throws ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.Ecc.MQVuserKeyingMaterial.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            MQVuserKeyingMaterial ::= SEQUENCE {
              ephemeralPublicKey OriginatorPublicKey,
              addedukm [0] EXPLICIT UserKeyingMaterial OPTIONAL  }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.EncryptedContentInfo.GetInstance(System.Object)">
             return an EncryptedContentInfo object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.EncryptedContentInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            EncryptedContentInfo ::= Sequence {
                contentType ContentType,
                contentEncryptionAlgorithm ContentEncryptionAlgorithmIdentifier,
                encryptedContent [0] IMPLICIT EncryptedContent OPTIONAL
            }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Cms.EncryptedContentInfoParser">
            <pre>
            EncryptedContentInfo ::= SEQUENCE {
                contentType ContentType,
                contentEncryptionAlgorithm ContentEncryptionAlgorithmIdentifier,
                encryptedContent [0] IMPLICIT EncryptedContent OPTIONAL
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.EncryptedData.ToAsn1Object">
            <pre>
                  EncryptedData ::= SEQUENCE {
                                version CMSVersion,
                                encryptedContentInfo EncryptedContentInfo,
                                unprotectedAttrs [1] IMPLICIT UnprotectedAttributes OPTIONAL }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.EnvelopedData.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an EnvelopedData object from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.EnvelopedData.GetInstance(System.Object)">
             return an EnvelopedData object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.EnvelopedData.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            EnvelopedData ::= Sequence {
                version CMSVersion,
                originatorInfo [0] IMPLICIT OriginatorInfo OPTIONAL,
                recipientInfos RecipientInfos,
                encryptedContentInfo EncryptedContentInfo,
                unprotectedAttrs [1] IMPLICIT UnprotectedAttributes OPTIONAL
            }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Cms.EnvelopedDataParser">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            EnvelopedData ::= SEQUENCE {
                version CMSVersion,
                originatorInfo [0] IMPLICIT OriginatorInfo OPTIONAL,
                recipientInfos RecipientInfos,
                encryptedContentInfo EncryptedContentInfo,
                unprotectedAttrs [1] IMPLICIT UnprotectedAttributes OPTIONAL
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KekIdentifier.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a KekIdentifier object from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KekIdentifier.GetInstance(System.Object)">
             return a KekIdentifier object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KekIdentifier.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            KekIdentifier ::= Sequence {
                keyIdentifier OCTET STRING,
                date GeneralizedTime OPTIONAL,
                other OtherKeyAttribute OPTIONAL
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KekRecipientInfo.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a KekRecipientInfo object from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KekRecipientInfo.GetInstance(System.Object)">
             return a KekRecipientInfo object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KekRecipientInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            KekRecipientInfo ::= Sequence {
                version CMSVersion,  -- always set to 4
                kekID KekIdentifier,
                keyEncryptionAlgorithm KeyEncryptionAlgorithmIdentifier,
                encryptedKey EncryptedKey
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KeyAgreeRecipientIdentifier.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an KeyAgreeRecipientIdentifier object from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param isExplicit true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KeyAgreeRecipientIdentifier.GetInstance(System.Object)">
             return an KeyAgreeRecipientIdentifier object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KeyAgreeRecipientIdentifier.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            KeyAgreeRecipientIdentifier ::= CHOICE {
                issuerAndSerialNumber IssuerAndSerialNumber,
                rKeyId [0] IMPLICIT RecipientKeyIdentifier
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KeyAgreeRecipientInfo.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a KeyAgreeRecipientInfo object from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KeyAgreeRecipientInfo.GetInstance(System.Object)">
             return a KeyAgreeRecipientInfo object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KeyAgreeRecipientInfo.ToAsn1Object">
                     * Produce an object suitable for an Asn1OutputStream.
                     * <pre>
                     * KeyAgreeRecipientInfo ::= Sequence {
                     *     version CMSVersion,  -- always set to 3
                     *     originator [0] EXPLICIT OriginatorIdentifierOrKey,
                     *     ukm [1] EXPLICIT UserKeyingMaterial OPTIONAL,
                     *     keyEncryptionAlgorithm KeyEncryptionAlgorithmIdentifier,
                     *     recipientEncryptedKeys RecipientEncryptedKeys
                     * }
            		 *
            		 * UserKeyingMaterial ::= OCTET STRING
                     * </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KeyTransRecipientInfo.GetInstance(System.Object)">
             return a KeyTransRecipientInfo object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KeyTransRecipientInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            KeyTransRecipientInfo ::= Sequence {
                version CMSVersion,  -- always set to 0 or 2
                rid RecipientIdentifier,
                keyEncryptionAlgorithm KeyEncryptionAlgorithmIdentifier,
                encryptedKey EncryptedKey
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.MetaData.ToAsn1Object">
            <pre>
            MetaData ::= SEQUENCE {
              hashProtected        BOOLEAN,
              fileName             UTF8String OPTIONAL,
              mediaType            IA5String OPTIONAL,
              otherMetaData        Attributes OPTIONAL
            }
            </pre>
            @return
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OriginatorIdentifierOrKey.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an OriginatorIdentifierOrKey object from a tagged object.
            
             @param o the tagged object holding the object we want.
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OriginatorIdentifierOrKey.GetInstance(System.Object)">
             return an OriginatorIdentifierOrKey object from the given object.
            
             @param o the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OriginatorIdentifierOrKey.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <pre>
             OriginatorIdentifierOrKey ::= CHOICE {
                 issuerAndSerialNumber IssuerAndSerialNumber,
                 subjectKeyIdentifier [0] SubjectKeyIdentifier,
                 originatorKey [1] OriginatorPublicKey
             }
            
             SubjectKeyIdentifier ::= OCTET STRING
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OriginatorInfo.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an OriginatorInfo object from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OriginatorInfo.GetInstance(System.Object)">
             return an OriginatorInfo object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OriginatorInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            OriginatorInfo ::= Sequence {
                certs [0] IMPLICIT CertificateSet OPTIONAL,
                crls [1] IMPLICIT CertificateRevocationLists OPTIONAL
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OriginatorPublicKey.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an OriginatorPublicKey object from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OriginatorPublicKey.GetInstance(System.Object)">
             return an OriginatorPublicKey object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OriginatorPublicKey.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            OriginatorPublicKey ::= Sequence {
                algorithm AlgorithmIdentifier,
                publicKey BIT STRING
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OtherKeyAttribute.GetInstance(System.Object)">
             return an OtherKeyAttribute object from the given object.
            
             @param o the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OtherKeyAttribute.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            OtherKeyAttribute ::= Sequence {
                keyAttrId OBJECT IDENTIFIER,
                keyAttr ANY DEFINED BY keyAttrId OPTIONAL
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OtherRecipientInfo.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a OtherRecipientInfo object from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OtherRecipientInfo.GetInstance(System.Object)">
             return a OtherRecipientInfo object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OtherRecipientInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            OtherRecipientInfo ::= Sequence {
               oriType OBJECT IDENTIFIER,
               oriValue ANY DEFINED BY oriType }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OtherRevocationInfoFormat.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a OtherRevocationInfoFormat object from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param explicit true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception IllegalArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OtherRevocationInfoFormat.GetInstance(System.Object)">
             return a OtherRevocationInfoFormat object from the given object.
            
             @param obj the object we want converted.
             @exception IllegalArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OtherRevocationInfoFormat.ToAsn1Object">
            Produce an object suitable for an ASN1OutputStream.
            <pre>
            OtherRevocationInfoFormat ::= SEQUENCE {
                 otherRevInfoFormat OBJECT IDENTIFIER,
                 otherRevInfo ANY DEFINED BY otherRevInfoFormat }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.PasswordRecipientInfo.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a PasswordRecipientInfo object from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.PasswordRecipientInfo.GetInstance(System.Object)">
             return a PasswordRecipientInfo object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.PasswordRecipientInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            PasswordRecipientInfo ::= Sequence {
              version CMSVersion,   -- Always set to 0
              keyDerivationAlgorithm [0] KeyDerivationAlgorithmIdentifier
                                        OPTIONAL,
             keyEncryptionAlgorithm KeyEncryptionAlgorithmIdentifier,
             encryptedKey EncryptedKey }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.RecipientEncryptedKey.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an RecipientEncryptedKey object from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param isExplicit true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.RecipientEncryptedKey.GetInstance(System.Object)">
             return a RecipientEncryptedKey object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.RecipientEncryptedKey.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            RecipientEncryptedKey ::= SEQUENCE {
                rid KeyAgreeRecipientIdentifier,
                encryptedKey EncryptedKey
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.RecipientIdentifier.GetInstance(System.Object)">
             return a RecipientIdentifier object from the given object.
            
             @param o the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.RecipientIdentifier.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <pre>
             RecipientIdentifier ::= CHOICE {
                 issuerAndSerialNumber IssuerAndSerialNumber,
                 subjectKeyIdentifier [0] SubjectKeyIdentifier
             }
            
             SubjectKeyIdentifier ::= OCTET STRING
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.RecipientInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            RecipientInfo ::= CHOICE {
                ktri KeyTransRecipientInfo,
                kari [1] KeyAgreeRecipientInfo,
                kekri [2] KekRecipientInfo,
                pwri [3] PasswordRecipientInfo,
                ori [4] OtherRecipientInfo }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.RecipientKeyIdentifier.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a RecipientKeyIdentifier object from a tagged object.
            
             @param _ato the tagged object holding the object we want.
             @param _explicit true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.RecipientKeyIdentifier.GetInstance(System.Object)">
             return a RecipientKeyIdentifier object from the given object.
            
             @param _obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.RecipientKeyIdentifier.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <pre>
             RecipientKeyIdentifier ::= Sequence {
                 subjectKeyIdentifier SubjectKeyIdentifier,
                 date GeneralizedTime OPTIONAL,
                 other OtherKeyAttribute OPTIONAL
             }
            
             SubjectKeyIdentifier ::= OCTET STRING
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.ScvpReqRes.ToAsn1Object">
            <pre>
               ScvpReqRes ::= SEQUENCE {
               request  [0] EXPLICIT ContentInfo OPTIONAL,
               response     ContentInfo }
            </pre>
            @return  the ASN.1 primitive representation.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Cms.SignedData">
            a signed data object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.SignedData.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            SignedData ::= Sequence {
                version CMSVersion,
                digestAlgorithms DigestAlgorithmIdentifiers,
                encapContentInfo EncapsulatedContentInfo,
                certificates [0] IMPLICIT CertificateSet OPTIONAL,
                crls [1] IMPLICIT CertificateRevocationLists OPTIONAL,
                signerInfos SignerInfos
              }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Cms.SignedDataParser">
            <pre>
            SignedData ::= SEQUENCE {
                version CMSVersion,
                digestAlgorithms DigestAlgorithmIdentifiers,
                encapContentInfo EncapsulatedContentInfo,
                certificates [0] IMPLICIT CertificateSet OPTIONAL,
                crls [1] IMPLICIT CertificateRevocationLists OPTIONAL,
                signerInfos SignerInfos
              }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.SignerIdentifier.GetInstance(System.Object)">
             return a SignerIdentifier object from the given object.
            
             @param o the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.SignerIdentifier.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <pre>
             SignerIdentifier ::= CHOICE {
                 issuerAndSerialNumber IssuerAndSerialNumber,
                 subjectKeyIdentifier [0] SubjectKeyIdentifier
             }
            
             SubjectKeyIdentifier ::= OCTET STRING
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.SignerInfo.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <pre>
              SignerInfo ::= Sequence {
                  version Version,
                  SignerIdentifier sid,
                  digestAlgorithm DigestAlgorithmIdentifier,
                  authenticatedAttributes [0] IMPLICIT Attributes OPTIONAL,
                  digestEncryptionAlgorithm DigestEncryptionAlgorithmIdentifier,
                  encryptedDigest EncryptedDigest,
                  unauthenticatedAttributes [1] IMPLICIT Attributes OPTIONAL
              }
            
              EncryptedDigest ::= OCTET STRING
            
              DigestAlgorithmIdentifier ::= AlgorithmIdentifier
            
              DigestEncryptionAlgorithmIdentifier ::= AlgorithmIdentifier
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.Time.#ctor(System.DateTime)">
            creates a time object from a given date - if the date is between 1950
            and 2049 a UTCTime object is Generated, otherwise a GeneralizedTime
            is used.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.Time.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            Time ::= CHOICE {
                        utcTime        UTCTime,
                        generalTime    GeneralizedTime }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.TimeStampAndCrl.ToAsn1Object">
            <pre>
            TimeStampAndCRL ::= SEQUENCE {
                timeStamp   TimeStampToken,          -- according to RFC 3161
                crl         CertificateList OPTIONAL -- according to RFC 5280
             }
            </pre>
            @return
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.TimeStampedData.ToAsn1Object">
            <pre>
            TimeStampedData ::= SEQUENCE {
              version              INTEGER { v1(1) },
              dataUri              IA5String OPTIONAL,
              metaData             MetaData OPTIONAL,
              content              OCTET STRING OPTIONAL,
              temporalEvidence     Evidence
            }
            </pre>
            @return
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.TimeStampTokenEvidence.ToAsn1Object">
            <pre>
            TimeStampTokenEvidence ::=
               SEQUENCE SIZE(1..MAX) OF TimeStampAndCrl
            </pre>
            @return
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.AttributeTypeAndValue.ToAsn1Object">
            <pre>
            AttributeTypeAndValue ::= SEQUENCE {
                      type         OBJECT IDENTIFIER,
                      value        ANY DEFINED BY type }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.CertId.ToAsn1Object">
            <pre>
            CertId ::= SEQUENCE {
                            issuer           GeneralName,
                            serialNumber     INTEGER }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.CertReqMessages.ToAsn1Object">
            <pre>
            CertReqMessages ::= SEQUENCE SIZE (1..MAX) OF CertReqMsg
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.CertReqMsg.#ctor(Org.BouncyCastle.Asn1.Crmf.CertRequest,Org.BouncyCastle.Asn1.Crmf.ProofOfPossession,Org.BouncyCastle.Asn1.Crmf.AttributeTypeAndValue[])">
            Creates a new CertReqMsg.
            @param certReq CertRequest
            @param popo may be null
            @param regInfo may be null
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.CertReqMsg.ToAsn1Object">
            <pre>
            CertReqMsg ::= SEQUENCE {
                               certReq   CertRequest,
                               pop       ProofOfPossession  OPTIONAL,
                               -- content depends upon key type
                               regInfo   SEQUENCE SIZE(1..MAX) OF AttributeTypeAndValue OPTIONAL }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.CertRequest.ToAsn1Object">
            <pre>
            CertRequest ::= SEQUENCE {
                                 certReqId     INTEGER,          -- ID for matching request and reply
                                 certTemplate  CertTemplate,  -- Selected fields of cert to be issued
                                 controls      Controls OPTIONAL }   -- Attributes affecting issuance
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.CertTemplate.ToAsn1Object">
            <pre>
             CertTemplate ::= SEQUENCE {
                 version      [0] Version               OPTIONAL,
                 serialNumber [1] INTEGER               OPTIONAL,
                 signingAlg   [2] AlgorithmIdentifier   OPTIONAL,
                 issuer       [3] Name                  OPTIONAL,
                 validity     [4] OptionalValidity      OPTIONAL,
                 subject      [5] Name                  OPTIONAL,
                 publicKey    [6] SubjectPublicKeyInfo  OPTIONAL,
                 issuerUID    [7] UniqueIdentifier      OPTIONAL,
                 subjectUID   [8] UniqueIdentifier      OPTIONAL,
                 extensions   [9] Extensions            OPTIONAL }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.CertTemplateBuilder.SetVersion(System.Int32)">
            Sets the X.509 version. Note: for X509v3, use 2 here. 
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.CertTemplateBuilder.SetIssuerUID(Org.BouncyCastle.Asn1.DerBitString)">
            Sets the issuer unique ID (deprecated in X.509v3) 
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.CertTemplateBuilder.SetSubjectUID(Org.BouncyCastle.Asn1.DerBitString)">
            Sets the subject unique ID (deprecated in X.509v3) 
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.CertTemplateBuilder.Build">
            <pre>
             CertTemplate ::= SEQUENCE {
                 version      [0] Version               OPTIONAL,
                 serialNumber [1] INTEGER               OPTIONAL,
                 signingAlg   [2] AlgorithmIdentifier   OPTIONAL,
                 issuer       [3] Name                  OPTIONAL,
                 validity     [4] OptionalValidity      OPTIONAL,
                 subject      [5] Name                  OPTIONAL,
                 publicKey    [6] SubjectPublicKeyInfo  OPTIONAL,
                 issuerUID    [7] UniqueIdentifier      OPTIONAL,
                 subjectUID   [8] UniqueIdentifier      OPTIONAL,
                 extensions   [9] Extensions            OPTIONAL }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.Controls.ToAsn1Object">
            <pre>
            Controls  ::= SEQUENCE SIZE(1..MAX) OF AttributeTypeAndValue
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.EncKeyWithID.ToAsn1Object">
            <pre>
            EncKeyWithID ::= SEQUENCE {
                 privateKey           PrivateKeyInfo,
                 identifier CHOICE {
                    string               UTF8String,
                    generalName          GeneralName
                } OPTIONAL
            }
            </pre>
            @return
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.EncryptedKey.ToAsn1Object">
            <pre>
               EncryptedKey ::= CHOICE {
                   encryptedValue        EncryptedValue, -- deprecated
                   envelopedData     [0] EnvelopedData }
                   -- The encrypted private key MUST be placed in the envelopedData
                   -- encryptedContentInfo encryptedContent OCTET STRING.
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.EncryptedValue.ToAsn1Object">
            <pre>
            EncryptedValue ::= SEQUENCE {
                                intendedAlg   [0] AlgorithmIdentifier  OPTIONAL,
                                -- the intended algorithm for which the value will be used
                                symmAlg       [1] AlgorithmIdentifier  OPTIONAL,
                                -- the symmetric algorithm used to encrypt the value
                                encSymmKey    [2] BIT STRING           OPTIONAL,
                                -- the (encrypted) symmetric key used to encrypt the value
                                keyAlg        [3] AlgorithmIdentifier  OPTIONAL,
                                -- algorithm used to encrypt the symmetric key
                                valueHint     [4] OCTET STRING         OPTIONAL,
                                -- a brief description or identifier of the encValue content
                                -- (may be meaningful only to the sending entity, and used only
                                -- if EncryptedValue might be re-examined by the sending entity
                                -- in the future)
                                encValue       BIT STRING }
                                -- the encrypted value itself
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.OptionalValidity.ToAsn1Object">
            <pre>
            OptionalValidity ::= SEQUENCE {
                                   notBefore  [0] Time OPTIONAL,
                                   notAfter   [1] Time OPTIONAL } --at least one MUST be present
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.PkiArchiveOptions.ToAsn1Object">
            <pre>
             PkiArchiveOptions ::= CHOICE {
                 encryptedPrivKey     [0] EncryptedKey,
                 -- the actual value of the private key
                 keyGenParameters     [1] KeyGenParameters,
                 -- parameters which allow the private key to be re-generated
                 archiveRemGenPrivKey [2] BOOLEAN }
                 -- set to TRUE if sender wishes receiver to archive the private
                 -- key of a key pair that the receiver generates in response to
                 -- this request; set to FALSE if no archival is desired.
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.PkiPublicationInfo.ToAsn1Object">
            <pre>
            PkiPublicationInfo ::= SEQUENCE {
                             action     INTEGER {
                                            dontPublish (0),
                                            pleasePublish (1) },
                             pubInfos  SEQUENCE SIZE (1..MAX) OF SinglePubInfo OPTIONAL }
            -- pubInfos MUST NOT be present if action is "dontPublish"
            -- (if action is "pleasePublish" and pubInfos is omitted,
            -- "dontCare" is assumed)
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Crmf.PKMacValue">
            Password-based MAC value for use with POPOSigningKeyInput.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.PKMacValue.#ctor(Org.BouncyCastle.Asn1.Cmp.PbmParameter,Org.BouncyCastle.Asn1.DerBitString)">
            Creates a new PKMACValue.
            @param params parameters for password-based MAC
            @param value MAC of the DER-encoded SubjectPublicKeyInfo
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.PKMacValue.#ctor(Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier,Org.BouncyCastle.Asn1.DerBitString)">
            Creates a new PKMACValue.
            @param aid CMPObjectIdentifiers.passwordBasedMAC, with PBMParameter
            @param value MAC of the DER-encoded SubjectPublicKeyInfo
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.PKMacValue.ToAsn1Object">
            <pre>
            PKMACValue ::= SEQUENCE {
                 algId  AlgorithmIdentifier,
                 -- algorithm value shall be PasswordBasedMac 1.2.840.113533.7.66.13
                 -- parameter value is PBMParameter
                 value  BIT STRING }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.PopoPrivKey.ToAsn1Object">
            <pre>
            PopoPrivKey ::= CHOICE {
                   thisMessage       [0] BIT STRING,         -- Deprecated
                    -- possession is proven in this message (which contains the private
                    -- key itself (encrypted for the CA))
                   subsequentMessage [1] SubsequentMessage,
                    -- possession will be proven in a subsequent message
                   dhMAC             [2] BIT STRING,         -- Deprecated
                   agreeMAC          [3] PKMACValue,
                   encryptedKey      [4] EnvelopedData }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.PopoSigningKey.#ctor(Org.BouncyCastle.Asn1.Crmf.PopoSigningKeyInput,Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier,Org.BouncyCastle.Asn1.DerBitString)">
            Creates a new Proof of Possession object for a signing key.
            @param poposkIn the PopoSigningKeyInput structure, or null if the
                CertTemplate includes both subject and publicKey values.
            @param aid the AlgorithmIdentifier used to sign the proof of possession.
            @param signature a signature over the DER-encoded value of poposkIn,
                or the DER-encoded value of certReq if poposkIn is null.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.PopoSigningKey.ToAsn1Object">
            <pre>
            PopoSigningKey ::= SEQUENCE {
                                 poposkInput           [0] PopoSigningKeyInput OPTIONAL,
                                 algorithmIdentifier   AlgorithmIdentifier,
                                 signature             BIT STRING }
             -- The signature (using "algorithmIdentifier") is on the
             -- DER-encoded value of poposkInput.  NOTE: If the CertReqMsg
             -- certReq CertTemplate contains the subject and publicKey values,
             -- then poposkInput MUST be omitted and the signature MUST be
             -- computed on the DER-encoded value of CertReqMsg certReq.  If
             -- the CertReqMsg certReq CertTemplate does not contain the public
             -- key and subject values, then poposkInput MUST be present and
             -- MUST be signed.  This strategy ensures that the public key is
             -- not present in both the poposkInput and CertReqMsg certReq
             -- CertTemplate fields.
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.PopoSigningKeyInput.#ctor(Org.BouncyCastle.Asn1.X509.GeneralName,Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo)">
            Creates a new PopoSigningKeyInput with sender name as authInfo. 
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.PopoSigningKeyInput.#ctor(Org.BouncyCastle.Asn1.Crmf.PKMacValue,Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo)">
            Creates a new PopoSigningKeyInput using password-based MAC. 
        </member>
        <member name="P:Org.BouncyCastle.Asn1.Crmf.PopoSigningKeyInput.Sender">
            Returns the sender field, or null if authInfo is publicKeyMac 
        </member>
        <member name="P:Org.BouncyCastle.Asn1.Crmf.PopoSigningKeyInput.PublicKeyMac">
            Returns the publicKeyMac field, or null if authInfo is sender 
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.PopoSigningKeyInput.ToAsn1Object">
            <pre>
            PopoSigningKeyInput ::= SEQUENCE {
                   authInfo             CHOICE {
                                            sender              [0] GeneralName,
                                            -- used only if an authenticated identity has been
                                            -- established for the sender (e.g., a DN from a
                                            -- previously-issued and currently-valid certificate
                                            publicKeyMac        PKMacValue },
                                            -- used if no authenticated GeneralName currently exists for
                                            -- the sender; publicKeyMac contains a password-based MAC
                                            -- on the DER-encoded value of publicKey
                   publicKey           SubjectPublicKeyInfo }  -- from CertTemplate
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.ProofOfPossession.#ctor">
            Creates a ProofOfPossession with type raVerified. 
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.ProofOfPossession.#ctor(Org.BouncyCastle.Asn1.Crmf.PopoSigningKey)">
            Creates a ProofOfPossession for a signing key. 
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.ProofOfPossession.#ctor(System.Int32,Org.BouncyCastle.Asn1.Crmf.PopoPrivKey)">
            Creates a ProofOfPossession for key encipherment or agreement.
            @param type one of TYPE_KEY_ENCIPHERMENT or TYPE_KEY_AGREEMENT
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.ProofOfPossession.ToAsn1Object">
            <pre>
            ProofOfPossession ::= CHOICE {
                                      raVerified        [0] NULL,
                                      -- used if the RA has already verified that the requester is in
                                      -- possession of the private key
                                      signature         [1] PopoSigningKey,
                                      keyEncipherment   [2] PopoPrivKey,
                                      keyAgreement      [3] PopoPrivKey }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.SinglePubInfo.ToAsn1Object">
            <pre>
            SinglePubInfo ::= SEQUENCE {
                   pubMethod    INTEGER {
                      dontCare    (0),
                      x500        (1),
                      web         (2),
                      ldap        (3) },
                  pubLocation  GeneralName OPTIONAL }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.CryptoPro.ECGost3410NamedCurves">
            table of the available named parameters for GOST 3410-2001.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.CryptoPro.ECGost3410NamedCurves.GetByOid(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
             return the ECDomainParameters object for the given OID, null if it
             isn't present.
            
             @param oid an object identifier representing a named parameters, if present.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.CryptoPro.ECGost3410NamedCurves.Names">
            returns an enumeration containing the name strings for curves
            contained in this structure.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.CryptoPro.ECGost3410NamedCurves.GetName(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            return the named curve name represented by the given object identifier.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.CryptoPro.Gost28147Parameters.ToAsn1Object">
             <pre>
             Gost28147-89-Parameters ::=
                           SEQUENCE {
                                   iv                   Gost28147-89-IV,
                                   encryptionParamSet   OBJECT IDENTIFIER
                            }
            
               Gost28147-89-IV ::= OCTET STRING (SIZE (8))
             </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.CryptoPro.Gost3410NamedParameters">
            table of the available named parameters for GOST 3410-94.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.CryptoPro.Gost3410NamedParameters.GetByOid(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
             return the GOST3410ParamSetParameters object for the given OID, null if it
             isn't present.
            
             @param oid an object identifier representing a named parameters, if present.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.CryptoPro.Gost3410NamedParameters.Names">
            returns an enumeration containing the name strings for parameters
            contained in this structure.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerApplicationSpecific">
            Base class for an application specific object
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerApplicationSpecific.GetObject">
             Return the enclosed object assuming explicit tagging.
            
             @return  the resulting object
             @throws IOException if reconstruction fails.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerApplicationSpecific.GetObject(System.Int32)">
             Return the enclosed object assuming implicit tagging.
            
             @param derTagNo the type tag that should be applied to the object's contents.
             @return  the resulting object
             @throws IOException if reconstruction fails.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBitString.GetInstance(System.Object)">
             return a Bit string from the passed in object
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBitString.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a Bit string from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBitString.#ctor(System.Byte[],System.Int32)">
            @param data the octets making up the bit string.
            @param padBits the number of extra bits at the end of the string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBitString.GetOctets">
             Return the octets contained in this BIT STRING, checking that this BIT STRING really
             does represent an octet aligned string. Only use this method when the standard you are
             following dictates that the BIT STRING will be octet aligned.
            
             @return a copy of the octet aligned data.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.DerBitString.IntValue">
            @return the value of the bit string as an int (truncating if necessary)
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerBmpString">
            Der BMPString object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBmpString.GetInstance(System.Object)">
             return a BMP string from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBmpString.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a BMP string from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                          be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBmpString.#ctor(System.Byte[])">
            basic constructor - byte encoded string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBmpString.#ctor(System.String)">
            basic constructor
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBoolean.GetInstance(System.Object)">
             return a bool from the passed in object.
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBoolean.GetInstance(System.Boolean)">
            return a DerBoolean from the passed in bool.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBoolean.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a Boolean from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerEnumerated.GetInstance(System.Object)">
             return an integer from the passed in object
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerEnumerated.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an Enumerated from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerExternal">
            Class representing the DER-type External
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerExternal.#ctor(Org.BouncyCastle.Asn1.DerObjectIdentifier,Org.BouncyCastle.Asn1.DerInteger,Org.BouncyCastle.Asn1.Asn1Object,Org.BouncyCastle.Asn1.DerTaggedObject)">
            Creates a new instance of DerExternal
            See X.690 for more informations about the meaning of these parameters
            @param directReference The direct reference or <code>null</code> if not set.
            @param indirectReference The indirect reference or <code>null</code> if not set.
            @param dataValueDescriptor The data value descriptor or <code>null</code> if not set.
            @param externalData The external data in its encoded form.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerExternal.#ctor(Org.BouncyCastle.Asn1.DerObjectIdentifier,Org.BouncyCastle.Asn1.DerInteger,Org.BouncyCastle.Asn1.Asn1Object,System.Int32,Org.BouncyCastle.Asn1.Asn1Object)">
            Creates a new instance of DerExternal.
            See X.690 for more informations about the meaning of these parameters
            @param directReference The direct reference or <code>null</code> if not set.
            @param indirectReference The indirect reference or <code>null</code> if not set.
            @param dataValueDescriptor The data value descriptor or <code>null</code> if not set.
            @param encoding The encoding to be used for the external data
            @param externalData The external data
        </member>
        <member name="P:Org.BouncyCastle.Asn1.DerExternal.Encoding">
            The encoding of the content. Valid values are
            <ul>
            <li><code>0</code> single-ASN1-type</li>
            <li><code>1</code> OCTET STRING</li>
            <li><code>2</code> BIT STRING</li>
            </ul>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerGeneralizedTime">
            Generalized time object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerGeneralizedTime.GetInstance(System.Object)">
             return a generalized time from the passed in object
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerGeneralizedTime.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a Generalized Time object from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerGeneralizedTime.#ctor(System.String)">
             The correct format for this is YYYYMMDDHHMMSS[.f]Z, or without the Z
             for local time, or Z+-HHMM on the end, for difference between local
             time and UTC time. The fractional second amount f must consist of at
             least one number with trailing zeroes removed.
            
             @param time the time string.
             @exception ArgumentException if string is an illegal format.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerGeneralizedTime.#ctor(System.DateTime)">
            base constructor from a local time object
        </member>
        <member name="P:Org.BouncyCastle.Asn1.DerGeneralizedTime.TimeString">
            Return the time.
            @return The time string as it appeared in the encoded object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerGeneralizedTime.GetTime">
            return the time - always in the form of
             YYYYMMDDhhmmssGMT(+hh:mm|-hh:mm).
            <p>
            Normally in a certificate we would expect "Z" rather than "GMT",
            however adding the "GMT" means we can just use:
            <pre>
                dateF = new SimpleDateFormat("yyyyMMddHHmmssz");
            </pre>
            To read in the time and Get a date which is compatible with our local
            time zone.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerGraphicString.GetInstance(System.Object)">
             return a Graphic String from the passed in object
            
             @param obj a DerGraphicString or an object that can be converted into one.
             @exception IllegalArgumentException if the object cannot be converted.
             @return a DerGraphicString instance, or null.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerGraphicString.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a Graphic String from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicit true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception IllegalArgumentException if the tagged object cannot
                           be converted.
             @return a DerGraphicString instance, or null.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerGraphicString.#ctor(System.Byte[])">
            basic constructor - with bytes.
            @param string the byte encoding of the characters making up the string.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerIA5String">
            Der IA5String object - this is an ascii string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerIA5String.GetInstance(System.Object)">
             return a IA5 string from the passed in object
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerIA5String.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an IA5 string from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerIA5String.#ctor(System.Byte[])">
            basic constructor - with bytes.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerIA5String.#ctor(System.String)">
            basic constructor - without validation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerIA5String.#ctor(System.String,System.Boolean)">
             Constructor with optional validation.
            
             @param string the base string to wrap.
             @param validate whether or not to check the string.
             @throws ArgumentException if validate is true and the string
             contains characters that should not be in an IA5String.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerIA5String.IsIA5String(System.String)">
             return true if the passed in String can be represented without
             loss as an IA5String, false otherwise.
            
             @return true if in printable set, false otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerInteger.GetInstance(System.Object)">
             return an integer from the passed in object
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerInteger.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an Integer from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param isExplicit true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.DerInteger.PositiveValue">
            in some cases positive values Get crammed into a space,
            that's not quite big enough...
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerNull">
            A Null object.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerNumericString">
            Der NumericString object - this is an ascii string of characters {0,1,2,3,4,5,6,7,8,9, }.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerNumericString.GetInstance(System.Object)">
             return a Numeric string from the passed in object
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerNumericString.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an Numeric string from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerNumericString.#ctor(System.Byte[])">
            basic constructor - with bytes.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerNumericString.#ctor(System.String)">
            basic constructor -  without validation..
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerNumericString.#ctor(System.String,System.Boolean)">
             Constructor with optional validation.
            
             @param string the base string to wrap.
             @param validate whether or not to check the string.
             @throws ArgumentException if validate is true and the string
             contains characters that should not be in a NumericString.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerNumericString.IsNumericString(System.String)">
             Return true if the string can be represented as a NumericString ('0'..'9', ' ')
            
             @param str string to validate.
             @return true if numeric, fale otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerObjectIdentifier.GetInstance(System.Object)">
             return an Oid from the passed in object
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerObjectIdentifier.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an object Identifier from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerObjectIdentifier.On(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            Return  true if this oid is an extension of the passed in branch, stem.
            @param stem the arc or branch that is a possible parent.
            @return  true if the branch is on the passed in stem, false otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerObjectIdentifier.Intern">
            Intern will return a reference to a pooled version of this object, unless it
            is not present in which case intern will add it.
            <p>
            The pool is also used by the ASN.1 parsers to limit the number of duplicated OID
            objects in circulation.
            </p>
            @return a reference to the identifier in the pool.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerOctetString.#ctor(System.Byte[])">
            <param name="str">The octets making up the octet string.</param>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerPrintableString">
            Der PrintableString object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerPrintableString.GetInstance(System.Object)">
             return a printable string from the passed in object.
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerPrintableString.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a Printable string from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerPrintableString.#ctor(System.Byte[])">
            basic constructor - byte encoded string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerPrintableString.#ctor(System.String)">
            basic constructor - this does not validate the string
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerPrintableString.#ctor(System.String,System.Boolean)">
             Constructor with optional validation.
            
             @param string the base string to wrap.
             @param validate whether or not to check the string.
             @throws ArgumentException if validate is true and the string
             contains characters that should not be in a PrintableString.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerPrintableString.IsPrintableString(System.String)">
             return true if the passed in String can be represented without
             loss as a PrintableString, false otherwise.
            
             @return true if in printable set, false otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerSequence.#ctor">
            create an empty sequence
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerSequence.#ctor(Org.BouncyCastle.Asn1.Asn1Encodable)">
            create a sequence containing one object
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerSequence.#ctor(Org.BouncyCastle.Asn1.Asn1EncodableVector)">
            create a sequence containing a vector of objects.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerSet">
            A Der encoded set object
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerSet.#ctor">
            create an empty set
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerSet.#ctor(Org.BouncyCastle.Asn1.Asn1Encodable)">
            @param obj - a single object that makes up the set.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerSet.#ctor(Org.BouncyCastle.Asn1.Asn1EncodableVector)">
            @param v - a vector of objects making up the set.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerT61String">
            Der T61String (also the teletex string) - 8-bit characters
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerT61String.GetInstance(System.Object)">
             return a T61 string from the passed in object.
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerT61String.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an T61 string from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerT61String.#ctor(System.Byte[])">
            basic constructor - with bytes.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerT61String.#ctor(System.String)">
            basic constructor - with string.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerTaggedObject">
            DER TaggedObject - in ASN.1 notation this is any object preceded by
            a [n] where n is some number - these are assumed to follow the construction
            rules (as with sequences).
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerTaggedObject.#ctor(System.Int32,Org.BouncyCastle.Asn1.Asn1Encodable)">
            @param tagNo the tag number for this object.
            @param obj the tagged object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerTaggedObject.#ctor(System.Boolean,System.Int32,Org.BouncyCastle.Asn1.Asn1Encodable)">
            @param explicitly true if an explicitly tagged object.
            @param tagNo the tag number for this object.
            @param obj the tagged object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerTaggedObject.#ctor(System.Int32)">
            create an implicitly tagged object that contains a zero
            length sequence.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerUniversalString">
            Der UniversalString object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUniversalString.GetInstance(System.Object)">
             return a Universal string from the passed in object.
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUniversalString.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a Universal string from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUniversalString.#ctor(System.Byte[])">
            basic constructor - byte encoded string.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerUtcTime">
            UTC time object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUtcTime.GetInstance(System.Object)">
             return an UTC Time from the passed in object.
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUtcTime.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an UTC Time from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUtcTime.#ctor(System.String)">
            The correct format for this is YYMMDDHHMMSSZ (it used to be that seconds were
            never encoded. When you're creating one of these objects from scratch, that's
            what you want to use, otherwise we'll try to deal with whatever Gets read from
            the input stream... (this is why the input format is different from the GetTime()
            method output).
            <p>
            @param time the time string.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUtcTime.#ctor(System.DateTime)">
            base constructor from a DateTime object
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUtcTime.ToDateTime">
             return the time as a date based on whatever a 2 digit year will return. For
             standardised processing use ToAdjustedDateTime().
            
             @return the resulting date
             @exception ParseException if the date string cannot be parsed.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUtcTime.ToAdjustedDateTime">
             return the time as an adjusted date
             in the range of 1950 - 2049.
            
             @return a date in the range of 1950 to 2049.
             @exception ParseException if the date string cannot be parsed.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.DerUtcTime.TimeString">
            return the time - always in the form of
             YYMMDDhhmmssGMT(+hh:mm|-hh:mm).
            <p>
            Normally in a certificate we would expect "Z" rather than "GMT",
            however adding the "GMT" means we can just use:
            <pre>
                dateF = new SimpleDateFormat("yyMMddHHmmssz");
            </pre>
            To read in the time and Get a date which is compatible with our local
            time zone.</p>
            <p>
            <b>Note:</b> In some cases, due to the local date processing, this
            may lead to unexpected results. If you want to stick the normal
            convention of 1950 to 2049 use the GetAdjustedTime() method.</p>
        </member>
        <member name="P:Org.BouncyCastle.Asn1.DerUtcTime.AdjustedTimeString">
            <summary>
            Return a time string as an adjusted date with a 4 digit year.
            This goes in the range of 1950 - 2049.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerUtf8String">
            Der UTF8String object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUtf8String.GetInstance(System.Object)">
             return an UTF8 string from the passed in object.
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUtf8String.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an UTF8 string from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUtf8String.#ctor(System.Byte[])">
            basic constructor - byte encoded string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUtf8String.#ctor(System.String)">
            basic constructor
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerVideotexString.GetInstance(System.Object)">
             return a Videotex String from the passed in object
            
             @param obj a DERVideotexString or an object that can be converted into one.
             @exception IllegalArgumentException if the object cannot be converted.
             @return a DERVideotexString instance, or null.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerVideotexString.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a Videotex String from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicit true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception IllegalArgumentException if the tagged object cannot
                           be converted.
             @return a DERVideotexString instance, or null.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerVideotexString.#ctor(System.Byte[])">
            basic constructor - with bytes.
            @param string the byte encoding of the characters making up the string.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerVisibleString">
            Der VisibleString object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerVisibleString.GetInstance(System.Object)">
             return a Visible string from the passed in object.
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerVisibleString.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a Visible string from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerVisibleString.#ctor(System.Byte[])">
            basic constructor - byte encoded string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerVisibleString.#ctor(System.String)">
            basic constructor
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.CertificateValues">
            <remarks>
            RFC 3126: 4.3.1 Certificate Values Attribute Definition
            <code>
            CertificateValues ::= SEQUENCE OF Certificate
            </code>
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Esf.CommitmentTypeIndication.ToAsn1Object">
            <pre>
            CommitmentTypeIndication ::= SEQUENCE {
                 commitmentTypeId   CommitmentTypeIdentifier,
                 commitmentTypeQualifier   SEQUENCE SIZE (1..MAX) OF
                         CommitmentTypeQualifier OPTIONAL }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.CommitmentTypeQualifier">
             Commitment type qualifiers, used in the Commitment-Type-Indication attribute (RFC3126).
            
             <pre>
               CommitmentTypeQualifier ::= SEQUENCE {
                   commitmentTypeIdentifier  CommitmentTypeIdentifier,
                   qualifier          ANY DEFINED BY commitmentTypeIdentifier OPTIONAL }
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Esf.CommitmentTypeQualifier.#ctor(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
             Creates a new <code>CommitmentTypeQualifier</code> instance.
            
             @param commitmentTypeIdentifier a <code>CommitmentTypeIdentifier</code> value
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Esf.CommitmentTypeQualifier.#ctor(Org.BouncyCastle.Asn1.DerObjectIdentifier,Org.BouncyCastle.Asn1.Asn1Encodable)">
             Creates a new <code>CommitmentTypeQualifier</code> instance.
            
             @param commitmentTypeIdentifier a <code>CommitmentTypeIdentifier</code> value
             @param qualifier the qualifier, defined by the above field.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Esf.CommitmentTypeQualifier.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Creates a new <code>CommitmentTypeQualifier</code> instance.
            
             @param as <code>CommitmentTypeQualifier</code> structure
             encoded as an Asn1Sequence.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Esf.CommitmentTypeQualifier.ToAsn1Object">
             Returns a DER-encodable representation of this instance.
            
             @return a <code>Asn1Object</code> value
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.CompleteCertificateRefs">
            <remarks>
            RFC 3126: 4.2.1 Complete Certificate Refs Attribute Definition
            <code>
            CompleteCertificateRefs ::= SEQUENCE OF OtherCertID
            </code>
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.CompleteRevocationRefs">
            <remarks>
            RFC 3126: 4.2.2 Complete Revocation Refs Attribute Definition
            <code>
            CompleteRevocationRefs ::= SEQUENCE OF CrlOcspRef
            </code>
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.CrlIdentifier">
            <remarks>
            RFC 3126: 4.2.2 Complete Revocation Refs Attribute Definition
            <code>
            CrlIdentifier ::= SEQUENCE 
            {
            	crlissuer		Name,
            	crlIssuedTime	UTCTime,
            	crlNumber		INTEGER OPTIONAL
            }
            </code>
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.CrlListID">
            <remarks>
            RFC 3126: 4.2.2 Complete Revocation Refs Attribute Definition
            <code>
            CRLListID ::= SEQUENCE 
            {
            	crls	SEQUENCE OF CrlValidatedID
            }
            </code>
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.CrlOcspRef">
            <remarks>
            RFC 3126: 4.2.2 Complete Revocation Refs Attribute Definition
            <code>
            CrlOcspRef ::= SEQUENCE {
            	crlids		[0] CRLListID		OPTIONAL,
            	ocspids		[1] OcspListID		OPTIONAL,
            	otherRev	[2] OtherRevRefs	OPTIONAL
            }
            </code>
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.CrlValidatedID">
            <remarks>
            RFC 3126: 4.2.2 Complete Revocation Refs Attribute Definition
            <code>
            CrlValidatedID ::= SEQUENCE {
            	crlHash			OtherHash,
            	crlIdentifier	CrlIdentifier OPTIONAL}
            </code>
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.OcspIdentifier">
            <remarks>
            RFC 3126: 4.2.2 Complete Revocation Refs Attribute Definition
            <code>
            OcspIdentifier ::= SEQUENCE {
            	ocspResponderID		ResponderID,
            		-- As in OCSP response data
            	producedAt			GeneralizedTime
            		-- As in OCSP response data
            }
            </code>
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.OcspListID">
            <remarks>
            RFC 3126: 4.2.2 Complete Revocation Refs Attribute Definition
            <code>
            OcspListID ::=  SEQUENCE {
            	ocspResponses	SEQUENCE OF OcspResponsesID
            }
            </code>
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.OcspResponsesID">
            <remarks>
            RFC 3126: 4.2.2 Complete Revocation Refs Attribute Definition
            <code>
            OcspResponsesID ::= SEQUENCE {
            	ocspIdentifier	OcspIdentifier,
            	ocspRepHash		OtherHash OPTIONAL
            }
            </code>
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.OtherCertID">
            <remarks>
            <code>
            OtherCertID ::= SEQUENCE {
            	otherCertHash	OtherHash,
            	issuerSerial	IssuerSerial OPTIONAL
            }
            </code>
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.OtherHash">
            <remarks>
            <code>
            OtherHash ::= CHOICE {
            	sha1Hash	OtherHashValue, -- This contains a SHA-1 hash
            	otherHash	OtherHashAlgAndValue
            }
            
            OtherHashValue ::= OCTET STRING
            </code>
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.OtherHashAlgAndValue">
            <summary>
            Summary description for OtherHashAlgAndValue.
            </summary>
            <remarks>
            <code>
            OtherHashAlgAndValue ::= SEQUENCE {
            	hashAlgorithm	AlgorithmIdentifier,
            	hashValue		OtherHashValue
            }
            
            OtherHashValue ::= OCTET STRING
            </code>
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.OtherRevRefs">
             <remarks>
             RFC 3126: 4.2.2 Complete Revocation Refs Attribute Definition
             <code>
             OtherRevRefs ::= SEQUENCE 
             {
            		otherRevRefType      OtherRevRefType,
            		otherRevRefs         ANY DEFINED BY otherRevRefType
             }
            
             OtherRevRefType ::= OBJECT IDENTIFIER
             </code>
             </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.OtherRevVals">
             <remarks>
             RFC 3126: 4.3.2 Revocation Values Attribute Definition
             <code>
             OtherRevVals ::= SEQUENCE 
             {
            		otherRevValType      OtherRevValType,
            		otherRevVals         ANY DEFINED BY otherRevValType
             }
            
             OtherRevValType ::= OBJECT IDENTIFIER
             </code>
             </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.OtherSigningCertificate">
            <remarks>
            <code>
            OtherSigningCertificate ::= SEQUENCE {
            	certs		SEQUENCE OF OtherCertID,
            	policies	SEQUENCE OF PolicyInformation OPTIONAL
            }
            </code>
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.RevocationValues">
            <remarks>
            RFC 5126: 6.3.4.  revocation-values Attribute Definition
            <code>
            RevocationValues ::=  SEQUENCE {
            	crlVals			[0] SEQUENCE OF CertificateList     OPTIONAL,
            	ocspVals		[1] SEQUENCE OF BasicOCSPResponse   OPTIONAL,
            	otherRevVals	[2] OtherRevVals OPTIONAL
            }
            </code>
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.SignaturePolicyId">
            <remarks>
            <code>
            SignaturePolicyId ::= SEQUENCE {
            	sigPolicyIdentifier		SigPolicyId,
            	sigPolicyHash			SigPolicyHash,
            	sigPolicyQualifiers		SEQUENCE SIZE (1..MAX) OF SigPolicyQualifierInfo OPTIONAL
            }
            
            SigPolicyId ::= OBJECT IDENTIFIER
            
            SigPolicyHash ::= OtherHashAlgAndValue
            </code>
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.SignaturePolicyIdentifier">
            <remarks>
            <code>
            SignaturePolicyIdentifier ::= CHOICE {
            	SignaturePolicyId		SignaturePolicyId,
            	SignaturePolicyImplied	SignaturePolicyImplied
            }
            
            SignaturePolicyImplied ::= NULL
            </code>
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Esf.SignerAttribute.ToAsn1Object">
            
             <pre>
              SignerAttribute ::= SEQUENCE OF CHOICE {
                  claimedAttributes   [0] ClaimedAttributes,
                  certifiedAttributes [1] CertifiedAttributes }
            
              ClaimedAttributes ::= SEQUENCE OF Attribute
              CertifiedAttributes ::= AttributeCertificate -- as defined in RFC 3281: see clause 4.1.
             </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.SignerLocation">
             Signer-Location attribute (RFC3126).
            
             <pre>
               SignerLocation ::= SEQUENCE {
                   countryName        [0] DirectoryString OPTIONAL,
                   localityName       [1] DirectoryString OPTIONAL,
                   postalAddress      [2] PostalAddress OPTIONAL }
            
               PostalAddress ::= SEQUENCE SIZE(1..6) OF DirectoryString
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Esf.SignerLocation.ToAsn1Object">
             <pre>
               SignerLocation ::= SEQUENCE {
                   countryName        [0] DirectoryString OPTIONAL,
                   localityName       [1] DirectoryString OPTIONAL,
                   postalAddress      [2] PostalAddress OPTIONAL }
            
               PostalAddress ::= SEQUENCE SIZE(1..6) OF DirectoryString
            
               DirectoryString ::= CHOICE {
                     teletexString           TeletexString (SIZE (1..MAX)),
                     printableString         PrintableString (SIZE (1..MAX)),
                     universalString         UniversalString (SIZE (1..MAX)),
                     utf8String              UTF8String (SIZE (1.. MAX)),
                     bmpString               BMPString (SIZE (1..MAX)) }
             </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.SigPolicyQualifierInfo">
            <remarks>
            <code>
            SigPolicyQualifierInfo ::= SEQUENCE {
            	sigPolicyQualifierId  SigPolicyQualifierId,
            	sigQualifier          ANY DEFINED BY sigPolicyQualifierId
            }
            
            SigPolicyQualifierId ::= OBJECT IDENTIFIER
            </code>
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ess.ContentHints.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
            constructor
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ess.ContentHints.ToAsn1Object">
            <pre>
            ContentHints ::= SEQUENCE {
              contentDescription UTF8String (SIZE (1..MAX)) OPTIONAL,
              contentType ContentType }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ess.ContentIdentifier.#ctor(Org.BouncyCastle.Asn1.Asn1OctetString)">
            Create from OCTET STRING whose octets represent the identifier.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ess.ContentIdentifier.#ctor(System.Byte[])">
            Create from byte array representing the identifier.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ess.ContentIdentifier.ToAsn1Object">
            The definition of ContentIdentifier is
            <pre>
            ContentIdentifier ::=  OCTET STRING
            </pre>
            id-aa-contentIdentifier OBJECT IDENTIFIER ::= { iso(1)
             member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs9(9)
             smime(16) id-aa(2) 7 }
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ess.EssCertID.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
            constructor
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ess.EssCertID.ToAsn1Object">
            <pre>
            EssCertID ::= SEQUENCE {
                certHash Hash,
                issuerSerial IssuerSerial OPTIONAL }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ess.EssCertIDv2.ToAsn1Object">
             <pre>
             EssCertIDv2 ::=  SEQUENCE {
                 hashAlgorithm     AlgorithmIdentifier
                          DEFAULT {algorithm id-sha256},
                 certHash          Hash,
                 issuerSerial      IssuerSerial OPTIONAL
             }
            
             Hash ::= OCTET STRING
            
             IssuerSerial ::= SEQUENCE {
                 issuer         GeneralNames,
                 serialNumber   CertificateSerialNumber
             }
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ess.SigningCertificate.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
            constructors
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ess.SigningCertificate.ToAsn1Object">
            The definition of SigningCertificate is
            <pre>
            SigningCertificate ::=  SEQUENCE {
                 certs        SEQUENCE OF EssCertID,
                 policies     SEQUENCE OF PolicyInformation OPTIONAL
            }
            </pre>
            id-aa-signingCertificate OBJECT IDENTIFIER ::= { iso(1)
             member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs9(9)
             smime(16) id-aa(2) 12 }
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ess.SigningCertificateV2.ToAsn1Object">
            The definition of SigningCertificateV2 is
            <pre>
            SigningCertificateV2 ::=  SEQUENCE {
                 certs        SEQUENCE OF EssCertIDv2,
                 policies     SEQUENCE OF PolicyInformation OPTIONAL
            }
            </pre>
            id-aa-signingCertificateV2 OBJECT IDENTIFIER ::= { iso(1)
               member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs9(9)
               smime(16) id-aa(2) 47 }
        </member>
        <member name="T:Org.BouncyCastle.Asn1.IAsn1Choice">
            Marker interface for CHOICE objects - if you implement this in a roll-your-own
            object, any attempt to tag the object implicitly will convert the tag to an
            explicit one as the encoding rules require.
            <p>
            If you use this interface your class should also implement the getInstance
            pattern which takes a tag object and the tagging mode used. 
            </p>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.IAsn1String">
            basic interface for Der string objects.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Icao.CscaMasterList">
             The CscaMasterList object. This object can be wrapped in a
             CMSSignedData to be published in LDAP.
            
             <pre>
             CscaMasterList ::= SEQUENCE {
               version                CscaMasterListVersion,
               certList               SET OF Certificate }
               
             CscaMasterListVersion :: INTEGER {v0(0)}
             </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Icao.DataGroupHash">
             The DataGroupHash object.
             <pre>
             DataGroupHash  ::=  SEQUENCE {
                  dataGroupNumber         DataGroupNumber,
                  dataGroupHashValue     OCTET STRING }
            
             DataGroupNumber ::= INTEGER {
                     dataGroup1    (1),
                     dataGroup1    (2),
                     dataGroup1    (3),
                     dataGroup1    (4),
                     dataGroup1    (5),
                     dataGroup1    (6),
                     dataGroup1    (7),
                     dataGroup1    (8),
                     dataGroup1    (9),
                     dataGroup1    (10),
                     dataGroup1    (11),
                     dataGroup1    (12),
                     dataGroup1    (13),
                     dataGroup1    (14),
                     dataGroup1    (15),
                     dataGroup1    (16) }
            
             </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Icao.LdsSecurityObject">
             The LDSSecurityObject object (V1.8).
             <pre>
             LDSSecurityObject ::= SEQUENCE {
               version                LDSSecurityObjectVersion,
               hashAlgorithm          DigestAlgorithmIdentifier,
               dataGroupHashValues    SEQUENCE SIZE (2..ub-DataGroups) OF DataHashGroup,
               ldsVersionInfo         LDSVersionInfo OPTIONAL
                 -- if present, version MUST be v1 }
            
             DigestAlgorithmIdentifier ::= AlgorithmIdentifier,
            
             LDSSecurityObjectVersion :: INTEGER {V0(0)}
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Icao.LdsVersionInfo.ToAsn1Object">
            <pre>
            LDSVersionInfo ::= SEQUENCE {
               ldsVersion PRINTABLE STRING
               unicodeVersion PRINTABLE STRING
             }
            </pre>
            @return
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttCPAccredited">
            The id-isismtt-cp-accredited OID indicates that the certificate is a
            qualified certificate according to Directive 1999/93/EC of the European
            Parliament and of the Council of 13 December 1999 on a Community
            Framework for Electronic Signatures, which additionally conforms the
            special requirements of the SigG and has been issued by an accredited CA.
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATDateOfCertGen">
             Certificate extensionDate of certificate generation
             
             <pre>
            		DateOfCertGenSyntax ::= GeneralizedTime
             </pre>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATProcuration">
            Attribute to indicate that the certificate holder may sign in the name of
            a third person. May also be used as extension in a certificate.
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATAdmission">
            Attribute to indicate admissions to certain professions. May be used as
            attribute in attribute certificate or as extension in a certificate
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATMonetaryLimit">
            Monetary limit for transactions. The QcEuMonetaryLimit QC statement MUST
            be used in new certificates in place of the extension/attribute
            MonetaryLimit since January 1, 2004. For the sake of backward
            compatibility with certificates already in use, SigG conforming
            components MUST support MonetaryLimit (as well as QcEuLimitValue).
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATDeclarationOfMajority">
            A declaration of majority. May be used as attribute in attribute
            certificate or as extension in a certificate
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATIccsn">
             
             Serial number of the smart card containing the corresponding private key
             
             <pre>
            		ICCSNSyntax ::= OCTET STRING (SIZE(8..20))
             </pre>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATPKReference">
             
             Reference for a file of a smartcard that stores the public key of this
             certificate and that is used as security anchor.
             
             <pre>
            		PKReferenceSyntax ::= OCTET STRING (SIZE(20))
             </pre>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATRestriction">
             Some other restriction regarding the usage of this certificate. May be
             used as attribute in attribute certificate or as extension in a
             certificate.
             
             <pre>
            		RestrictionSyntax ::= DirectoryString (SIZE(1..1024))
             </pre>
             
             @see Org.BouncyCastle.Asn1.IsisMtt.X509.Restriction
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATRetrieveIfAllowed">
             
             (Single)Request extension: Clients may include this extension in a
             (single) Request to request the responder to send the certificate in the
             response message along with the status information. Besides the LDAP
             service, this extension provides another mechanism for the distribution
             of certificates, which MAY optionally be provided by certificate
             repositories.
             
             <pre>
            		RetrieveIfAllowed ::= BOOLEAN
             </pre>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATRequestedCertificate">
            SingleOCSPResponse extension: The certificate requested by the client by
            inserting the RetrieveIfAllowed extension in the request, will be
            returned in this extension.
            
            @see Org.BouncyCastle.Asn1.IsisMtt.Ocsp.RequestedCertificate
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATNamingAuthorities">
            Base ObjectIdentifier for naming authorities
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATCertInDirSince">
             SingleOCSPResponse extension: Date, when certificate has been published
             in the directory and status information has become available. Currently,
             accrediting authorities enforce that SigG-conforming OCSP servers include
             this extension in the responses.
             
             <pre>
            		CertInDirSince ::= GeneralizedTime
             </pre>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATCertHash">
             Hash of a certificate in OCSP.
            
             @see Org.BouncyCastle.Asn1.IsisMtt.Ocsp.CertHash
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATNameAtBirth">
             <pre>
            		NameAtBirth ::= DirectoryString(SIZE(1..64)
             </pre>
             
             Used in
             {@link Org.BouncyCastle.Asn1.X509.SubjectDirectoryAttributes SubjectDirectoryAttributes}
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATAdditionalInformation">
            Some other information of non-restrictive nature regarding the usage of
            this certificate. May be used as attribute in atribute certificate or as
            extension in a certificate.
            
            <pre>
                          AdditionalInformationSyntax ::= DirectoryString (SIZE(1..2048))
            </pre>
            
            @see Org.BouncyCastle.Asn1.IsisMtt.X509.AdditionalInformationSyntax
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATLiabilityLimitationFlag">
             Indicates that an attribute certificate exists, which limits the
             usability of this public key certificate. Whenever verifying a signature
             with the help of this certificate, the content of the corresponding
             attribute certificate should be concerned. This extension MUST be
             included in a PKC, if a corresponding attribute certificate (having the
             PKC as base certificate) contains some attribute that restricts the
             usability of the PKC too. Attribute certificates with restricting content
             MUST always be included in the signed document.
             
             <pre>
            		LiabilityLimitationFlagSyntax ::= BOOLEAN
             </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.IsisMtt.Ocsp.CertHash">
            ISIS-MTT PROFILE: The responder may include this extension in a response to
            send the hash of the requested certificate to the responder. This hash is
            cryptographically bound to the certificate and serves as evidence that the
            certificate is known to the responder (i.e. it has been issued and is present
            in the directory). Hence, this extension is a means to provide a positive
            statement of availability as described in T8.[8]. As explained in T13.[1],
            clients may rely on this information to be able to validate signatures after
            the expiry of the corresponding certificate. Hence, clients MUST support this
            extension. If a positive statement of availability is to be delivered, this
            extension syntax and OID MUST be used.
            <p/>
            <p/>
            <pre>
                CertHash ::= SEQUENCE {
                  hashAlgorithm AlgorithmIdentifier,
                  certificateHash OCTET STRING
                }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.Ocsp.CertHash.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from Asn1Sequence.
             <p/>
             The sequence is of type CertHash:
             <p/>
             <pre>
                 CertHash ::= SEQUENCE {
                   hashAlgorithm AlgorithmIdentifier,
                   certificateHash OCTET STRING
                 }
             </pre>
            
             @param seq The ASN.1 sequence.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.Ocsp.CertHash.#ctor(Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier,System.Byte[])">
             Constructor from a given details.
            
             @param hashAlgorithm   The hash algorithm identifier.
             @param certificateHash The hash of the whole DER encoding of the certificate.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.Ocsp.CertHash.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
                 CertHash ::= SEQUENCE {
                   hashAlgorithm AlgorithmIdentifier,
                   certificateHash OCTET STRING
                 }
             </pre>
            
             @return an Asn1Object
        </member>
        <member name="T:Org.BouncyCastle.Asn1.IsisMtt.Ocsp.RequestedCertificate">
            ISIS-MTT-Optional: The certificate requested by the client by inserting the
            RetrieveIfAllowed extension in the request, will be returned in this
            extension.
            <p/>
            ISIS-MTT-SigG: The signature act allows publishing certificates only then,
            when the certificate owner gives his isExplicit permission. Accordingly, there
            may be nondownloadable certificates, about which the responder must provide
            status information, but MUST NOT include them in the response. Clients may
            get therefore the following three kind of answers on a single request
            including the RetrieveIfAllowed extension:
            <ul>
            <li> a) the responder supports the extension and is allowed to publish the
            certificate: RequestedCertificate returned including the requested
            certificate</li>
            <li>b) the responder supports the extension but is NOT allowed to publish
            the certificate: RequestedCertificate returned including an empty OCTET
            STRING</li>
            <li>c) the responder does not support the extension: RequestedCertificate is
            not included in the response</li>
            </ul>
            Clients requesting RetrieveIfAllowed MUST be able to handle these cases. If
            any of the OCTET STRING options is used, it MUST contain the DER encoding of
            the requested certificate.
            <p/>
            <pre>
                       RequestedCertificate ::= CHOICE {
                         Certificate Certificate,
                         publicKeyCertificate [0] EXPLICIT OCTET STRING,
                         attributeCertificate [1] EXPLICIT OCTET STRING
                       }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.Ocsp.RequestedCertificate.#ctor(Org.BouncyCastle.Asn1.X509.X509CertificateStructure)">
             Constructor from a given details.
             <p/>
             Only one parameter can be given. All other must be <code>null</code>.
            
             @param certificate Given as Certificate
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.Ocsp.RequestedCertificate.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
                        RequestedCertificate ::= CHOICE {
                          Certificate Certificate,
                          publicKeyCertificate [0] EXPLICIT OCTET STRING,
                          attributeCertificate [1] EXPLICIT OCTET STRING
                        }
             </pre>
            
             @return an Asn1Object
        </member>
        <member name="T:Org.BouncyCastle.Asn1.IsisMtt.X509.AdditionalInformationSyntax">
            Some other information of non-restrictive nature regarding the usage of this
            certificate.
            
            <pre>
               AdditionalInformationSyntax ::= DirectoryString (SIZE(1..2048))
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.AdditionalInformationSyntax.#ctor(System.String)">
             Constructor from a given details.
            
             @param information The describtion of the information.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.AdditionalInformationSyntax.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
               AdditionalInformationSyntax ::= DirectoryString (SIZE(1..2048))
             </pre>
            
             @return an Asn1Object
        </member>
        <member name="T:Org.BouncyCastle.Asn1.IsisMtt.X509.Admissions">
             An Admissions structure.
             <p/>
             <pre>
                        Admissions ::= SEQUENCE
                        {
                          admissionAuthority [0] EXPLICIT GeneralName OPTIONAL
                          namingAuthority [1] EXPLICIT NamingAuthority OPTIONAL
                          professionInfos SEQUENCE OF ProfessionInfo
                        }
             <p/>
             </pre>
            
             @see Org.BouncyCastle.Asn1.IsisMtt.X509.AdmissionSyntax
             @see Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo
             @see Org.BouncyCastle.Asn1.IsisMtt.X509.NamingAuthority
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.Admissions.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from Asn1Sequence.
             <p/>
             The sequence is of type ProcurationSyntax:
             <p/>
             <pre>
                        Admissions ::= SEQUENCE
                        {
                          admissionAuthority [0] EXPLICIT GeneralName OPTIONAL
                          namingAuthority [1] EXPLICIT NamingAuthority OPTIONAL
                          professionInfos SEQUENCE OF ProfessionInfo
                        }
             </pre>
            
             @param seq The ASN.1 sequence.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.Admissions.#ctor(Org.BouncyCastle.Asn1.X509.GeneralName,Org.BouncyCastle.Asn1.IsisMtt.X509.NamingAuthority,Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo[])">
             Constructor from a given details.
             <p/>
             Parameter <code>professionInfos</code> is mandatory.
            
             @param admissionAuthority The admission authority.
             @param namingAuthority    The naming authority.
             @param professionInfos    The profession infos.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.Admissions.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
                   Admissions ::= SEQUENCE
                   {
                     admissionAuthority [0] EXPLICIT GeneralName OPTIONAL
                     namingAuthority [1] EXPLICIT NamingAuthority OPTIONAL
                     professionInfos SEQUENCE OF ProfessionInfo
                   }
             <p/>
             </pre>
            
             @return an Asn1Object
        </member>
        <member name="T:Org.BouncyCastle.Asn1.IsisMtt.X509.AdmissionSyntax">
             Attribute to indicate admissions to certain professions.
             <p/>
             <pre>
                 AdmissionSyntax ::= SEQUENCE
                 {
                   admissionAuthority GeneralName OPTIONAL,
                   contentsOfAdmissions SEQUENCE OF Admissions
                 }
             <p/>
                 Admissions ::= SEQUENCE
                 {
                   admissionAuthority [0] EXPLICIT GeneralName OPTIONAL
                   namingAuthority [1] EXPLICIT NamingAuthority OPTIONAL
                   professionInfos SEQUENCE OF ProfessionInfo
                 }
             <p/>
                 NamingAuthority ::= SEQUENCE
                 {
                   namingAuthorityId OBJECT IDENTIFIER OPTIONAL,
                   namingAuthorityUrl IA5String OPTIONAL,
                   namingAuthorityText DirectoryString(SIZE(1..128)) OPTIONAL
                 }
             <p/>
                 ProfessionInfo ::= SEQUENCE
                 {
                   namingAuthority [0] EXPLICIT NamingAuthority OPTIONAL,
                   professionItems SEQUENCE OF DirectoryString (SIZE(1..128)),
                   professionOIDs SEQUENCE OF OBJECT IDENTIFIER OPTIONAL,
                   registrationNumber PrintableString(SIZE(1..128)) OPTIONAL,
                   addProfessionInfo OCTET STRING OPTIONAL
                 }
             </pre>
             <p/>
             <p/>
             ISIS-MTT PROFILE: The relatively complex structure of AdmissionSyntax
             supports the following concepts and requirements:
             <ul>
             <li> External institutions (e.g. professional associations, chambers, unions,
             administrative bodies, companies, etc.), which are responsible for granting
             and verifying professional admissions, are indicated by means of the data
             field admissionAuthority. An admission authority is indicated by a
             GeneralName object. Here an X.501 directory name (distinguished name) can be
             indicated in the field directoryName, a URL address can be indicated in the
             field uniformResourceIdentifier, and an object identifier can be indicated in
             the field registeredId.</li>
             <li> The names of authorities which are responsible for the administration of
             title registers are indicated in the data field namingAuthority. The name of
             the authority can be identified by an object identifier in the field
             namingAuthorityId, by means of a text string in the field
             namingAuthorityText, by means of a URL address in the field
             namingAuthorityUrl, or by a combination of them. For example, the text string
             can contain the name of the authority, the country and the name of the title
             register. The URL-option refers to a web page which contains lists with
             officially registered professions (text and possibly OID) as well as
             further information on these professions. Object identifiers for the
             component namingAuthorityId are grouped under the OID-branch
             id-isis-at-namingAuthorities and must be applied for.</li>
             <li>See http://www.teletrust.de/anwend.asp?Id=30200&amp;Sprache=E_&amp;HomePG=0
             for an application form and http://www.teletrust.de/links.asp?id=30220,11
             for an overview of registered naming authorities.</li>
             <li> By means of the data type ProfessionInfo certain professions,
             specializations, disciplines, fields of activity, etc. are identified. A
             profession is represented by one or more text strings, resp. profession OIDs
             in the fields professionItems and professionOIDs and by a registration number
             in the field registrationNumber. An indication in text form must always be
             present, whereas the other indications are optional. The component
             addProfessionInfo may contain additional applicationspecific information in
             DER-encoded form.</li>
             </ul>
             <p/>
             By means of different namingAuthority-OIDs or profession OIDs hierarchies of
             professions, specializations, disciplines, fields of activity, etc. can be
             expressed. The issuing admission authority should always be indicated (field
             admissionAuthority), whenever a registration number is presented. Still,
             information on admissions can be given without indicating an admission or a
             naming authority by the exclusive use of the component professionItems. In
             this case the certification authority is responsible for the verification of
             the admission information.
             <p/>
             <p/>
             <p/>
             This attribute is single-valued. Still, several admissions can be captured in
             the sequence structure of the component contentsOfAdmissions of
             AdmissionSyntax or in the component professionInfos of Admissions. The
             component admissionAuthority of AdmissionSyntax serves as default value for
             the component admissionAuthority of Admissions. Within the latter component
             the default value can be overwritten, in case that another authority is
             responsible. The component namingAuthority of Admissions serves as a default
             value for the component namingAuthority of ProfessionInfo. Within the latter
             component the default value can be overwritten, in case that another naming
             authority needs to be recorded.
             <p/>
             The length of the string objects is limited to 128 characters. It is
             recommended to indicate a namingAuthorityURL in all issued attribute
             certificates. If a namingAuthorityURL is indicated, the field professionItems
             of ProfessionInfo should contain only registered titles. If the field
             professionOIDs exists, it has to contain the OIDs of the professions listed
             in professionItems in the same order. In general, the field professionInfos
             should contain only one entry, unless the admissions that are to be listed
             are logically connected (e.g. they have been issued under the same admission
             number).
            
             @see Org.BouncyCastle.Asn1.IsisMtt.X509.Admissions
             @see Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo
             @see Org.BouncyCastle.Asn1.IsisMtt.X509.NamingAuthority
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.AdmissionSyntax.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from Asn1Sequence.
             <p/>
             The sequence is of type ProcurationSyntax:
             <p/>
             <pre>
                 AdmissionSyntax ::= SEQUENCE
                 {
                   admissionAuthority GeneralName OPTIONAL,
                   contentsOfAdmissions SEQUENCE OF Admissions
                 }
             <p/>
                 Admissions ::= SEQUENCE
                 {
                   admissionAuthority [0] EXPLICIT GeneralName OPTIONAL
                   namingAuthority [1] EXPLICIT NamingAuthority OPTIONAL
                   professionInfos SEQUENCE OF ProfessionInfo
                 }
             <p/>
                 NamingAuthority ::= SEQUENCE
                 {
                   namingAuthorityId OBJECT IDENTIFIER OPTIONAL,
                   namingAuthorityUrl IA5String OPTIONAL,
                   namingAuthorityText DirectoryString(SIZE(1..128)) OPTIONAL
                 }
             <p/>
                 ProfessionInfo ::= SEQUENCE
                 {
                   namingAuthority [0] EXPLICIT NamingAuthority OPTIONAL,
                   professionItems SEQUENCE OF DirectoryString (SIZE(1..128)),
                   professionOIDs SEQUENCE OF OBJECT IDENTIFIER OPTIONAL,
                   registrationNumber PrintableString(SIZE(1..128)) OPTIONAL,
                   addProfessionInfo OCTET STRING OPTIONAL
                 }
             </pre>
            
             @param seq The ASN.1 sequence.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.AdmissionSyntax.#ctor(Org.BouncyCastle.Asn1.X509.GeneralName,Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from given details.
            
             @param admissionAuthority   The admission authority.
             @param contentsOfAdmissions The admissions.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.AdmissionSyntax.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
                 AdmissionSyntax ::= SEQUENCE
                 {
                   admissionAuthority GeneralName OPTIONAL,
                   contentsOfAdmissions SEQUENCE OF Admissions
                 }
             <p/>
                 Admissions ::= SEQUENCE
                 {
                   admissionAuthority [0] EXPLICIT GeneralName OPTIONAL
                   namingAuthority [1] EXPLICIT NamingAuthority OPTIONAL
                   professionInfos SEQUENCE OF ProfessionInfo
                 }
             <p/>
                 NamingAuthority ::= SEQUENCE
                 {
                   namingAuthorityId OBJECT IDENTIFIER OPTIONAL,
                   namingAuthorityUrl IA5String OPTIONAL,
                   namingAuthorityText DirectoryString(SIZE(1..128)) OPTIONAL
                 }
             <p/>
                 ProfessionInfo ::= SEQUENCE
                 {
                   namingAuthority [0] EXPLICIT NamingAuthority OPTIONAL,
                   professionItems SEQUENCE OF DirectoryString (SIZE(1..128)),
                   professionOIDs SEQUENCE OF OBJECT IDENTIFIER OPTIONAL,
                   registrationNumber PrintableString(SIZE(1..128)) OPTIONAL,
                   addProfessionInfo OCTET STRING OPTIONAL
                 }
             </pre>
            
             @return an Asn1Object
        </member>
        <member name="P:Org.BouncyCastle.Asn1.IsisMtt.X509.AdmissionSyntax.AdmissionAuthority">
            @return Returns the admissionAuthority if present, null otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.AdmissionSyntax.GetContentsOfAdmissions">
            @return Returns the contentsOfAdmissions.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.IsisMtt.X509.DeclarationOfMajority">
            A declaration of majority.
            <p/>
            <pre>
                      DeclarationOfMajoritySyntax ::= CHOICE
                      {
                        notYoungerThan [0] IMPLICIT INTEGER,
                        fullAgeAtCountry [1] IMPLICIT SEQUENCE
                        {
                          fullAge BOOLEAN DEFAULT TRUE,
                          country PrintableString (SIZE(2))
                        }
                        dateOfBirth [2] IMPLICIT GeneralizedTime
                      }
            </pre>
            <p/>
            fullAgeAtCountry indicates the majority of the owner with respect to the laws
            of a specific country.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.DeclarationOfMajority.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
                       DeclarationOfMajoritySyntax ::= CHOICE
                       {
                         notYoungerThan [0] IMPLICIT INTEGER,
                         fullAgeAtCountry [1] IMPLICIT SEQUENCE
                         {
                           fullAge BOOLEAN DEFAULT TRUE,
                           country PrintableString (SIZE(2))
                         }
                         dateOfBirth [2] IMPLICIT GeneralizedTime
                       }
             </pre>
            
             @return an Asn1Object
        </member>
        <member name="P:Org.BouncyCastle.Asn1.IsisMtt.X509.DeclarationOfMajority.NotYoungerThan">
            @return notYoungerThan if that's what we are, -1 otherwise
        </member>
        <member name="T:Org.BouncyCastle.Asn1.IsisMtt.X509.MonetaryLimit">
            Monetary limit for transactions. The QcEuMonetaryLimit QC statement MUST be
            used in new certificates in place of the extension/attribute MonetaryLimit
            since January 1, 2004. For the sake of backward compatibility with
            certificates already in use, components SHOULD support MonetaryLimit (as well
            as QcEuLimitValue).
            <p/>
            Indicates a monetary limit within which the certificate holder is authorized
            to act. (This value DOES NOT express a limit on the liability of the
            certification authority).
            <p/>
            <pre>
               MonetaryLimitSyntax ::= SEQUENCE
               {
                 currency PrintableString (SIZE(3)),
                 amount INTEGER,
                 exponent INTEGER
               }
            </pre>
            <p/>
            currency must be the ISO code.
            <p/>
            value = amount10*exponent
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.MonetaryLimit.#ctor(System.String,System.Int32,System.Int32)">
             Constructor from a given details.
             <p/>
             <p/>
             value = amount10^exponent
            
             @param currency The currency. Must be the ISO code.
             @param amount   The amount
             @param exponent The exponent
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.MonetaryLimit.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
                MonetaryLimitSyntax ::= SEQUENCE
                {
                  currency PrintableString (SIZE(3)),
                  amount INTEGER,
                  exponent INTEGER
                }
             </pre>
            
             @return an Asn1Object
        </member>
        <member name="T:Org.BouncyCastle.Asn1.IsisMtt.X509.NamingAuthority">
            Names of authorities which are responsible for the administration of title
            registers.
            
            <pre>
                        NamingAuthority ::= SEQUENCE 
                        {
                          namingAuthorityID OBJECT IDENTIFIER OPTIONAL,
                          namingAuthorityUrl IA5String OPTIONAL,
                          namingAuthorityText DirectoryString(SIZE(1..128)) OPTIONAL
                        }
            </pre>
            @see Org.BouncyCastle.Asn1.IsisMtt.X509.AdmissionSyntax
            
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.NamingAuthority.IdIsisMttATNamingAuthoritiesRechtWirtschaftSteuern">
            Profession OIDs should always be defined under the OID branch of the
            responsible naming authority. At the time of this writing, the work group
            Recht, Wirtschaft, Steuern (Law, Economy, Taxes) is registered as the
            first naming authority under the OID id-isismtt-at-namingAuthorities.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.NamingAuthority.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from Asn1Sequence.
             <p/>
             <p/>
             <pre>
                         NamingAuthority ::= SEQUENCE
                         {
                           namingAuthorityID OBJECT IDENTIFIER OPTIONAL,
                           namingAuthorityUrl IA5String OPTIONAL,
                           namingAuthorityText DirectoryString(SIZE(1..128)) OPTIONAL
                         }
             </pre>
            
             @param seq The ASN.1 sequence.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.IsisMtt.X509.NamingAuthority.NamingAuthorityID">
            @return Returns the namingAuthorityID.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.IsisMtt.X509.NamingAuthority.NamingAuthorityText">
            @return Returns the namingAuthorityText.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.IsisMtt.X509.NamingAuthority.NamingAuthorityUrl">
            @return Returns the namingAuthorityUrl.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.NamingAuthority.#ctor(Org.BouncyCastle.Asn1.DerObjectIdentifier,System.String,Org.BouncyCastle.Asn1.X500.DirectoryString)">
             Constructor from given details.
             <p/>
             All parameters can be combined.
            
             @param namingAuthorityID   ObjectIdentifier for naming authority.
             @param namingAuthorityUrl  URL for naming authority.
             @param namingAuthorityText Textual representation of naming authority.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.NamingAuthority.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
                         NamingAuthority ::= SEQUENCE
                         {
                           namingAuthorityID OBJECT IDENTIFIER OPTIONAL,
                           namingAuthorityUrl IA5String OPTIONAL,
                           namingAuthorityText DirectoryString(SIZE(1..128)) OPTIONAL
                         }
             </pre>
            
             @return an Asn1Object
        </member>
        <member name="T:Org.BouncyCastle.Asn1.IsisMtt.X509.ProcurationSyntax">
            Attribute to indicate that the certificate holder may sign in the name of a
            third person.
            <p>
            ISIS-MTT PROFILE: The corresponding ProcurationSyntax contains either the
            name of the person who is represented (subcomponent thirdPerson) or a
            reference to his/her base certificate (in the component signingFor,
            subcomponent certRef), furthermore the optional components country and
            typeSubstitution to indicate the country whose laws apply, and respectively
            the type of procuration (e.g. manager, procuration, custody).
            </p>
            <p>
            ISIS-MTT PROFILE: The GeneralName MUST be of type directoryName and MAY only
            contain: - RFC3039 attributes, except pseudonym (countryName, commonName,
            surname, givenName, serialNumber, organizationName, organizationalUnitName,
            stateOrProvincename, localityName, postalAddress) and - SubjectDirectoryName
            attributes (title, dateOfBirth, placeOfBirth, gender, countryOfCitizenship,
            countryOfResidence and NameAtBirth).
            </p>
            <pre>
                          ProcurationSyntax ::= SEQUENCE {
                            country [1] EXPLICIT PrintableString(SIZE(2)) OPTIONAL,
                            typeOfSubstitution [2] EXPLICIT DirectoryString (SIZE(1..128)) OPTIONAL,
                            signingFor [3] EXPLICIT SigningFor 
                          }
                          
                          SigningFor ::= CHOICE 
                          { 
                            thirdPerson GeneralName,
                            certRef IssuerSerial 
                          }
            </pre>
            
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.ProcurationSyntax.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from Asn1Sequence.
             <p/>
             The sequence is of type ProcurationSyntax:
             <p/>
             <pre>
                           ProcurationSyntax ::= SEQUENCE {
                             country [1] EXPLICIT PrintableString(SIZE(2)) OPTIONAL,
                             typeOfSubstitution [2] EXPLICIT DirectoryString (SIZE(1..128)) OPTIONAL,
                             signingFor [3] EXPLICIT SigningFor
                           }
             <p/>
                           SigningFor ::= CHOICE
                           {
                             thirdPerson GeneralName,
                             certRef IssuerSerial
                           }
             </pre>
            
             @param seq The ASN.1 sequence.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.ProcurationSyntax.#ctor(System.String,Org.BouncyCastle.Asn1.X500.DirectoryString,Org.BouncyCastle.Asn1.X509.IssuerSerial)">
             Constructor from a given details.
             <p/>
             <p/>
             Either <code>generalName</code> or <code>certRef</code> MUST be
             <code>null</code>.
            
             @param country            The country code whose laws apply.
             @param typeOfSubstitution The type of procuration.
             @param certRef            Reference to certificate of the person who is represented.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.ProcurationSyntax.#ctor(System.String,Org.BouncyCastle.Asn1.X500.DirectoryString,Org.BouncyCastle.Asn1.X509.GeneralName)">
             Constructor from a given details.
             <p/>
             <p/>
             Either <code>generalName</code> or <code>certRef</code> MUST be
             <code>null</code>.
            
             @param country            The country code whose laws apply.
             @param typeOfSubstitution The type of procuration.
             @param thirdPerson        The GeneralName of the person who is represented.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.ProcurationSyntax.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
                           ProcurationSyntax ::= SEQUENCE {
                             country [1] EXPLICIT PrintableString(SIZE(2)) OPTIONAL,
                             typeOfSubstitution [2] EXPLICIT DirectoryString (SIZE(1..128)) OPTIONAL,
                             signingFor [3] EXPLICIT SigningFor
                           }
             <p/>
                           SigningFor ::= CHOICE
                           {
                             thirdPerson GeneralName,
                             certRef IssuerSerial
                           }
             </pre>
            
             @return an Asn1Object
        </member>
        <member name="T:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo">
            Professions, specializations, disciplines, fields of activity, etc.
            
            <pre>
                          ProfessionInfo ::= SEQUENCE 
                          {
                            namingAuthority [0] EXPLICIT NamingAuthority OPTIONAL,
                            professionItems SEQUENCE OF DirectoryString (SIZE(1..128)),
                            professionOids SEQUENCE OF OBJECT IDENTIFIER OPTIONAL,
                            registrationNumber PrintableString(SIZE(1..128)) OPTIONAL,
                            addProfessionInfo OCTET STRING OPTIONAL 
                          }
            </pre>
            
            @see Org.BouncyCastle.Asn1.IsisMtt.X509.AdmissionSyntax
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Rechtsanwltin">
            Rechtsanwltin
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Rechtsanwalt">
            Rechtsanwalt
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Rechtsbeistand">
            Rechtsbeistand
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Steuerberaterin">
            Steuerberaterin
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Steuerberater">
            Steuerberater
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Steuerbevollmchtigte">
            Steuerbevollmchtigte
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Steuerbevollmchtigter">
            Steuerbevollmchtigter
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Notarin">
            Notarin
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Notar">
            Notar
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Notarvertreterin">
            Notarvertreterin
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Notarvertreter">
            Notarvertreter
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Notariatsverwalterin">
            Notariatsverwalterin
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Notariatsverwalter">
            Notariatsverwalter
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Wirtschaftsprferin">
            Wirtschaftsprferin
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Wirtschaftsprfer">
            Wirtschaftsprfer
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.VereidigteBuchprferin">
            Vereidigte Buchprferin
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.VereidigterBuchprfer">
            Vereidigter Buchprfer
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Patentanwltin">
            Patentanwltin
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Patentanwalt">
            Patentanwalt
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from Asn1Sequence.
             <p/>
             <p/>
             <pre>
                           ProfessionInfo ::= SEQUENCE
                           {
                             namingAuthority [0] EXPLICIT NamingAuthority OPTIONAL,
                             professionItems SEQUENCE OF DirectoryString (SIZE(1..128)),
                             professionOids SEQUENCE OF OBJECT IDENTIFIER OPTIONAL,
                             registrationNumber PrintableString(SIZE(1..128)) OPTIONAL,
                             addProfessionInfo OCTET STRING OPTIONAL
                           }
             </pre>
            
             @param seq The ASN.1 sequence.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.#ctor(Org.BouncyCastle.Asn1.IsisMtt.X509.NamingAuthority,Org.BouncyCastle.Asn1.X500.DirectoryString[],Org.BouncyCastle.Asn1.DerObjectIdentifier[],System.String,Org.BouncyCastle.Asn1.Asn1OctetString)">
             Constructor from given details.
             <p/>
             <code>professionItems</code> is mandatory, all other parameters are
             optional.
            
             @param namingAuthority    The naming authority.
             @param professionItems    Directory strings of the profession.
             @param professionOids     DERObjectIdentfier objects for the
                                       profession.
             @param registrationNumber Registration number.
             @param addProfessionInfo  Additional infos in encoded form.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
                           ProfessionInfo ::= SEQUENCE
                           {
                             namingAuthority [0] EXPLICIT NamingAuthority OPTIONAL,
                             professionItems SEQUENCE OF DirectoryString (SIZE(1..128)),
                             professionOids SEQUENCE OF OBJECT IDENTIFIER OPTIONAL,
                             registrationNumber PrintableString(SIZE(1..128)) OPTIONAL,
                             addProfessionInfo OCTET STRING OPTIONAL
                           }
             </pre>
            
             @return an Asn1Object
        </member>
        <member name="P:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.AddProfessionInfo">
            @return Returns the addProfessionInfo.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.NamingAuthority">
            @return Returns the namingAuthority.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.GetProfessionItems">
            @return Returns the professionItems.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.GetProfessionOids">
            @return Returns the professionOids.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.RegistrationNumber">
            @return Returns the registrationNumber.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.IsisMtt.X509.Restriction">
            Some other restriction regarding the usage of this certificate.
            <p/>
            <pre>
             RestrictionSyntax ::= DirectoryString (SIZE(1..1024))
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.Restriction.#ctor(Org.BouncyCastle.Asn1.X500.DirectoryString)">
             Constructor from DirectoryString.
             <p/>
             The DirectoryString is of type RestrictionSyntax:
             <p/>
             <pre>
                  RestrictionSyntax ::= DirectoryString (SIZE(1..1024))
             </pre>
            
             @param restriction A IAsn1String.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.Restriction.#ctor(System.String)">
             Constructor from a given details.
            
             @param restriction The description of the restriction.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.Restriction.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
                  RestrictionSyntax ::= DirectoryString (SIZE(1..1024))
             <p/>
             </pre>
            
             @return an Asn1Object
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Misc.Cast5CbcParameters.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            cast5CBCParameters ::= Sequence {
                                      iv         OCTET STRING DEFAULT 0,
                                             -- Initialization vector
                                      keyLength  Integer
                                             -- Key length, in bits
                                 }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Misc.IdeaCbcPar.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            IDEA-CBCPar ::= Sequence {
                                 iv    OCTET STRING OPTIONAL -- exactly 8 octets
                             }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Misc.NetscapeCertType">
            The NetscapeCertType object.
            <pre>
               NetscapeCertType ::= BIT STRING {
                    SSLClient               (0),
                    SSLServer               (1),
                    S/MIME                  (2),
                    Object Signing          (3),
                    Reserved                (4),
                    SSL CA                  (5),
                    S/MIME CA               (6),
                    Object Signing CA       (7) }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Misc.NetscapeCertType.#ctor(System.Int32)">
             Basic constructor.
            
             @param usage - the bitwise OR of the Key Usage flags giving the
             allowed uses for the key.
             e.g. (X509NetscapeCertType.sslCA | X509NetscapeCertType.smimeCA)
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Mozilla.PublicKeyAndChallenge">
             This is designed to parse
             the PublicKeyAndChallenge created by the KEYGEN tag included by
             Mozilla based browsers.
              <pre>
              PublicKeyAndChallenge ::= SEQUENCE {
                spki SubjectPublicKeyInfo,
                challenge IA5STRING
              }
            
              </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Nist.NistNamedCurves">
            Utility class for fetching curves using their NIST names as published in FIPS-PUB 186-3
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Nist.NistNamedCurves.GetByOid(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
             return the X9ECParameters object for the named curve represented by
             the passed in object identifier. Null if the curve isn't present.
            
             @param oid an object identifier representing a named curve, if present.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Nist.NistNamedCurves.GetOid(System.String)">
             return the object identifier signified by the passed in name. Null
             if there is no object identifier associated with name.
            
             @return the object identifier associated with name, if present.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Nist.NistNamedCurves.GetName(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            return the named curve name represented by the given object identifier.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.Nist.NistNamedCurves.Names">
            returns an enumeration containing the name strings for curves
            contained in this structure.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Ntt.NttObjectIdentifiers">
            <summary>From RFC 3657</summary>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ocsp.BasicOcspResponse.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            BasicOcspResponse       ::= Sequence {
                 tbsResponseData      ResponseData,
                 signatureAlgorithm   AlgorithmIdentifier,
                 signature            BIT STRING,
                 certs                [0] EXPLICIT Sequence OF Certificate OPTIONAL }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ocsp.CertID.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            CertID          ::=     Sequence {
                hashAlgorithm       AlgorithmIdentifier,
                issuerNameHash      OCTET STRING, -- Hash of Issuer's DN
                issuerKeyHash       OCTET STRING, -- Hash of Issuers public key
                serialNumber        CertificateSerialNumber }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ocsp.CertStatus.#ctor">
            create a CertStatus object with a tag of zero.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ocsp.CertStatus.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             CertStatus ::= CHOICE {
                             good        [0]     IMPLICIT Null,
                             revoked     [1]     IMPLICIT RevokedInfo,
                             unknown     [2]     IMPLICIT UnknownInfo }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ocsp.CrlID.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            CrlID ::= Sequence {
                crlUrl               [0]     EXPLICIT IA5String OPTIONAL,
                crlNum               [1]     EXPLICIT Integer OPTIONAL,
                crlTime              [2]     EXPLICIT GeneralizedTime OPTIONAL }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ocsp.OcspRequest.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            OcspRequest     ::=     Sequence {
                tbsRequest                  TBSRequest,
                optionalSignature   [0]     EXPLICIT Signature OPTIONAL }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ocsp.OcspResponse.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            OcspResponse ::= Sequence {
                responseStatus         OcspResponseStatus,
                responseBytes          [0] EXPLICIT ResponseBytes OPTIONAL }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ocsp.OcspResponseStatus.#ctor(System.Int32)">
            The OcspResponseStatus enumeration.
            <pre>
            OcspResponseStatus ::= Enumerated {
                successful            (0),  --Response has valid confirmations
                malformedRequest      (1),  --Illegal confirmation request
                internalError         (2),  --Internal error in issuer
                tryLater              (3),  --Try again later
                                            --(4) is not used
                sigRequired           (5),  --Must sign the request
                unauthorized          (6)   --Request unauthorized
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ocsp.Request.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            Request         ::=     Sequence {
                reqCert                     CertID,
                singleRequestExtensions     [0] EXPLICIT Extensions OPTIONAL }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ocsp.ResponderID.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            ResponderID ::= CHOICE {
                 byName          [1] Name,
                 byKey           [2] KeyHash }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ocsp.ResponseBytes.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            ResponseBytes ::=       Sequence {
                responseType   OBJECT IDENTIFIER,
                response       OCTET STRING }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ocsp.ResponseData.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            ResponseData ::= Sequence {
                version              [0] EXPLICIT Version DEFAULT v1,
                responderID              ResponderID,
                producedAt               GeneralizedTime,
                responses                Sequence OF SingleResponse,
                responseExtensions   [1] EXPLICIT Extensions OPTIONAL }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ocsp.RevokedInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            RevokedInfo ::= Sequence {
                 revocationTime              GeneralizedTime,
                 revocationReason    [0]     EXPLICIT CRLReason OPTIONAL }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ocsp.ServiceLocator.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            ServiceLocator ::= Sequence {
                issuer    Name,
                locator   AuthorityInfoAccessSyntax OPTIONAL }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ocsp.Signature.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            Signature       ::=     Sequence {
                signatureAlgorithm      AlgorithmIdentifier,
                signature               BIT STRING,
                certs               [0] EXPLICIT Sequence OF Certificate OPTIONAL}
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ocsp.SingleResponse.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             SingleResponse ::= Sequence {
                     certID                       CertID,
                     certStatus                   CertStatus,
                     thisUpdate                   GeneralizedTime,
                     nextUpdate         [0]       EXPLICIT GeneralizedTime OPTIONAL,
                     singleExtensions   [1]       EXPLICIT Extensions OPTIONAL }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ocsp.TbsRequest.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            TBSRequest      ::=     Sequence {
                version             [0]     EXPLICIT Version DEFAULT v1,
                requestorName       [1]     EXPLICIT GeneralName OPTIONAL,
                requestList                 Sequence OF Request,
                requestExtensions   [2]     EXPLICIT Extensions OPTIONAL }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.OidTokenizer">
            class for breaking up an Oid into it's component tokens, ala
            java.util.StringTokenizer. We need this class as some of the
            lightweight Java environment don't support classes like
            StringTokenizer.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Pkcs.AttributePkcs.GetInstance(System.Object)">
             return an Attribute object from the given object.
            
             @param o the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Pkcs.AttributePkcs.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            Attr ::= Sequence {
                attrType OBJECT IDENTIFIER,
                attrValues Set OF AttributeValue
            }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Pkcs.CertificationRequest">
            Pkcs10 Certfication request object.
            <pre>
            CertificationRequest ::= Sequence {
              certificationRequestInfo  CertificationRequestInfo,
              signatureAlgorithm        AlgorithmIdentifier{{ SignatureAlgorithms }},
              signature                 BIT STRING
            }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Pkcs.CertificationRequestInfo">
             Pkcs10 CertificationRequestInfo object.
             <pre>
              CertificationRequestInfo ::= Sequence {
               version             Integer { v1(0) } (v1,...),
               subject             Name,
               subjectPKInfo   SubjectPublicKeyInfo{{ PKInfoAlgorithms }},
               attributes          [0] Attributes{{ CRIAttributes }}
              }
            
              Attributes { ATTRIBUTE:IOSet } ::= Set OF Attr{{ IOSet }}
            
              Attr { ATTRIBUTE:IOSet } ::= Sequence {
                type    ATTRIBUTE.&amp;id({IOSet}),
                values  Set SIZE(1..MAX) OF ATTRIBUTE.&amp;Type({IOSet}{\@type})
              }
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Pkcs.ContentInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            ContentInfo ::= Sequence {
                     contentType ContentType,
                     content
                     [0] EXPLICIT ANY DEFINED BY contentType OPTIONAL }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Pkcs.EncryptedData">
             The EncryptedData object.
             <pre>
                  EncryptedData ::= Sequence {
                       version Version,
                       encryptedContentInfo EncryptedContentInfo
                  }
            
            
                  EncryptedContentInfo ::= Sequence {
                      contentType ContentType,
                      contentEncryptionAlgorithm  ContentEncryptionAlgorithmIdentifier,
                      encryptedContent [0] IMPLICIT EncryptedContent OPTIONAL
                }
            
                EncryptedContent ::= OCTET STRING
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Pkcs.EncryptedPrivateKeyInfo.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <pre>
             EncryptedPrivateKeyInfo ::= Sequence {
                  encryptionAlgorithm AlgorithmIdentifier {{KeyEncryptionAlgorithms}},
                  encryptedData EncryptedData
             }
            
             EncryptedData ::= OCTET STRING
            
             KeyEncryptionAlgorithms ALGORITHM-IDENTIFIER ::= {
                      ... -- For local profiles
             }
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Pkcs.MacData.ToAsn1Object">
            <pre>
            MacData ::= SEQUENCE {
                mac      DigestInfo,
                macSalt  OCTET STRING,
                iterations INTEGER DEFAULT 1
                -- Note: The default is for historic reasons and its use is deprecated. A
                -- higher value, like 1024 is recommended.
            </pre>
            @return the basic DERObject construction.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Pkcs.Pfx">
            the infamous Pfx from Pkcs12
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Pkcs.PkcsObjectIdentifiers.id_aa_cmsAlgorithmProtect">
            RFC 6211 -  id-aa-cmsAlgorithmProtect OBJECT IDENTIFIER ::= {
            iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1)
            pkcs9(9) 52 }  
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Pkcs.PrivateKeyInfo.ToAsn1Object">
             write out an RSA private key with its associated information
             as described in Pkcs8.
             <pre>
                  PrivateKeyInfo ::= Sequence {
                                          version Version,
                                          privateKeyAlgorithm AlgorithmIdentifier {{PrivateKeyAlgorithms}},
                                          privateKey PrivateKey,
                                          attributes [0] IMPLICIT Attributes OPTIONAL
                                      }
                  Version ::= Integer {v1(0)} (v1,...)
            
                  PrivateKey ::= OCTET STRING
            
                  Attributes ::= Set OF Attr
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Pkcs.RsaesOaepParameters.#ctor">
            The default version
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Pkcs.RsaesOaepParameters.ToAsn1Object">
             <pre>
              RSAES-OAEP-params ::= SEQUENCE {
                 hashAlgorithm      [0] OAEP-PSSDigestAlgorithms     DEFAULT sha1,
                 maskGenAlgorithm   [1] PKCS1MGFAlgorithms  DEFAULT mgf1SHA1,
                 pSourceAlgorithm   [2] PKCS1PSourceAlgorithms  DEFAULT pSpecifiedEmpty
               }
            
               OAEP-PSSDigestAlgorithms    ALGORITHM-IDENTIFIER ::= {
                 { OID id-sha1 PARAMETERS NULL   }|
                 { OID id-sha256 PARAMETERS NULL }|
                 { OID id-sha384 PARAMETERS NULL }|
                 { OID id-sha512 PARAMETERS NULL },
                 ...  -- Allows for future expansion --
               }
               PKCS1MGFAlgorithms    ALGORITHM-IDENTIFIER ::= {
                 { OID id-mgf1 PARAMETERS OAEP-PSSDigestAlgorithms },
                ...  -- Allows for future expansion --
               }
               PKCS1PSourceAlgorithms    ALGORITHM-IDENTIFIER ::= {
                 { OID id-pSpecified PARAMETERS OCTET STRING },
                 ...  -- Allows for future expansion --
              }
             </pre>
             @return the asn1 primitive representing the parameters.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Pkcs.RsaPrivateKeyStructure.ToAsn1Object">
             This outputs the key in Pkcs1v2 format.
             <pre>
                  RsaPrivateKey ::= Sequence {
                                      version Version,
                                      modulus Integer, -- n
                                      publicExponent Integer, -- e
                                      privateExponent Integer, -- d
                                      prime1 Integer, -- p
                                      prime2 Integer, -- q
                                      exponent1 Integer, -- d mod (p-1)
                                      exponent2 Integer, -- d mod (q-1)
                                      coefficient Integer -- (inverse of q) mod p
                                  }
            
                  Version ::= Integer
             </pre>
             <p>This routine is written to output Pkcs1 version 0, private keys.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Pkcs.RsassaPssParameters.#ctor">
            The default version
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Pkcs.RsassaPssParameters.ToAsn1Object">
             <pre>
             RSASSA-PSS-params ::= SEQUENCE {
               hashAlgorithm      [0] OAEP-PSSDigestAlgorithms  DEFAULT sha1,
                maskGenAlgorithm   [1] PKCS1MGFAlgorithms  DEFAULT mgf1SHA1,
                saltLength         [2] INTEGER  DEFAULT 20,
                trailerField       [3] TrailerField  DEFAULT trailerFieldBC
              }
            
             OAEP-PSSDigestAlgorithms    ALGORITHM-IDENTIFIER ::= {
                { OID id-sha1 PARAMETERS NULL   }|
                { OID id-sha256 PARAMETERS NULL }|
                { OID id-sha384 PARAMETERS NULL }|
                { OID id-sha512 PARAMETERS NULL },
                ...  -- Allows for future expansion --
             }
            
             PKCS1MGFAlgorithms    ALGORITHM-IDENTIFIER ::= {
               { OID id-mgf1 PARAMETERS OAEP-PSSDigestAlgorithms },
                ...  -- Allows for future expansion --
             }
            
             TrailerField ::= INTEGER { trailerFieldBC(1) }
             </pre>
             @return the asn1 primitive representing the parameters.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Pkcs.SignedData">
            a Pkcs#7 signed data object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Pkcs.SignedData.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             SignedData ::= Sequence {
                 version Version,
                 digestAlgorithms DigestAlgorithmIdentifiers,
                 contentInfo ContentInfo,
                 certificates
                     [0] IMPLICIT ExtendedCertificatesAndCertificates
                              OPTIONAL,
                 crls
                     [1] IMPLICIT CertificateRevocationLists OPTIONAL,
                 signerInfos SignerInfos }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Pkcs.SignerInfo">
            a Pkcs#7 signer info object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Pkcs.SignerInfo.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <pre>
              SignerInfo ::= Sequence {
                  version Version,
                  issuerAndSerialNumber IssuerAndSerialNumber,
                  digestAlgorithm DigestAlgorithmIdentifier,
                  authenticatedAttributes [0] IMPLICIT Attributes OPTIONAL,
                  digestEncryptionAlgorithm DigestEncryptionAlgorithmIdentifier,
                  encryptedDigest EncryptedDigest,
                  unauthenticatedAttributes [1] IMPLICIT Attributes OPTIONAL
              }
            
              EncryptedDigest ::= OCTET STRING
            
              DigestAlgorithmIdentifier ::= AlgorithmIdentifier
            
              DigestEncryptionAlgorithmIdentifier ::= AlgorithmIdentifier
             </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Sec.ECPrivateKeyStructure">
            the elliptic curve private key object from SEC 1
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Sec.ECPrivateKeyStructure.ToAsn1Object">
            ECPrivateKey ::= SEQUENCE {
                version INTEGER { ecPrivkeyVer1(1) } (ecPrivkeyVer1),
                privateKey OCTET STRING,
                parameters [0] Parameters OPTIONAL,
                publicKey [1] BIT STRING OPTIONAL }
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Sec.SecNamedCurves.GetByOid(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
             return the X9ECParameters object for the named curve represented by
             the passed in object identifier. Null if the curve isn't present.
            
             @param oid an object identifier representing a named curve, if present.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Sec.SecNamedCurves.GetOid(System.String)">
             return the object identifier signified by the passed in name. Null
             if there is no object identifier associated with name.
            
             @return the object identifier associated with name, if present.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Sec.SecNamedCurves.GetName(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            return the named curve name represented by the given object identifier.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.Sec.SecNamedCurves.Names">
            returns an enumeration containing the name strings for curves
            contained in this structure.
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Sec.SecObjectIdentifiers.EllipticCurve">
            EllipticCurve OBJECT IDENTIFIER ::= {
                  iso(1) identified-organization(3) certicom(132) curve(0)
            }
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Smime.SmimeCapabilities">
            Handler class for dealing with S/MIME Capabilities
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Smime.SmimeCapabilities.PreferSignedData">
            general preferences
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Smime.SmimeCapabilities.Aes256Cbc">
            encryption algorithms preferences
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Smime.SmimeCapabilities.GetInstance(System.Object)">
             return an Attr object from the given object.
            
             @param o the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Smime.SmimeCapabilities.GetCapabilitiesForOid(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            returns an ArrayList with 0 or more objects of all the capabilities
            matching the passed in capability Oid. If the Oid passed is null the
            entire set is returned.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Smime.SmimeCapabilities.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            SMIMECapabilities ::= Sequence OF SMIMECapability
            </pre>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Smime.SmimeCapability.PreferSignedData">
            general preferences
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Smime.SmimeCapability.DesCbc">
            encryption algorithms preferences
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Smime.SmimeCapability.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            SMIMECapability ::= Sequence {
                capabilityID OBJECT IDENTIFIER,
                parameters ANY DEFINED BY capabilityID OPTIONAL
            }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Smime.SmimeCapabilityVector">
            Handler for creating a vector S/MIME Capabilities
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Smime.SmimeEncryptionKeyPreferenceAttribute">
            The SmimeEncryptionKeyPreference object.
            <pre>
            SmimeEncryptionKeyPreference ::= CHOICE {
                issuerAndSerialNumber   [0] IssuerAndSerialNumber,
                receipentKeyId          [1] RecipientKeyIdentifier,
                subjectAltKeyIdentifier [2] SubjectKeyIdentifier
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Smime.SmimeEncryptionKeyPreferenceAttribute.#ctor(Org.BouncyCastle.Asn1.Asn1OctetString)">
            @param sKeyId the subjectKeyIdentifier value (normally the X.509 one)
        </member>
        <member name="T:Org.BouncyCastle.Asn1.TeleTrust.TeleTrusTNamedCurves">
            elliptic curves defined in "ECC Brainpool Standard Curves and Curve Generation"
            http://www.ecc-brainpool.org/download/draft_pkix_additional_ecc_dp.txt
        </member>
        <member name="M:Org.BouncyCastle.Asn1.TeleTrust.TeleTrusTNamedCurves.GetByOid(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
             return the X9ECParameters object for the named curve represented by
             the passed in object identifier. Null if the curve isn't present.
            
             @param oid an object identifier representing a named curve, if present.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.TeleTrust.TeleTrusTNamedCurves.GetOid(System.String)">
             return the object identifier signified by the passed in name. Null
             if there is no object identifier associated with name.
            
             @return the object identifier associated with name, if present.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.TeleTrust.TeleTrusTNamedCurves.GetName(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            return the named curve name represented by the given object identifier.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.TeleTrust.TeleTrusTNamedCurves.Names">
            returns an enumeration containing the name strings for curves
            contained in this structure.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Tsp.Accuracy.ToAsn1Object">
            <pre>
            Accuracy ::= SEQUENCE {
                        seconds        INTEGER              OPTIONAL,
                        millis     [0] INTEGER  (1..999)    OPTIONAL,
                        micros     [1] INTEGER  (1..999)    OPTIONAL
                        }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Tsp.MessageImprint.GetInstance(System.Object)">
            @param o
            @return a MessageImprint object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Tsp.MessageImprint.ToAsn1Object">
            <pre>
               MessageImprint ::= SEQUENCE  {
                  hashAlgorithm                AlgorithmIdentifier,
                  hashedMessage                OCTET STRING  }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Tsp.TimeStampReq.ToAsn1Object">
            <pre>
            TimeStampReq ::= SEQUENCE  {
             version                      INTEGER  { v1(1) },
             messageImprint               MessageImprint,
               --a hash algorithm OID and the hash value of the data to be
               --time-stamped
             reqPolicy             TSAPolicyId              OPTIONAL,
             nonce                 INTEGER                  OPTIONAL,
             certReq               BOOLEAN                  DEFAULT FALSE,
             extensions            [0] IMPLICIT Extensions  OPTIONAL
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Tsp.TimeStampResp.ToAsn1Object">
            <pre>
            TimeStampResp ::= SEQUENCE  {
              status                  PkiStatusInfo,
              timeStampToken          TimeStampToken     OPTIONAL  }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Tsp.TstInfo.ToAsn1Object">
             <pre>
            
                 TstInfo ::= SEQUENCE  {
                    version                      INTEGER  { v1(1) },
                    policy                       TSAPolicyId,
                    messageImprint               MessageImprint,
                      -- MUST have the same value as the similar field in
                      -- TimeStampReq
                    serialNumber                 INTEGER,
                     -- Time-Stamping users MUST be ready to accommodate integers
                     -- up to 160 bits.
                    genTime                      GeneralizedTime,
                    accuracy                     Accuracy                 OPTIONAL,
                    ordering                     BOOLEAN             DEFAULT FALSE,
                    nonce                        INTEGER                  OPTIONAL,
                      -- MUST be present if the similar field was present
                      -- in TimeStampReq.  In that case it MUST have the same value.
                    tsa                          [0] GeneralName          OPTIONAL,
                    extensions                   [1] IMPLICIT Extensions   OPTIONAL  }
            
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Utilities.Asn1Dump.AsString(System.String,System.Boolean,Org.BouncyCastle.Asn1.Asn1Object,System.Text.StringBuilder)">
             dump a Der object as a formatted string with indentation
            
             @param obj the Asn1Object to be dumped out.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Utilities.Asn1Dump.DumpAsString(Org.BouncyCastle.Asn1.Asn1Encodable)">
             dump out a DER object as a formatted string, in non-verbose mode
            
             @param obj the Asn1Encodable to be dumped out.
             @return  the resulting string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Utilities.Asn1Dump.DumpAsString(Org.BouncyCastle.Asn1.Asn1Encodable,System.Boolean)">
             Dump out the object as a string
            
             @param obj the Asn1Encodable to be dumped out.
             @param verbose  if true, dump out the contents of octet and bit strings.
             @return  the resulting string.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X500.AttributeTypeAndValue">
            <summary>
            Holding class for the AttributeTypeAndValue structures that make up an RDN.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X500.AttributeTypeAndValue.ToAsn1Object">
            <summary>
            AttributeTypeAndValue::= SEQUENCE {
                      type OBJECT IDENTIFIER,
                     value ANY DEFINED BY type
              }
            </summary>
            <returns>A basic ASN.1 object representation.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X500.DirectoryString.ToAsn1Object">
            <pre>
             DirectoryString ::= CHOICE {
               teletexString               TeletexString (SIZE (1..MAX)),
               printableString             PrintableString (SIZE (1..MAX)),
               universalString             UniversalString (SIZE (1..MAX)),
               utf8String                  UTF8String (SIZE (1..MAX)),
               bmpString                   BMPString (SIZE (1..MAX))  }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X500.IX500NameStyle">
            <summary>
            This interface provides a profile to conform to when
            DNs are being converted into strings and back. The idea being that we'll be able to deal with
            the number of standard ways the fields in a DN should be
            encoded into their ASN.1 counterparts - a number that is rapidly approaching the
            number of machines on the Internet.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X500.IX500NameStyle.StringToValue(Org.BouncyCastle.Asn1.DerObjectIdentifier,System.String)">
            <summary>
            Convert the passed in String value into the appropriate ASN.1 encoded object.
            </summary>
            <param name="oid">The OID associated with the value in the DN.</param>
            <param name="value">The value of the particular DN component.</param>
            <returns>The ASN.1 equivalent for the value.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X500.IX500NameStyle.AttrNameToOID(System.String)">
            <summary>
            Return the OID associated with the passed in name.
            </summary>
            <param name="attrName">The string to match.</param>
            <returns>An OID</returns>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X500.IX500NameStyle.FromString(System.String)">
            <summary>
            Return an array of RDN generated from the passed in String.
            </summary>
            <param name="dirName"> the String representation.</param>
            <returns>An array of corresponding RDNs.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X500.IX500NameStyle.AreEqual(Org.BouncyCastle.Asn1.X500.X500Name,Org.BouncyCastle.Asn1.X500.X500Name)">
            <summary>
            Return true if the two names are equal.
            </summary>
            <param name="name1">First name for comparison.</param>
            <param name="name2">Second name for comparison.</param>
            <returns>true if name1 = name 2, false otherwise.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X500.IX500NameStyle.CalculateHashCode(Org.BouncyCastle.Asn1.X500.X500Name)">
            <summary>
            Calculate a hashCode for the passed in name.
            </summary>
            <param name="name">The name the hashCode is required for.</param>
            <returns>The calculated hashCode.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X500.IX500NameStyle.ToString(Org.BouncyCastle.Asn1.X500.X500Name)">
            <summary>
            Convert the passed in X500Name to a String.
            </summary>
            <param name="name">The name to convert.</param>
            <returns>A String representation.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X500.IX500NameStyle.OidToDisplayName(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>
            Return the display name for toString() associated with the OID.
            </summary>
            <param name="oid">The OID of interest.</param>
            <returns>The name displayed in toString(), null if no mapping provided.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X500.IX500NameStyle.OidToAttrNames(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>
            Return the acceptable names in a String DN that map to OID.
            </summary>
            <param name="oid">The OID of interest.</param>
            <returns>An array of String aliases for the OID, zero length if there are none.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X500.Rdn.#ctor(Org.BouncyCastle.Asn1.DerObjectIdentifier,Org.BouncyCastle.Asn1.Asn1Encodable)">
             Create a single valued RDN.
            
             @param oid RDN type.
             @param value RDN value.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X500.Rdn.#ctor(Org.BouncyCastle.Asn1.X500.AttributeTypeAndValue[])">
             Create a multi-valued RDN.
            
             @param aAndVs attribute type/value pairs making up the RDN
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X500.Rdn.Count">
             Return the number of AttributeTypeAndValue objects in this RDN,
            
             @return size of RDN, greater than 1 if multi-valued.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X500.Rdn.ToAsn1Object">
             <pre>
             RelativeDistinguishedName ::=
                                 SET OF AttributeTypeAndValue
            
             AttributeTypeAndValue ::= SEQUENCE {
                    type     AttributeType,
                    value    AttributeValue }
             </pre>
             @return this object as its ASN1Primitive type
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X500.Style.AbstractX500NameStyle">
            This class provides some default behavior and common implementation for a
            X500NameStyle. It should be easily extendable to support implementing the
            desired X500NameStyle.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X500.Style.AbstractX500NameStyle.CopyHashTable(System.Collections.IDictionary)">
             Tool function to shallow copy a Hashtable.
            
             @param paramsMap table to copy
             @return the copy of the table
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X500.Style.AbstractX500NameStyle.StringToValue(Org.BouncyCastle.Asn1.DerObjectIdentifier,System.String)">
             For all string values starting with '#' is assumed, that these are
             already valid ASN.1 objects encoded in hex.
             <p>
             All other string values are send to
             {@link AbstractX500NameStyle#encodeStringValue(ASN1ObjectIdentifier, String)}.
             </p>
             Subclasses should overwrite
             {@link AbstractX500NameStyle#encodeStringValue(ASN1ObjectIdentifier, String)}
             to change the encoding of specific types.
            
             @param oid the DN name of the value.
             @param value the String representation of the value.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X500.Style.AbstractX500NameStyle.EncodeStringValue(Org.BouncyCastle.Asn1.DerObjectIdentifier,System.String)">
             Encoded every value into a UTF8String.
             <p>
             Subclasses should overwrite
             this method to change the encoding of specific types.
             </p>
            
             @param oid the DN oid of the value
             @param value the String representation of the value
             @return a the value encoded into a ASN.1 object. Never returns <code>null</code>.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X500.Style.BCStrictStyle">
            Variation of BCStyle that insists on strict ordering for equality
            and hashCode comparisons
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X500.Style.BCStyle.C">
            country code - StringType(SIZE(2))
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X500.Style.BCStyle.O">
            organization - StringType(SIZE(1..64))
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X500.Style.BCStyle.OU">
            organizational unit name - StringType(SIZE(1..64))
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X500.Style.BCStyle.T">
            Title
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X500.Style.BCStyle.CN">
            common name - StringType(SIZE(1..64))
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X500.Style.BCStyle.SN">
            device serial number name - StringType(SIZE(1..64))
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X500.Style.BCStyle.STREET">
            street - StringType(SIZE(1..64))
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X500.Style.BCStyle.SERIALNUMBER">
            device serial number name - StringType(SIZE(1..64))
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X500.Style.BCStyle.L">
            locality name - StringType(SIZE(1..64))
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X500.Style.BCStyle.ST">
            state, or province name - StringType(SIZE(1..64))
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X500.Style.BCStyle.SURNAME">
            Naming attributes of type X520name
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X500.Style.BCStyle.BUSINESS_CATEGORY">
            businessCategory - DirectoryString(SIZE(1..128)
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X500.Style.BCStyle.POSTAL_CODE">
            postalCode - DirectoryString(SIZE(1..40)
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X500.Style.BCStyle.DN_QUALIFIER">
            dnQualifier - DirectoryString(SIZE(1..64)
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X500.Style.BCStyle.PSEUDONYM">
            RFC 3039 Pseudonym - DirectoryString(SIZE(1..64)
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X500.Style.BCStyle.DATE_OF_BIRTH">
            RFC 3039 DateOfBirth - GeneralizedTime - YYYYMMDD000000Z
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X500.Style.BCStyle.PLACE_OF_BIRTH">
            RFC 3039 PlaceOfBirth - DirectoryString(SIZE(1..128)
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X500.Style.BCStyle.GENDER">
            RFC 3039 Gender - PrintableString (SIZE(1)) -- "M", "F", "m" or "f"
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X500.Style.BCStyle.COUNTRY_OF_CITIZENSHIP">
            RFC 3039 CountryOfCitizenship - PrintableString (SIZE (2)) -- ISO 3166
            codes only
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X500.Style.BCStyle.COUNTRY_OF_RESIDENCE">
            RFC 3039 CountryOfResidence - PrintableString (SIZE (2)) -- ISO 3166
            codes only
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X500.Style.BCStyle.NAME_AT_BIRTH">
            ISIS-MTT NameAtBirth - DirectoryString(SIZE(1..64)
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X500.Style.BCStyle.POSTAL_ADDRESS">
            RFC 3039 PostalAddress - SEQUENCE SIZE (1..6) OF
            DirectoryString(SIZE(1..30))
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X500.Style.BCStyle.DMD_NAME">
            RFC 2256 dmdName
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X500.Style.BCStyle.TELEPHONE_NUMBER">
            id-at-telephoneNumber
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X500.Style.BCStyle.NAME">
            id-at-name
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X500.Style.BCStyle.EmailAddress">
            Email address (RSA PKCS#9 extension) - IA5String.
            <p/>Note: if you're trying to be ultra orthodox, don't use this! It shouldn't be in here.
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X500.Style.BCStyle.UnstructuredName">
            more from PKCS#9
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X500.Style.BCStyle.E">
            email address in Verisign certificates
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X500.Style.BCStyle.UID">
            LDAP User id.
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X500.Style.BCStyle.DefaultSymbols">
            default look up table translating OID values into their common symbols following
            the convention in RFC 2253 with a few extras
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X500.Style.BCStyle.DefaultLookUp">
            look up table translating common symbols into their OIDS.
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X500.Style.BCStyle.Instance">
            <remarks>
            Singleton instance.
            </remarks>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X500.Style.Rfc4519Style.DefaultSymbols">
            default look up table translating OID values into their common symbols following
            the convention in RFC 2253 with a few extras
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X500.Style.Rfc4519Style.DefaultLookUp">
            look up table translating common symbols into their OIDS.
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X500.Style.Rfc4519Style.INSTANCE">
            Singleton instance.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X500.Style.X500NameTokenizer">
            <summary>
            Class for breaking up an X500 Name into it's component tokens.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X500.X500Name">
             The X.500 Name object.
             <pre>
                 Name ::= CHOICE {
                                   RDNSequence }
            
                 RDNSequence ::= SEQUENCE OF RelativeDistinguishedName
            
                 RelativeDistinguishedName ::= SET SIZE (1..MAX) OF AttributeTypeAndValue
            
                 AttributeTypeAndValue ::= SEQUENCE {
                                               type  OBJECT IDENTIFIER,
                                               value ANY }
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X500.X500Name.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
            Return a X500Name based on the passed in tagged object.
            
            @param obj tag object holding name.
            @param explicit true if explicitly tagged false otherwise.
            @return the X500Name
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X500.X500Name.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from ASN1Sequence
            
             the principal will be a list of constructed sets, each containing an (OID, String) pair.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X500.X500Name.GetRdns">
             return an array of RDNs in structure order.
            
             @return an array of RDN objects.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X500.X500Name.GetAttributeTypes">
             return an array of OIDs contained in the attribute type of each RDN in structure order.
            
             @return an array, possibly zero length, of DerObjectIdentifiers objects.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X500.X500Name.GetRdns(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
             return an array of RDNs containing the attribute type given by OID in structure order.
            
             @param attributeType the type OID we are looking for.
             @return an array, possibly zero length, of RDN objects.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X500.X500Name.Equivalent(System.Object)">
            test for equality - note: case is ignored.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X500.X500Name.DefaultStyle">
             The current default style.
            
             @return default style for X500Name construction.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X500.X500NameBuilder">
            <summary>
            A builder class for making X.500 Name objects.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X500.X500NameBuilder.#ctor">
            <summary>
            Constructor using the default style (BCStyle).
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X500.X500NameBuilder.#ctor(Org.BouncyCastle.Asn1.X500.IX500NameStyle)">
            <summary>
            Constructor using a specified style.
            </summary>
            <param name="template">The style template for string to DN conversion.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X500.X500NameBuilder.AddRdn(Org.BouncyCastle.Asn1.DerObjectIdentifier,System.String)">
            <summary>
            Add an RDN based on a single OID and a string representation of its value.
            </summary>
            <param name="oid">The OID for this RDN.</param>
            <param name="value">The string representation of the value the OID refers to.</param>
            <returns>The current builder instance.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X500.X500NameBuilder.AddRdn(Org.BouncyCastle.Asn1.DerObjectIdentifier,Org.BouncyCastle.Asn1.Asn1Encodable)">
            <summary>
            Add an RDN based on a single OID and an ASN.1 value.
            </summary>
            <param name="oid">The OID for this RDN.</param>
            <param name="value">The ASN.1 value the OID refers to.</param>
            <returns>The current builder instance.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X500.X500NameBuilder.AddRdn(Org.BouncyCastle.Asn1.X500.AttributeTypeAndValue)">
            <summary>
            Add an RDN based on the passed in AttributeTypeAndValue.
            </summary>
            <param name="attrTAndV">the AttributeTypeAndValue to build the RDN from.</param>
            <returns>The current builder instance.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X500.X500NameBuilder.AddMultiValuedRdn(Org.BouncyCastle.Asn1.DerObjectIdentifier[],System.String[])">
            <summary>
            Add a multi-valued RDN made up of the passed in OIDs and associated string values.
            </summary>
            <param name="oids">The OIDs making up the RDN.</param>
            <param name="values">The string representation of the values the OIDs refer to.</param>
            <returns>The current builder instance.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X500.X500NameBuilder.AddMultiValuedRdn(Org.BouncyCastle.Asn1.DerObjectIdentifier[],Org.BouncyCastle.Asn1.Asn1Encodable[])">
            <summary>
            Add a multi-valued RDN made up of the passed in OIDs and associated ASN.1 values.
            </summary>
            <param name="oids">The OIDs making up the RDN.</param>
            <param name="values">The ASN.1 values the OIDs refer to.</param>
            <returns>The current builder instance.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X500.X500NameBuilder.AddMultiValuedRdn(Org.BouncyCastle.Asn1.X500.AttributeTypeAndValue[])">
            <summary>
            Add an RDN based on the passed in AttributeTypeAndValues.
            </summary>
            <param name="attrTAndVs">The AttributeTypeAndValues to build the RDN from.</param>
            <returns>The current builder instance.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X500.X500NameBuilder.Build">
            <summary>
            Build an X.500 name for the current builder state.
            </summary>
            <returns>A new X.500 name.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.AccessDescription">
            The AccessDescription object.
            <pre>
            AccessDescription  ::=  SEQUENCE {
                  accessMethod          OBJECT IDENTIFIER,
                  accessLocation        GeneralName  }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AccessDescription.#ctor(Org.BouncyCastle.Asn1.DerObjectIdentifier,Org.BouncyCastle.Asn1.X509.GeneralName)">
            create an AccessDescription with the oid and location provided.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.AccessDescription.AccessMethod">
            
             @return the access method.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.AccessDescription.AccessLocation">
            
             @return the access location
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier.Algorithm">
            <summary>
            Return the OID in the Algorithm entry of this identifier.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier.Parameters">
            <summary>
            Return the parameters structure in the Parameters entry of this identifier.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
                 AlgorithmIdentifier ::= Sequence {
                                       algorithm OBJECT IDENTIFIER,
                                       parameters ANY DEFINED BY algorithm OPTIONAL }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AttCertIssuer.#ctor(Org.BouncyCastle.Asn1.X509.GeneralNames)">
            <summary>
            Don't use this one if you are trying to be RFC 3281 compliant.
            Use it for v1 attribute certificates only.
            </summary>
            <param name="names">Our GeneralNames structure</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AttCertIssuer.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             AttCertIssuer ::= CHOICE {
                  v1Form   GeneralNames,  -- MUST NOT be used in this
                                          -- profile
                  v2Form   [0] V2Form     -- v2 only
             }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AttCertValidityPeriod.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             AttCertValidityPeriod  ::= Sequence {
                  notBeforeTime  GeneralizedTime,
                  notAfterTime   GeneralizedTime
             }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AttributeX509.GetInstance(System.Object)">
             return an Attr object from the given object.
            
             @param o the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AttributeX509.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            Attr ::= Sequence {
                attrType OBJECT IDENTIFIER,
                attrValues Set OF AttributeValue
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AttributeCertificate.GetInstance(System.Object)">
            @param obj
            @return
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AttributeCertificate.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             AttributeCertificate ::= Sequence {
                  acinfo               AttributeCertificateInfo,
                  signatureAlgorithm   AlgorithmIdentifier,
                  signatureValue       BIT STRING
             }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AttributeCertificateInfo.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <pre>
              AttributeCertificateInfo ::= Sequence {
                   version              AttCertVersion -- version is v2,
                   holder               Holder,
                   issuer               AttCertIssuer,
                   signature            AlgorithmIdentifier,
                   serialNumber         CertificateSerialNumber,
                   attrCertValidityPeriod   AttCertValidityPeriod,
                   attributes           Sequence OF Attr,
                   issuerUniqueID       UniqueIdentifier OPTIONAL,
                   extensions           Extensions OPTIONAL
              }
            
              AttCertVersion ::= Integer { v2(1) }
             </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.AuthorityInformationAccess">
             The AuthorityInformationAccess object.
             <pre>
             id-pe-authorityInfoAccess OBJECT IDENTIFIER ::= { id-pe 1 }
            
             AuthorityInfoAccessSyntax  ::=
                  Sequence SIZE (1..MAX) OF AccessDescription
             AccessDescription  ::=  Sequence {
                   accessMethod          OBJECT IDENTIFIER,
                   accessLocation        GeneralName  }
            
             id-ad OBJECT IDENTIFIER ::= { id-pkix 48 }
             id-ad-caIssuers OBJECT IDENTIFIER ::= { id-ad 2 }
             id-ad-ocsp OBJECT IDENTIFIER ::= { id-ad 1 }
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AuthorityInformationAccess.#ctor(Org.BouncyCastle.Asn1.DerObjectIdentifier,Org.BouncyCastle.Asn1.X509.GeneralName)">
            create an AuthorityInformationAccess with the oid and location provided.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.AuthorityKeyIdentifier">
             The AuthorityKeyIdentifier object.
             <pre>
             id-ce-authorityKeyIdentifier OBJECT IDENTIFIER ::=  { id-ce 35 }
            
               AuthorityKeyIdentifier ::= Sequence {
                  keyIdentifier             [0] IMPLICIT KeyIdentifier           OPTIONAL,
                  authorityCertIssuer       [1] IMPLICIT GeneralNames            OPTIONAL,
                  authorityCertSerialNumber [2] IMPLICIT CertificateSerialNumber OPTIONAL  }
            
               KeyIdentifier ::= OCTET STRING
             </pre>
            
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AuthorityKeyIdentifier.#ctor(Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo)">
                     *
                     * Calulates the keyidentifier using a SHA1 hash over the BIT STRING
                     * from SubjectPublicKeyInfo as defined in RFC2459.
                     *
                     * Example of making a AuthorityKeyIdentifier:
                     * <pre>
            	     *   SubjectPublicKeyInfo apki = new SubjectPublicKeyInfo((ASN1Sequence)new ASN1InputStream(
            		 *       publicKey.getEncoded()).readObject());
                     *   AuthorityKeyIdentifier aki = new AuthorityKeyIdentifier(apki);
                     * </pre>
                     *
                     *
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AuthorityKeyIdentifier.#ctor(Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo,Org.BouncyCastle.Asn1.X509.GeneralNames,Org.BouncyCastle.Math.BigInteger)">
            create an AuthorityKeyIdentifier with the GeneralNames tag and
            the serial number provided as well.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AuthorityKeyIdentifier.#ctor(Org.BouncyCastle.Asn1.X509.GeneralNames,Org.BouncyCastle.Math.BigInteger)">
            create an AuthorityKeyIdentifier with the GeneralNames tag and
            the serial number provided.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AuthorityKeyIdentifier.#ctor(System.Byte[])">
            create an AuthorityKeyIdentifier with a precomputed key identifier
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AuthorityKeyIdentifier.#ctor(System.Byte[],Org.BouncyCastle.Asn1.X509.GeneralNames,Org.BouncyCastle.Math.BigInteger)">
            create an AuthorityKeyIdentifier with a precomupted key identifier
            and the GeneralNames tag and the serial number provided as well.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AuthorityKeyIdentifier.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.BasicConstraints.#ctor(System.Int32)">
             create a cA=true object for the given path length constraint.
            
             @param pathLenConstraint
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.BasicConstraints.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            BasicConstraints := Sequence {
               cA                  Boolean DEFAULT FALSE,
               pathLenConstraint   Integer (0..MAX) OPTIONAL
            }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.CertificateList">
             PKIX RFC-2459
            
             The X.509 v2 CRL syntax is as follows.  For signature calculation,
             the data that is to be signed is ASN.1 Der encoded.
            
             <pre>
             CertificateList  ::=  Sequence  {
                  tbsCertList          TbsCertList,
                  signatureAlgorithm   AlgorithmIdentifier,
                  signatureValue       BIT STRING  }
             </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.CertificatePair">
             This class helps to support crossCerfificatePairs in a LDAP directory
             according RFC 2587
            
             <pre>
                 crossCertificatePairATTRIBUTE::={
                   WITH SYNTAX   CertificatePair
                   EQUALITY MATCHING RULE certificatePairExactMatch
                   ID joint-iso-ccitt(2) ds(5) attributeType(4) crossCertificatePair(40)}
             </pre>
            
             <blockquote> The forward elements of the crossCertificatePair attribute of a
             CA's directory entry shall be used to store all, except self-issued
             certificates issued to this CA. Optionally, the reverse elements of the
             crossCertificatePair attribute, of a CA's directory entry may contain a
             subset of certificates issued by this CA to other CAs. When both the forward
             and the reverse elements are present in a single attribute value, issuer name
             in one certificate shall match the subject name in the other and vice versa,
             and the subject public key in one certificate shall be capable of verifying
             the digital signature on the other certificate and vice versa.
            
             When a reverse element is present, the forward element value and the reverse
             element value need not be stored in the same attribute value; in other words,
             they can be stored in either a single attribute value or two attribute
             values. </blockquote>
            
             <pre>
                   CertificatePair ::= SEQUENCE {
                     forward		[0]	Certificate OPTIONAL,
                     reverse		[1]	Certificate OPTIONAL,
                     -- at least one of the pair shall be present -- }
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.CertificatePair.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from Asn1Sequence.
             <p/>
             The sequence is of type CertificatePair:
             <p/>
             <pre>
                   CertificatePair ::= SEQUENCE {
                     forward		[0]	Certificate OPTIONAL,
                     reverse		[1]	Certificate OPTIONAL,
                     -- at least one of the pair shall be present -- }
             </pre>
            
             @param seq The ASN.1 sequence.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.CertificatePair.#ctor(Org.BouncyCastle.Asn1.X509.X509CertificateStructure,Org.BouncyCastle.Asn1.X509.X509CertificateStructure)">
             Constructor from a given details.
            
             @param forward Certificates issued to this CA.
             @param reverse Certificates issued by this CA to other CAs.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.CertificatePair.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
                   CertificatePair ::= SEQUENCE {
                     forward		[0]	Certificate OPTIONAL,
                     reverse		[1]	Certificate OPTIONAL,
                     -- at least one of the pair shall be present -- }
             </pre>
            
             @return a DERObject
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.CertificatePair.Forward">
            @return Returns the forward.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.CertificatePair.Reverse">
            @return Returns the reverse.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.CertificatePolicies.#ctor(Org.BouncyCastle.Asn1.X509.PolicyInformation)">
            Construct a CertificatePolicies object containing one PolicyInformation.
            
            @param name the name to be contained.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.CertificatePolicies.ToAsn1Object">
            Produce an object suitable for an ASN1OutputStream.
            <pre>
            CertificatePolicies ::= SEQUENCE SIZE {1..MAX} OF PolicyInformation
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.CertPolicyID">
             CertPolicyId, used in the CertificatePolicies and PolicyMappings
             X509V3 Extensions.
            
             <pre>
                 CertPolicyId ::= OBJECT IDENTIFIER
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.CrlDistPoint.GetDistributionPoints">
             Return the distribution points making up the sequence.
            
             @return DistributionPoint[]
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.CrlDistPoint.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            CrlDistPoint ::= Sequence SIZE {1..MAX} OF DistributionPoint
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.CrlNumber">
            The CRLNumber object.
            <pre>
            CRLNumber::= Integer(0..MAX)
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.CrlReason">
            The CRLReason enumeration.
            <pre>
            CRLReason ::= Enumerated {
             unspecified             (0),
             keyCompromise           (1),
             cACompromise            (2),
             affiliationChanged      (3),
             superseded              (4),
             cessationOfOperation    (5),
             certificateHold         (6),
             removeFromCRL           (8),
             privilegeWithdrawn      (9),
             aACompromise           (10)
            }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.DigestInfo">
            The DigestInfo object.
            <pre>
            DigestInfo::=Sequence{
                     digestAlgorithm  AlgorithmIdentifier,
                     digest OCTET STRING }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.DisplayText">
             <code>DisplayText</code> class, used in
             <code>CertificatePolicies</code> X509 V3 extensions (in policy qualifiers).
            
             <p>It stores a string in a chosen encoding.
             <pre>
             DisplayText ::= CHOICE {
                  ia5String        IA5String      (SIZE (1..200)),
                  visibleString    VisibleString  (SIZE (1..200)),
                  bmpString        BMPString      (SIZE (1..200)),
                  utf8String       UTF8String     (SIZE (1..200)) }
             </pre></p>
             @see PolicyQualifierInfo
             @see PolicyInformation
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.DisplayText.ContentTypeIA5String">
             Constant corresponding to ia5String encoding.
            
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.DisplayText.ContentTypeBmpString">
             Constant corresponding to bmpString encoding.
            
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.DisplayText.ContentTypeUtf8String">
             Constant corresponding to utf8String encoding.
            
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.DisplayText.ContentTypeVisibleString">
             Constant corresponding to visibleString encoding.
            
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.DisplayText.DisplayTextMaximumSize">
             Describe constant <code>DisplayTextMaximumSize</code> here.
            
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.DisplayText.#ctor(System.Int32,System.String)">
             Creates a new <code>DisplayText</code> instance.
            
             @param type the desired encoding type for the text.
             @param text the text to store. Strings longer than 200
             characters are truncated.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.DisplayText.#ctor(System.String)">
             Creates a new <code>DisplayText</code> instance.
            
             @param text the text to encapsulate. Strings longer than 200
             characters are truncated.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.DisplayText.#ctor(Org.BouncyCastle.Asn1.IAsn1String)">
             Creates a new <code>DisplayText</code> instance.
             <p>Useful when reading back a <code>DisplayText</code> class
             from it's Asn1Encodable form.</p>
            
             @param contents an <code>Asn1Encodable</code> instance.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.DisplayText.GetString">
             Returns the stored <code>string</code> object.
            
             @return the stored text as a <code>string</code>.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.DistributionPoint">
            The DistributionPoint object.
            <pre>
            DistributionPoint ::= Sequence {
                 distributionPoint [0] DistributionPointName OPTIONAL,
                 reasons           [1] ReasonFlags OPTIONAL,
                 cRLIssuer         [2] GeneralNames OPTIONAL
            }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.DistributionPointName">
            The DistributionPointName object.
            <pre>
            DistributionPointName ::= CHOICE {
                fullName                 [0] GeneralNames,
                nameRelativeToCRLIssuer  [1] RDN
            }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.ExtendedKeyUsage">
            The extendedKeyUsage object.
            <pre>
                 extendedKeyUsage ::= Sequence SIZE (1..MAX) OF KeyPurposeId
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.ExtendedKeyUsage.GetAllUsages">
            Returns all extended key usages.
            The returned ArrayList contains DerObjectIdentifier instances.
            @return An ArrayList with all key purposes.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.GeneralName">
             The GeneralName object.
             <pre>
             GeneralName ::= CHOICE {
                  otherName                       [0]     OtherName,
                  rfc822Name                      [1]     IA5String,
                  dNSName                         [2]     IA5String,
                  x400Address                     [3]     ORAddress,
                  directoryName                   [4]     Name,
                  ediPartyName                    [5]     EDIPartyName,
                  uniformResourceIdentifier       [6]     IA5String,
                  iPAddress                       [7]     OCTET STRING,
                  registeredID                    [8]     OBJECT IDENTIFIER}
            
             OtherName ::= Sequence {
                  type-id    OBJECT IDENTIFIER,
                  value      [0] EXPLICIT ANY DEFINED BY type-id }
            
             EDIPartyName ::= Sequence {
                  nameAssigner            [0]     DirectoryString OPTIONAL,
                  partyName               [1]     DirectoryString }
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.GeneralName.#ctor(Org.BouncyCastle.Asn1.Asn1Object,System.Int32)">
             When the subjectAltName extension contains an Internet mail address,
             the address MUST be included as an rfc822Name. The format of an
             rfc822Name is an "addr-spec" as defined in RFC 822 [RFC 822].
            
             When the subjectAltName extension contains a domain name service
             label, the domain name MUST be stored in the dNSName (an IA5String).
             The name MUST be in the "preferred name syntax," as specified by RFC
             1034 [RFC 1034].
            
             When the subjectAltName extension contains a URI, the name MUST be
             stored in the uniformResourceIdentifier (an IA5String). The name MUST
             be a non-relative URL, and MUST follow the URL syntax and encoding
             rules specified in [RFC 1738].  The name must include both a scheme
             (e.g., "http" or "ftp") and a scheme-specific-part.  The scheme-
             specific-part must include a fully qualified domain name or IP
             address as the host.
            
             When the subjectAltName extension contains a iPAddress, the address
             MUST be stored in the octet string in "network byte order," as
             specified in RFC 791 [RFC 791]. The least significant bit (LSB) of
             each octet is the LSB of the corresponding byte in the network
             address. For IP Version 4, as specified in RFC 791, the octet string
             MUST contain exactly four octets.  For IP Version 6, as specified in
             RFC 1883, the octet string MUST contain exactly sixteen octets [RFC
             1883].
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.GeneralName.#ctor(System.Int32,System.String)">
             Create a GeneralName for the given tag from the passed in string.
             <p>
             This constructor can handle:
             <ul>
             <li>rfc822Name</li>
             <li>iPAddress</li>
             <li>directoryName</li>
             <li>dNSName</li>
             <li>uniformResourceIdentifier</li>
             <li>registeredID</li>
             </ul>
             For x400Address, otherName and ediPartyName there is no common string
             format defined.
             </p><p>
             Note: A directory name can be encoded in different ways into a byte
             representation. Be aware of this if the byte representation is used for
             comparing results.
             </p>
            
             @param tag tag number
             @param name string representation of name
             @throws ArgumentException if the string encoding is not correct or
                         not supported.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.GeneralNames.#ctor(Org.BouncyCastle.Asn1.X509.GeneralName)">
            <summary>Construct a GeneralNames object containing one GeneralName.</summary>
            <param name="name">The name to be contained.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.GeneralNames.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            GeneralNames ::= Sequence SIZE {1..MAX} OF GeneralName
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.GeneralSubtree">
             Class for containing a restriction object subtrees in NameConstraints. See
             RFC 3280.
            
             <pre>
            
                   GeneralSubtree ::= SEQUENCE
                   {
                     baseName                    GeneralName,
                     minimum         [0]     BaseDistance DEFAULT 0,
                     maximum         [1]     BaseDistance OPTIONAL
                   }
             </pre>
            
             @see org.bouncycastle.asn1.x509.NameConstraints
            
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.GeneralSubtree.#ctor(Org.BouncyCastle.Asn1.X509.GeneralName,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
             Constructor from a given details.
            
             According RFC 3280, the minimum and maximum fields are not used with any
             name forms, thus minimum MUST be zero, and maximum MUST be absent.
             <p>
             If minimum is <code>null</code>, zero is assumed, if
             maximum is <code>null</code>, maximum is absent.</p>
            
             @param baseName
                        A restriction.
             @param minimum
                        Minimum
            
             @param maximum
                        Maximum
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.GeneralSubtree.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
            
             Returns:
            
             <pre>
                   GeneralSubtree ::= SEQUENCE
                   {
                     baseName                    GeneralName,
                     minimum         [0]     BaseDistance DEFAULT 0,
                     maximum         [1]     BaseDistance OPTIONAL
                   }
             </pre>
            
             @return a DERObject
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.Holder">
            The Holder object.
            <p>
            For an v2 attribute certificate this is:
            
            <pre>
                       Holder ::= SEQUENCE {
                             baseCertificateID   [0] IssuerSerial OPTIONAL,
                                      -- the issuer and serial number of
                                      -- the holder's Public Key Certificate
                             entityName          [1] GeneralNames OPTIONAL,
                                      -- the name of the claimant or role
                             objectDigestInfo    [2] ObjectDigestInfo OPTIONAL
                                      -- used to directly authenticate the holder,
                                      -- for example, an executable
                       }
            </pre>
            </p>
            <p>
            For an v1 attribute certificate this is:
            
            <pre>
                    subject CHOICE {
                     baseCertificateID [0] IssuerSerial,
                     -- associated with a Public Key Certificate
                     subjectName [1] GeneralNames },
                     -- associated with a name
            </pre>
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Holder.#ctor(Org.BouncyCastle.Asn1.Asn1TaggedObject)">
            Constructor for a holder for an v1 attribute certificate.
            
            @param tagObj The ASN.1 tagged holder object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Holder.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
            Constructor for a holder for an v2 attribute certificate. *
            
            @param seq The ASN.1 sequence.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Holder.#ctor(Org.BouncyCastle.Asn1.X509.IssuerSerial,System.Int32)">
            Constructs a holder from a IssuerSerial.
            @param baseCertificateID The IssuerSerial.
            @param version The version of the attribute certificate. 
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.Holder.Version">
            Returns 1 for v2 attribute certificates or 0 for v1 attribute
            certificates. 
            @return The version of the attribute certificate.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Holder.#ctor(Org.BouncyCastle.Asn1.X509.GeneralNames)">
            Constructs a holder with an entityName for v2 attribute certificates or
            with a subjectName for v1 attribute certificates.
            
            @param entityName The entity or subject name.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Holder.#ctor(Org.BouncyCastle.Asn1.X509.GeneralNames,System.Int32)">
            Constructs a holder with an entityName for v2 attribute certificates or
            with a subjectName for v1 attribute certificates.
            
            @param entityName The entity or subject name.
            @param version The version of the attribute certificate. 
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Holder.#ctor(Org.BouncyCastle.Asn1.X509.ObjectDigestInfo)">
            Constructs a holder from an object digest info.
            
            @param objectDigestInfo The object digest info object.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.Holder.EntityName">
            Returns the entityName for an v2 attribute certificate or the subjectName
            for an v1 attribute certificate.
            
            @return The entityname or subjectname.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Holder.ToAsn1Object">
            The Holder object.
            <pre>
             Holder ::= Sequence {
                   baseCertificateID   [0] IssuerSerial OPTIONAL,
                            -- the issuer and serial number of
                            -- the holder's Public Key Certificate
                   entityName          [1] GeneralNames OPTIONAL,
                            -- the name of the claimant or role
                   objectDigestInfo    [2] ObjectDigestInfo OPTIONAL
                            -- used to directly authenticate the holder,
                            -- for example, an executable
             }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.IetfAttrSyntax">
            Implementation of <code>IetfAttrSyntax</code> as specified by RFC3281.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.IetfAttrSyntax.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
            
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.IetfAttrSyntax.ToAsn1Object">
            
             <pre>
            
              IetfAttrSyntax ::= Sequence {
                policyAuthority [0] GeneralNames OPTIONAL,
                values Sequence OF CHOICE {
                  octets OCTET STRING,
                  oid OBJECT IDENTIFIER,
                  string UTF8String
                }
              }
            
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.IssuerSerial.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             IssuerSerial  ::=  Sequence {
                  issuer         GeneralNames,
                  serial         CertificateSerialNumber,
                  issuerUid      UniqueIdentifier OPTIONAL
             }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.IssuingDistributionPoint">
            <pre>
            IssuingDistributionPoint ::= SEQUENCE { 
              distributionPoint          [0] DistributionPointName OPTIONAL, 
              onlyContainsUserCerts      [1] BOOLEAN DEFAULT FALSE, 
              onlyContainsCACerts        [2] BOOLEAN DEFAULT FALSE, 
              onlySomeReasons            [3] ReasonFlags OPTIONAL, 
              indirectCRL                [4] BOOLEAN DEFAULT FALSE,
              onlyContainsAttributeCerts [5] BOOLEAN DEFAULT FALSE }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.IssuingDistributionPoint.#ctor(Org.BouncyCastle.Asn1.X509.DistributionPointName,System.Boolean,System.Boolean,Org.BouncyCastle.Asn1.X509.ReasonFlags,System.Boolean,System.Boolean)">
            Constructor from given details.
            
            @param distributionPoint
                       May contain an URI as pointer to most current CRL.
            @param onlyContainsUserCerts Covers revocation information for end certificates.
            @param onlyContainsCACerts Covers revocation information for CA certificates.
            
            @param onlySomeReasons
                       Which revocation reasons does this point cover.
            @param indirectCRL
                       If <code>true</code> then the CRL contains revocation
                       information about certificates ssued by other CAs.
            @param onlyContainsAttributeCerts Covers revocation information for attribute certificates.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.IssuingDistributionPoint.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
            Constructor from Asn1Sequence
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.IssuingDistributionPoint.DistributionPoint">
            @return Returns the distributionPoint.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.IssuingDistributionPoint.OnlySomeReasons">
            @return Returns the onlySomeReasons.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.KeyPurposeID">
            The KeyPurposeID object.
            <pre>
                KeyPurposeID ::= OBJECT IDENTIFIER
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.KeyUsage">
             The KeyUsage object.
             <pre>
                id-ce-keyUsage OBJECT IDENTIFIER ::=  { id-ce 15 }
            
                KeyUsage ::= BIT STRING {
                     digitalSignature        (0),
                     nonRepudiation          (1),
                     keyEncipherment         (2),
                     dataEncipherment        (3),
                     keyAgreement            (4),
                     keyCertSign             (5),
                     cRLSign                 (6),
                     encipherOnly            (7),
                     decipherOnly            (8) }
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.KeyUsage.#ctor(System.Int32)">
             Basic constructor.
            
             @param usage - the bitwise OR of the Key Usage flags giving the
             allowed uses for the key.
             e.g. (KeyUsage.keyEncipherment | KeyUsage.dataEncipherment)
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.NameConstraints.#ctor(System.Collections.IList,System.Collections.IList)">
             Constructor from a given details.
            
             <p>permitted and excluded are Vectors of GeneralSubtree objects.</p>
            
             @param permitted Permitted subtrees
             @param excluded Excluded subtrees
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.NoticeReference">
             <code>NoticeReference</code> class, used in
             <code>CertificatePolicies</code> X509 V3 extensions
             (in policy qualifiers).
            
             <pre>
              NoticeReference ::= Sequence {
                  organization     DisplayText,
                  noticeNumbers    Sequence OF Integer }
            
             </pre>
            
             @see PolicyQualifierInfo
             @see PolicyInformation
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.NoticeReference.#ctor(System.String,System.Collections.IList)">
             Creates a new <code>NoticeReference</code> instance.
            
             @param organization a <code>String</code> value
             @param numbers a <code>Vector</code> value
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.NoticeReference.#ctor(System.String,Org.BouncyCastle.Asn1.Asn1EncodableVector)">
             Creates a new <code>NoticeReference</code> instance.
            
             @param organization a <code>String</code> value
             @param noticeNumbers an <code>ASN1EncodableVector</code> value
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.NoticeReference.#ctor(Org.BouncyCastle.Asn1.X509.DisplayText,Org.BouncyCastle.Asn1.Asn1EncodableVector)">
             Creates a new <code>NoticeReference</code> instance.
            
             @param organization displayText
             @param noticeNumbers an <code>ASN1EncodableVector</code> value
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.NoticeReference.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Creates a new <code>NoticeReference</code> instance.
             <p>Useful for reconstructing a <code>NoticeReference</code>
             instance from its encodable/encoded form.</p>
            
             @param as an <code>Asn1Sequence</code> value obtained from either
             calling @{link ToAsn1Object()} for a <code>NoticeReference</code>
             instance or from parsing it from a Der-encoded stream.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.NoticeReference.ToAsn1Object">
             Describe <code>ToAsn1Object</code> method here.
            
             @return a <code>Asn1Object</code> value
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.ObjectDigestInfo">
            ObjectDigestInfo ASN.1 structure used in v2 attribute certificates.
            
            <pre>
             
               ObjectDigestInfo ::= SEQUENCE {
                    digestedObjectType  ENUMERATED {
                            publicKey            (0),
                            publicKeyCert        (1),
                            otherObjectTypes     (2) },
                                    -- otherObjectTypes MUST NOT
                                    -- be used in this profile
                    otherObjectTypeID   OBJECT IDENTIFIER OPTIONAL,
                    digestAlgorithm     AlgorithmIdentifier,
                    objectDigest        BIT STRING
               }
              
            </pre>
            
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.ObjectDigestInfo.PublicKey">
            The public key is hashed.
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.ObjectDigestInfo.PublicKeyCert">
            The public key certificate is hashed.
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.ObjectDigestInfo.OtherObjectDigest">
            An other object is hashed.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.ObjectDigestInfo.#ctor(System.Int32,System.String,Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier,System.Byte[])">
            Constructor from given details.
            <p>
            If <code>digestedObjectType</code> is not {@link #publicKeyCert} or
            {@link #publicKey} <code>otherObjectTypeID</code> must be given,
            otherwise it is ignored.</p>
            
            @param digestedObjectType The digest object type.
            @param otherObjectTypeID The object type ID for
                       <code>otherObjectDigest</code>.
            @param digestAlgorithm The algorithm identifier for the hash.
            @param objectDigest The hash value.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.ObjectDigestInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            
            <pre>
             
               ObjectDigestInfo ::= SEQUENCE {
                    digestedObjectType  ENUMERATED {
                            publicKey            (0),
                            publicKeyCert        (1),
                            otherObjectTypes     (2) },
                                    -- otherObjectTypes MUST NOT
                                    -- be used in this profile
                    otherObjectTypeID   OBJECT IDENTIFIER OPTIONAL,
                    digestAlgorithm     AlgorithmIdentifier,
                    objectDigest        BIT STRING
               }
              
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.PolicyMappings">
             PolicyMappings V3 extension, described in RFC3280.
             <pre>
                PolicyMappings ::= Sequence SIZE (1..MAX) OF Sequence {
                  issuerDomainPolicy      CertPolicyId,
                  subjectDomainPolicy     CertPolicyId }
             </pre>
            
             @see <a href="http://www.faqs.org/rfc/rfc3280.txt">RFC 3280, section 4.2.1.6</a>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.PolicyMappings.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Creates a new <code>PolicyMappings</code> instance.
            
             @param seq an <code>Asn1Sequence</code> constructed as specified
             in RFC 3280
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.PolicyMappings.#ctor(System.Collections.IDictionary)">
             Creates a new <code>PolicyMappings</code> instance.
            
             @param mappings a <code>HashMap</code> value that maps
             <code>string</code> oids
             to other <code>string</code> oids.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.PolicyQualifierID">
             PolicyQualifierId, used in the CertificatePolicies
             X509V3 extension.
            
             <pre>
                id-qt          OBJECT IDENTIFIER ::=  { id-pkix 2 }
                id-qt-cps      OBJECT IDENTIFIER ::=  { id-qt 1 }
                id-qt-unotice  OBJECT IDENTIFIER ::=  { id-qt 2 }
              PolicyQualifierId ::=
                   OBJECT IDENTIFIER ( id-qt-cps | id-qt-unotice )
             </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.PolicyQualifierInfo">
             Policy qualifiers, used in the X509V3 CertificatePolicies
             extension.
            
             <pre>
               PolicyQualifierInfo ::= Sequence {
                   policyQualifierId  PolicyQualifierId,
                   qualifier          ANY DEFINED BY policyQualifierId }
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.PolicyQualifierInfo.#ctor(Org.BouncyCastle.Asn1.DerObjectIdentifier,Org.BouncyCastle.Asn1.Asn1Encodable)">
             Creates a new <code>PolicyQualifierInfo</code> instance.
            
             @param policyQualifierId a <code>PolicyQualifierId</code> value
             @param qualifier the qualifier, defined by the above field.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.PolicyQualifierInfo.#ctor(System.String)">
             Creates a new <code>PolicyQualifierInfo</code> containing a
             cPSuri qualifier.
            
             @param cps the CPS (certification practice statement) uri as a
             <code>string</code>.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.PolicyQualifierInfo.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Creates a new <code>PolicyQualifierInfo</code> instance.
            
             @param as <code>PolicyQualifierInfo</code> X509 structure
             encoded as an Asn1Sequence.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.PolicyQualifierInfo.ToAsn1Object">
             Returns a Der-encodable representation of this instance.
            
             @return a <code>Asn1Object</code> value
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.PrivateKeyUsagePeriod">
            <remarks>
            <pre>
            PrivateKeyUsagePeriod ::= SEQUENCE
            {
            notBefore       [0]     GeneralizedTime OPTIONAL,
            notAfter        [1]     GeneralizedTime OPTIONAL }
            </pre>
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.Qualified.BiometricData">
            The BiometricData object.
            <pre>
            BiometricData  ::=  SEQUENCE {
                  typeOfBiometricData  TypeOfBiometricData,
                  hashAlgorithm        AlgorithmIdentifier,
                  biometricDataHash    OCTET STRING,
                  sourceDataUri        IA5String OPTIONAL  }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.Qualified.Iso4217CurrencyCode">
            The Iso4217CurrencyCode object.
            <pre>
            Iso4217CurrencyCode  ::=  CHOICE {
                  alphabetic              PrintableString (SIZE 3), --Recommended
                  numeric              INTEGER (1..999) }
            -- Alphabetic or numeric currency code as defined in ISO 4217
            -- It is recommended that the Alphabetic form is used
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.Qualified.MonetaryValue">
            The MonetaryValue object.
            <pre>
            MonetaryValue  ::=  SEQUENCE {
                  currency              Iso4217CurrencyCode,
                  amount               INTEGER,
                  exponent             INTEGER }
            -- value = amount * 10^exponent
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.Qualified.QCStatement">
            The QCStatement object.
            <pre>
            QCStatement ::= SEQUENCE {
              statementId        OBJECT IDENTIFIER,
              statementInfo      ANY DEFINED BY statementId OPTIONAL}
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.Qualified.SemanticsInformation">
             The SemanticsInformation object.
             <pre>
                   SemanticsInformation ::= SEQUENCE {
                     semanticsIdentifier        OBJECT IDENTIFIER   OPTIONAL,
                     nameRegistrationAuthorities NameRegistrationAuthorities
                                                                     OPTIONAL }
                     (WITH COMPONENTS {..., semanticsIdentifier PRESENT}|
                      WITH COMPONENTS {..., nameRegistrationAuthorities PRESENT})
            
                 NameRegistrationAuthorities ::=  SEQUENCE SIZE (1..MAX) OF
                     GeneralName
             </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.Qualified.TypeOfBiometricData">
             The TypeOfBiometricData object.
             <pre>
             TypeOfBiometricData ::= CHOICE {
               predefinedBiometricType   PredefinedBiometricType,
               biometricDataOid          OBJECT IDENTIFIER }
            
             PredefinedBiometricType ::= INTEGER {
               picture(0),handwritten-signature(1)}
               (picture|handwritten-signature)
             </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.ReasonFlags">
            The ReasonFlags object.
            <pre>
            ReasonFlags ::= BIT STRING {
               unused(0),
               keyCompromise(1),
               cACompromise(2),
               affiliationChanged(3),
               superseded(4),
               cessationOfOperation(5),
               certficateHold(6)
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.ReasonFlags.#ctor(System.Int32)">
            @param reasons - the bitwise OR of the Key Reason flags giving the
            allowed uses for the key.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.RoleSyntax">
             Implementation of the RoleSyntax object as specified by the RFC3281.
            
             <pre>
             RoleSyntax ::= SEQUENCE {
                             roleAuthority  [0] GeneralNames OPTIONAL,
                             roleName       [1] GeneralName
                       }
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.RoleSyntax.GetInstance(System.Object)">
            RoleSyntax factory method.
            @param obj the object used to construct an instance of <code>
            RoleSyntax</code>. It must be an instance of <code>RoleSyntax
            </code> or <code>Asn1Sequence</code>.
            @return the instance of <code>RoleSyntax</code> built from the
            supplied object.
            @throws java.lang.ArgumentException if the object passed
            to the factory is not an instance of <code>RoleSyntax</code> or
            <code>Asn1Sequence</code>.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.RoleSyntax.#ctor(Org.BouncyCastle.Asn1.X509.GeneralNames,Org.BouncyCastle.Asn1.X509.GeneralName)">
            Constructor.
            @param roleAuthority the role authority of this RoleSyntax.
            @param roleName    the role name of this RoleSyntax.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.RoleSyntax.#ctor(Org.BouncyCastle.Asn1.X509.GeneralName)">
            Constructor. Invoking this constructor is the same as invoking
            <code>new RoleSyntax(null, roleName)</code>.
            @param roleName    the role name of this RoleSyntax.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.RoleSyntax.#ctor(System.String)">
            Utility constructor. Takes a <code>string</code> argument representing
            the role name, builds a <code>GeneralName</code> to hold the role name
            and calls the constructor that takes a <code>GeneralName</code>.
            @param roleName
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.RoleSyntax.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
            Constructor that builds an instance of <code>RoleSyntax</code> by
            extracting the encoded elements from the <code>Asn1Sequence</code>
            object supplied.
            @param seq    an instance of <code>Asn1Sequence</code> that holds
            the encoded elements used to build this <code>RoleSyntax</code>.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.RoleSyntax.RoleAuthority">
            Gets the role authority of this RoleSyntax.
            @return    an instance of <code>GeneralNames</code> holding the
            role authority of this RoleSyntax.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.RoleSyntax.RoleName">
            Gets the role name of this RoleSyntax.
            @return    an instance of <code>GeneralName</code> holding the
            role name of this RoleSyntax.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.RoleSyntax.GetRoleNameAsString">
            Gets the role name as a <code>java.lang.string</code> object.
            @return    the role name of this RoleSyntax represented as a
            <code>string</code> object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.RoleSyntax.GetRoleAuthorityAsString">
            Gets the role authority as a <code>string[]</code> object.
            @return the role authority of this RoleSyntax represented as a
            <code>string[]</code> array.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.RoleSyntax.ToAsn1Object">
             Implementation of the method <code>ToAsn1Object</code> as
             required by the superclass <code>ASN1Encodable</code>.
            
             <pre>
             RoleSyntax ::= SEQUENCE {
                             roleAuthority  [0] GeneralNames OPTIONAL,
                             roleName       [1] GeneralName
                       }
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.RsaPublicKeyStructure.ToAsn1Object">
            This outputs the key in Pkcs1v2 format.
            <pre>
                 RSAPublicKey ::= Sequence {
                                     modulus Integer, -- n
                                     publicExponent Integer, -- e
                                 }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.SigI.NameOrPseudonym">
            Structure for a name or pseudonym.
            
            <pre>
                  NameOrPseudonym ::= CHOICE {
                	   surAndGivenName SEQUENCE {
                	     surName DirectoryString,
                	     givenName SEQUENCE OF DirectoryString 
                    },
                	   pseudonym DirectoryString 
                  }
            </pre>
            
            @see org.bouncycastle.asn1.x509.sigi.PersonalData
            
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SigI.NameOrPseudonym.#ctor(Org.BouncyCastle.Asn1.X500.DirectoryString)">
            Constructor from DERString.
            <p/>
            The sequence is of type NameOrPseudonym:
            <p/>
            <pre>
                  NameOrPseudonym ::= CHOICE {
                	   surAndGivenName SEQUENCE {
                	     surName DirectoryString,
                	     givenName SEQUENCE OF DirectoryString
                    },
                	   pseudonym DirectoryString
                  }
            </pre>
            @param pseudonym pseudonym value to use.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SigI.NameOrPseudonym.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from Asn1Sequence.
             <p/>
             The sequence is of type NameOrPseudonym:
             <p/>
             <pre>
                   NameOrPseudonym ::= CHOICE {
                 	   surAndGivenName SEQUENCE {
                 	     surName DirectoryString,
                 	     givenName SEQUENCE OF DirectoryString
                     },
                 	   pseudonym DirectoryString
                   }
             </pre>
            
             @param seq The ASN.1 sequence.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SigI.NameOrPseudonym.#ctor(System.String)">
             Constructor from a given details.
            
             @param pseudonym The pseudonym.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SigI.NameOrPseudonym.#ctor(Org.BouncyCastle.Asn1.X500.DirectoryString,Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from a given details.
            
             @param surname   The surname.
             @param givenName A sequence of directory strings making up the givenName
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SigI.NameOrPseudonym.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
                   NameOrPseudonym ::= CHOICE {
                 	   surAndGivenName SEQUENCE {
                 	     surName DirectoryString,
                 	     givenName SEQUENCE OF DirectoryString
                     },
                 	   pseudonym DirectoryString
                   }
             </pre>
            
             @return an Asn1Object
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.SigI.PersonalData">
             Contains personal data for the otherName field in the subjectAltNames
             extension.
             <p/>
             <pre>
                 PersonalData ::= SEQUENCE {
                   nameOrPseudonym NameOrPseudonym,
                   nameDistinguisher [0] INTEGER OPTIONAL,
                   dateOfBirth [1] GeneralizedTime OPTIONAL,
                   placeOfBirth [2] DirectoryString OPTIONAL,
                   gender [3] PrintableString OPTIONAL,
                   postalAddress [4] DirectoryString OPTIONAL
                   }
             </pre>
            
             @see org.bouncycastle.asn1.x509.sigi.NameOrPseudonym
             @see org.bouncycastle.asn1.x509.sigi.SigIObjectIdentifiers
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SigI.PersonalData.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from Asn1Sequence.
             <p/>
             The sequence is of type NameOrPseudonym:
             <p/>
             <pre>
                 PersonalData ::= SEQUENCE {
                   nameOrPseudonym NameOrPseudonym,
                   nameDistinguisher [0] INTEGER OPTIONAL,
                   dateOfBirth [1] GeneralizedTime OPTIONAL,
                   placeOfBirth [2] DirectoryString OPTIONAL,
                   gender [3] PrintableString OPTIONAL,
                   postalAddress [4] DirectoryString OPTIONAL
                   }
             </pre>
            
             @param seq The ASN.1 sequence.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SigI.PersonalData.#ctor(Org.BouncyCastle.Asn1.X509.SigI.NameOrPseudonym,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Asn1.DerGeneralizedTime,Org.BouncyCastle.Asn1.X500.DirectoryString,System.String,Org.BouncyCastle.Asn1.X500.DirectoryString)">
             Constructor from a given details.
            
             @param nameOrPseudonym  Name or pseudonym.
             @param nameDistinguisher Name distinguisher.
             @param dateOfBirth      Date of birth.
             @param placeOfBirth     Place of birth.
             @param gender           Gender.
             @param postalAddress    Postal Address.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SigI.PersonalData.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
                 PersonalData ::= SEQUENCE {
                   nameOrPseudonym NameOrPseudonym,
                   nameDistinguisher [0] INTEGER OPTIONAL,
                   dateOfBirth [1] GeneralizedTime OPTIONAL,
                   placeOfBirth [2] DirectoryString OPTIONAL,
                   gender [3] PrintableString OPTIONAL,
                   postalAddress [4] DirectoryString OPTIONAL
                   }
             </pre>
            
             @return an Asn1Object
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.SigI.SigIObjectIdentifiers">
            Object Identifiers of SigI specifciation (German Signature Law
            Interoperability specification).
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.SigI.SigIObjectIdentifiers.IdSigIKP">
            Key purpose IDs for German SigI (Signature Interoperability
            Specification)
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.SigI.SigIObjectIdentifiers.IdSigICP">
            Certificate policy IDs for German SigI (Signature Interoperability
            Specification)
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.SigI.SigIObjectIdentifiers.IdSigION">
            Other Name IDs for German SigI (Signature Interoperability Specification)
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.SigI.SigIObjectIdentifiers.IdSigIKPDirectoryService">
            To be used for for the generation of directory service certificates.
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.SigI.SigIObjectIdentifiers.IdSigIONPersonalData">
            ID for PersonalData
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.SigI.SigIObjectIdentifiers.IdSigICPSigConform">
            Certificate is conform to german signature law.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.SubjectDirectoryAttributes">
             This extension may contain further X.500 attributes of the subject. See also
             RFC 3039.
            
             <pre>
                 SubjectDirectoryAttributes ::= Attributes
                 Attributes ::= SEQUENCE SIZE (1..MAX) OF Attribute
                 Attribute ::= SEQUENCE
                 {
                   type AttributeType
                   values SET OF AttributeValue
                 }
            
                 AttributeType ::= OBJECT IDENTIFIER
                 AttributeValue ::= ANY DEFINED BY AttributeType
             </pre>
            
             @see org.bouncycastle.asn1.x509.X500Name for AttributeType ObjectIdentifiers.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SubjectDirectoryAttributes.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from Asn1Sequence.
            
             The sequence is of type SubjectDirectoryAttributes:
            
             <pre>
                  SubjectDirectoryAttributes ::= Attributes
                  Attributes ::= SEQUENCE SIZE (1..MAX) OF Attribute
                  Attribute ::= SEQUENCE
                  {
                    type AttributeType
                    values SET OF AttributeValue
                  }
            
                  AttributeType ::= OBJECT IDENTIFIER
                  AttributeValue ::= ANY DEFINED BY AttributeType
             </pre>
            
             @param seq
                        The ASN.1 sequence.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SubjectDirectoryAttributes.#ctor(System.Collections.IList)">
             Constructor from an ArrayList of attributes.
            
             The ArrayList consists of attributes of type {@link Attribute Attribute}
            
             @param attributes The attributes.
            
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SubjectDirectoryAttributes.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
            
             Returns:
            
             <pre>
                  SubjectDirectoryAttributes ::= Attributes
                  Attributes ::= SEQUENCE SIZE (1..MAX) OF Attribute
                  Attribute ::= SEQUENCE
                  {
                    type AttributeType
                    values SET OF AttributeValue
                  }
            
                  AttributeType ::= OBJECT IDENTIFIER
                  AttributeValue ::= ANY DEFINED BY AttributeType
             </pre>
            
             @return a DERObject
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.SubjectDirectoryAttributes.Attributes">
            @return Returns the attributes.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.SubjectKeyIdentifier">
            The SubjectKeyIdentifier object.
            <pre>
            SubjectKeyIdentifier::= OCTET STRING
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SubjectKeyIdentifier.#ctor(Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo)">
             Calculates the keyIdentifier using a SHA1 hash over the BIT STRING
             from SubjectPublicKeyInfo as defined in RFC3280.
            
             @param spki the subject public key info.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SubjectKeyIdentifier.CreateSha1KeyIdentifier(Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo)">
            Return a RFC 3280 type 1 key identifier. As in:
            <pre>
            (1) The keyIdentifier is composed of the 160-bit SHA-1 hash of the
            value of the BIT STRING subjectPublicKey (excluding the tag,
            length, and number of unused bits).
            </pre>
            @param keyInfo the key info object containing the subjectPublicKey field.
            @return the key identifier.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SubjectKeyIdentifier.CreateTruncatedSha1KeyIdentifier(Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo)">
            Return a RFC 3280 type 2 key identifier. As in:
            <pre>
            (2) The keyIdentifier is composed of a four bit type field with
            the value 0100 followed by the least significant 60 bits of the
            SHA-1 hash of the value of the BIT STRING subjectPublicKey.
            </pre>
            @param keyInfo the key info object containing the subjectPublicKey field.
            @return the key identifier.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo">
            The object that contains the public key stored in a certficate.
            <p>
            The GetEncoded() method in the public keys in the JCE produces a DER
            encoded one of these.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo.GetPublicKey">
             for when the public key is an encoded object - if the bitstring
             can't be decoded this routine raises an IOException.
            
             @exception IOException - if the bit string doesn't represent a Der
             encoded object.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo.PublicKeyData">
            for when the public key is raw bits...
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            SubjectPublicKeyInfo ::= Sequence {
                                     algorithm AlgorithmIdentifier,
                                     publicKey BIT STRING }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.Target">
            Target structure used in target information extension for attribute
            certificates from RFC 3281.
            
            <pre>
                Target  ::= CHOICE {
                  targetName          [0] GeneralName,
                  targetGroup         [1] GeneralName,
                  targetCert          [2] TargetCert
                }
            </pre>
            
            <p>
            The targetCert field is currently not supported and must not be used
            according to RFC 3281.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Target.GetInstance(System.Object)">
            Creates an instance of a Target from the given object.
            <p>
            <code>obj</code> can be a Target or a {@link Asn1TaggedObject}</p>
            
            @param obj The object.
            @return A Target instance.
            @throws ArgumentException if the given object cannot be
                        interpreted as Target.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Target.#ctor(Org.BouncyCastle.Asn1.Asn1TaggedObject)">
            Constructor from Asn1TaggedObject.
            
            @param tagObj The tagged object.
            @throws ArgumentException if the encoding is wrong.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Target.#ctor(Org.BouncyCastle.Asn1.X509.Target.Choice,Org.BouncyCastle.Asn1.X509.GeneralName)">
             Constructor from given details.
             <p>
             Exactly one of the parameters must be not <code>null</code>.</p>
            
             @param type the choice type to apply to the name.
             @param name the general name.
             @throws ArgumentException if type is invalid.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.Target.TargetGroup">
            @return Returns the targetGroup.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.Target.TargetName">
            @return Returns the targetName.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Target.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            
            Returns:
            
            <pre>
                Target  ::= CHOICE {
                  targetName          [0] GeneralName,
                  targetGroup         [1] GeneralName,
                  targetCert          [2] TargetCert
                }
            </pre>
            
            @return an Asn1Object
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.TargetInformation">
            Target information extension for attributes certificates according to RFC
            3281.
            
            <pre>
                      SEQUENCE OF Targets
            </pre>
            
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.TargetInformation.GetInstance(System.Object)">
            Creates an instance of a TargetInformation from the given object.
            <p>
            <code>obj</code> can be a TargetInformation or a {@link Asn1Sequence}</p>
            
            @param obj The object.
            @return A TargetInformation instance.
            @throws ArgumentException if the given object cannot be interpreted as TargetInformation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.TargetInformation.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
            Constructor from a Asn1Sequence.
            
            @param seq The Asn1Sequence.
            @throws ArgumentException if the sequence does not contain
                        correctly encoded Targets elements.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.TargetInformation.GetTargetsObjects">
            Returns the targets in this target information extension.
            <p>
            The ArrayList is cloned before it is returned.</p>
            
            @return Returns the targets.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.TargetInformation.#ctor(Org.BouncyCastle.Asn1.X509.Targets)">
            Constructs a target information from a single targets element. 
            According to RFC 3281 only one targets element must be produced.
            
            @param targets A Targets instance.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.TargetInformation.#ctor(Org.BouncyCastle.Asn1.X509.Target[])">
             According to RFC 3281 only one targets element must be produced. If
             multiple targets are given they must be merged in
             into one targets element.
            
             @param targets An array with {@link Targets}.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.TargetInformation.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            
            Returns:
            
            <pre>
                     SEQUENCE OF Targets
            </pre>
            
            <p>
            According to RFC 3281 only one targets element must be produced. If
            multiple targets are given in the constructor they are merged into one
            targets element. If this was produced from a
            {@link Org.BouncyCastle.Asn1.Asn1Sequence} the encoding is kept.</p>
            
            @return an Asn1Object
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.Targets">
            Targets structure used in target information extension for attribute
            certificates from RFC 3281.
            
            <pre>
                       Targets ::= SEQUENCE OF Target
                      
                       Target  ::= CHOICE {
                         targetName          [0] GeneralName,
                         targetGroup         [1] GeneralName,
                         targetCert          [2] TargetCert
                       }
                      
                       TargetCert  ::= SEQUENCE {
                         targetCertificate    IssuerSerial,
                         targetName           GeneralName OPTIONAL,
                         certDigestInfo       ObjectDigestInfo OPTIONAL
                       }
            </pre>
            
            @see org.bouncycastle.asn1.x509.Target
            @see org.bouncycastle.asn1.x509.TargetInformation
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Targets.GetInstance(System.Object)">
            Creates an instance of a Targets from the given object.
            <p>
            <code>obj</code> can be a Targets or a {@link Asn1Sequence}</p>
            
            @param obj The object.
            @return A Targets instance.
            @throws ArgumentException if the given object cannot be interpreted as Target.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Targets.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
            Constructor from Asn1Sequence.
            
            @param targets The ASN.1 SEQUENCE.
            @throws ArgumentException if the contents of the sequence are
                        invalid.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Targets.#ctor(Org.BouncyCastle.Asn1.X509.Target[])">
            Constructor from given targets.
            <p>
            The ArrayList is copied.</p>
            
            @param targets An <code>ArrayList</code> of {@link Target}s.
            @see Target
            @throws ArgumentException if the ArrayList contains not only Targets.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Targets.GetTargets">
            Returns the targets in an <code>ArrayList</code>.
            <p>
            The ArrayList is cloned before it is returned.</p>
            
            @return Returns the targets.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Targets.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            
            Returns:
            
            <pre>
                       Targets ::= SEQUENCE OF Target
            </pre>
            
            @return an Asn1Object
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.TbsCertificateStructure">
            The TbsCertificate object.
            <pre>
            TbsCertificate ::= Sequence {
                 version          [ 0 ]  Version DEFAULT v1(0),
                 serialNumber            CertificateSerialNumber,
                 signature               AlgorithmIdentifier,
                 issuer                  Name,
                 validity                Validity,
                 subject                 Name,
                 subjectPublicKeyInfo    SubjectPublicKeyInfo,
                 issuerUniqueID    [ 1 ] IMPLICIT UniqueIdentifier OPTIONAL,
                 subjectUniqueID   [ 2 ] IMPLICIT UniqueIdentifier OPTIONAL,
                 extensions        [ 3 ] Extensions OPTIONAL
                 }
            </pre>
            <p>
            Note: issuerUniqueID and subjectUniqueID are both deprecated by the IETF. This class
            will parse them, but you really shouldn't be creating new ones.</p>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.TbsCertificateList">
            PKIX RFC-2459 - TbsCertList object.
            <pre>
            TbsCertList  ::=  Sequence  {
                 version                 Version OPTIONAL,
                                              -- if present, shall be v2
                 signature               AlgorithmIdentifier,
                 issuer                  Name,
                 thisUpdate              Time,
                 nextUpdate              Time OPTIONAL,
                 revokedCertificates     Sequence OF Sequence  {
                      userCertificate         CertificateSerialNumber,
                      revocationDate          Time,
                      crlEntryExtensions      Extensions OPTIONAL
                                                    -- if present, shall be v2
                                           }  OPTIONAL,
                 crlExtensions           [0]  EXPLICIT Extensions OPTIONAL
                                                    -- if present, shall be v2
                                           }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Time.#ctor(System.DateTime)">
            creates a time object from a given date - if the date is between 1950
            and 2049 a UTCTime object is Generated, otherwise a GeneralizedTime
            is used.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Time.ToDateTime">
            <summary>
            Return our time as DateTime.
            </summary>
            <returns>A date time.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Time.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            Time ::= CHOICE {
                        utcTime        UTCTime,
                        generalTime    GeneralizedTime }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.UserNotice">
             <code>UserNotice</code> class, used in
             <code>CertificatePolicies</code> X509 extensions (in policy
             qualifiers).
             <pre>
             UserNotice ::= Sequence {
                  noticeRef        NoticeReference OPTIONAL,
                  explicitText     DisplayText OPTIONAL}
            
             </pre>
            
             @see PolicyQualifierId
             @see PolicyInformation
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.UserNotice.#ctor(Org.BouncyCastle.Asn1.X509.NoticeReference,Org.BouncyCastle.Asn1.X509.DisplayText)">
             Creates a new <code>UserNotice</code> instance.
            
             @param noticeRef a <code>NoticeReference</code> value
             @param explicitText a <code>DisplayText</code> value
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.UserNotice.#ctor(Org.BouncyCastle.Asn1.X509.NoticeReference,System.String)">
             Creates a new <code>UserNotice</code> instance.
            
             @param noticeRef a <code>NoticeReference</code> value
             @param str the explicitText field as a string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.UserNotice.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Creates a new <code>UserNotice</code> instance.
             <p>Useful from reconstructing a <code>UserNotice</code> instance
             from its encodable/encoded form.
            
             @param as an <code>ASN1Sequence</code> value obtained from either
             calling @{link toASN1Object()} for a <code>UserNotice</code>
             instance or from parsing it from a DER-encoded stream.</p>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.V1TbsCertificateGenerator">
             Generator for Version 1 TbsCertificateStructures.
             <pre>
             TbsCertificate ::= Sequence {
                  version          [ 0 ]  Version DEFAULT v1(0),
                  serialNumber            CertificateSerialNumber,
                  signature               AlgorithmIdentifier,
                  issuer                  Name,
                  validity                Validity,
                  subject                 Name,
                  subjectPublicKeyInfo    SubjectPublicKeyInfo,
                  }
             </pre>
            
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.V2AttributeCertificateInfoGenerator">
             Generator for Version 2 AttributeCertificateInfo
             <pre>
             AttributeCertificateInfo ::= Sequence {
                   version              AttCertVersion -- version is v2,
                   holder               Holder,
                   issuer               AttCertIssuer,
                   signature            AlgorithmIdentifier,
                   serialNumber         CertificateSerialNumber,
                   attrCertValidityPeriod   AttCertValidityPeriod,
                   attributes           Sequence OF Attr,
                   issuerUniqueID       UniqueIdentifier OPTIONAL,
                   extensions           Extensions OPTIONAL
             }
             </pre>
            
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.V2AttributeCertificateInfoGenerator.AddAttribute(Org.BouncyCastle.Asn1.X509.AttributeX509)">
            @param attribute
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.V2Form.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             V2Form ::= Sequence {
                  issuerName            GeneralNames  OPTIONAL,
                  baseCertificateID     [0] IssuerSerial  OPTIONAL,
                  objectDigestInfo      [1] ObjectDigestInfo  OPTIONAL
                    -- issuerName MUST be present in this profile
                    -- baseCertificateID and objectDigestInfo MUST NOT
                    -- be present in this profile
             }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.V2TbsCertListGenerator">
             Generator for Version 2 TbsCertList structures.
             <pre>
              TbsCertList  ::=  Sequence  {
                   version                 Version OPTIONAL,
                                                -- if present, shall be v2
                   signature               AlgorithmIdentifier,
                   issuer                  Name,
                   thisUpdate              Time,
                   nextUpdate              Time OPTIONAL,
                   revokedCertificates     Sequence OF Sequence  {
                        userCertificate         CertificateSerialNumber,
                        revocationDate          Time,
                        crlEntryExtensions      Extensions OPTIONAL
                                                      -- if present, shall be v2
                                             }  OPTIONAL,
                   crlExtensions           [0]  EXPLICIT Extensions OPTIONAL
                                                      -- if present, shall be v2
                                             }
             </pre>
            
             <b>Note: This class may be subject to change</b>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.V3TbsCertificateGenerator">
             Generator for Version 3 TbsCertificateStructures.
             <pre>
             TbsCertificate ::= Sequence {
                  version          [ 0 ]  Version DEFAULT v1(0),
                  serialNumber            CertificateSerialNumber,
                  signature               AlgorithmIdentifier,
                  issuer                  Name,
                  validity                Validity,
                  subject                 Name,
                  subjectPublicKeyInfo    SubjectPublicKeyInfo,
                  issuerUniqueID    [ 1 ] IMPLICIT UniqueIdentifier OPTIONAL,
                  subjectUniqueID   [ 2 ] IMPLICIT UniqueIdentifier OPTIONAL,
                  extensions        [ 3 ] Extensions OPTIONAL
                  }
             </pre>
            
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.X509CertificateStructure">
            an X509Certificate structure.
            <pre>
             Certificate ::= Sequence {
                 tbsCertificate          TbsCertificate,
                 signatureAlgorithm      AlgorithmIdentifier,
                 signature               BIT STRING
             }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.X509Extension">
            an object for the elements in the X.509 V3 extension block.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Extension.ConvertValueToObject(Org.BouncyCastle.Asn1.X509.X509Extension)">
            <sumary>Convert the value of the passed in extension to an object.</sumary>
            <param name="ext">The extension to parse.</param>
            <returns>The object the value string contains.</returns>
            <exception cref="T:System.ArgumentException">If conversion is not possible.</exception>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.SubjectDirectoryAttributes">
            Subject Directory Attributes
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.SubjectKeyIdentifier">
            Subject Key Identifier
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.KeyUsage">
            Key Usage
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.PrivateKeyUsagePeriod">
            Private Key Usage Period
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.SubjectAlternativeName">
            Subject Alternative Name
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.IssuerAlternativeName">
            Issuer Alternative Name
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.BasicConstraints">
            Basic Constraints
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.CrlNumber">
            CRL Number
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.ReasonCode">
            Reason code
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.InstructionCode">
            Hold Instruction Code
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.InvalidityDate">
            Invalidity Date
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.DeltaCrlIndicator">
            Delta CRL indicator
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.IssuingDistributionPoint">
            Issuing Distribution Point
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.CertificateIssuer">
            Certificate Issuer
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.NameConstraints">
            Name Constraints
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.CrlDistributionPoints">
            CRL Distribution Points
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.CertificatePolicies">
            Certificate Policies
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.PolicyMappings">
            Policy Mappings
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.AuthorityKeyIdentifier">
            Authority Key Identifier
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.PolicyConstraints">
            Policy Constraints
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.ExtendedKeyUsage">
            Extended Key Usage
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.FreshestCrl">
            Freshest CRL
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.InhibitAnyPolicy">
            Inhibit Any Policy
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.AuthorityInfoAccess">
            Authority Info Access
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.SubjectInfoAccess">
            Subject Info Access
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.LogoType">
            Logo Type
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.BiometricInfo">
            BiometricInfo
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.QCStatements">
            QCStatements
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.AuditIdentity">
            Audit identity extension in attribute certificates.
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.NoRevAvail">
            NoRevAvail extension in attribute certificates.
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.TargetInformation">
            TargetInformation extension in attribute certificates.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Extensions.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from Asn1Sequence.
            
             the extensions are a list of constructed sequences, either with (Oid, OctetString) or (Oid, Boolean, OctetString)
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Extensions.#ctor(System.Collections.IDictionary)">
            constructor from a table of extensions.
            <p>
            it's is assumed the table contains Oid/string pairs.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Extensions.#ctor(System.Collections.IList,System.Collections.IDictionary)">
            Constructor from a table of extensions with ordering.
            <p>
            It's is assumed the table contains Oid/string pairs.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Extensions.#ctor(System.Collections.IList,System.Collections.IList)">
             Constructor from two vectors
            
             @param objectIDs an ArrayList of the object identifiers.
             @param values an ArrayList of the extension values.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.X509Extensions.ExtensionOids">
            return an Enumeration of the extension field's object ids.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Extensions.GetExtension(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
             return the extension represented by the object identifier
             passed in.
            
             @return the extension if it's present, null otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Extensions.ToAsn1Object">
             <pre>
                 Extensions        ::=   SEQUENCE SIZE (1..MAX) OF Extension
            
                 Extension         ::=   SEQUENCE {
                    extnId            EXTENSION.&amp;id ({ExtensionSet}),
                    critical          BOOLEAN DEFAULT FALSE,
                    extnValue         OCTET STRING }
             </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.X509ExtensionsGenerator">
            <remarks>Generator for X.509 extensions</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509ExtensionsGenerator.Reset">
            <summary>Reset the generator</summary>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509ExtensionsGenerator.AddExtension(Org.BouncyCastle.Asn1.DerObjectIdentifier,System.Boolean,Org.BouncyCastle.Asn1.Asn1Encodable)">
            <summary>
            Add an extension with the given oid and the passed in value to be included
            in the OCTET STRING associated with the extension.
            </summary>
            <param name="oid">OID for the extension.</param>
            <param name="critical">True if critical, false otherwise.</param>
            <param name="extValue">The ASN.1 object to be included in the extension.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509ExtensionsGenerator.AddExtension(Org.BouncyCastle.Asn1.DerObjectIdentifier,System.Boolean,System.Byte[])">
            <summary>
            Add an extension with the given oid and the passed in byte array to be wrapped
            in the OCTET STRING associated with the extension.
            </summary>
            <param name="oid">OID for the extension.</param>
            <param name="critical">True if critical, false otherwise.</param>
            <param name="extValue">The byte array to be wrapped.</param>
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.X509ExtensionsGenerator.IsEmpty">
            <summary>Return true if there are no extension present in this generator.</summary>
            <returns>True if empty, false otherwise</returns>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509ExtensionsGenerator.Generate">
            <summary>Generate an X509Extensions object based on the current state of the generator.</summary>
            <returns>An <c>X509Extensions</c> object</returns>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X9.ECNamedCurveTable">
            A general class that reads all X9.62 style EC curve tables.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.ECNamedCurveTable.GetByName(System.String)">
             return a X9ECParameters object representing the passed in named
             curve. The routine returns null if the curve is not present.
            
             @param name the name of the curve requested
             @return an X9ECParameters object or null if the curve is not available.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.ECNamedCurveTable.GetOid(System.String)">
             return the object identifier signified by the passed in name. Null
             if there is no object identifier associated with name.
            
             @return the object identifier associated with name, if present.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.ECNamedCurveTable.GetByOid(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
             return a X9ECParameters object representing the passed in named
             curve.
            
             @param oid the object id of the curve requested
             @return an X9ECParameters object or null if the curve is not available.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X9.ECNamedCurveTable.Names">
             return an enumeration of the names of the available curves.
            
             @return an enumeration of the names of the available curves.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X9.KeySpecificInfo">
            ASN.1 def for Diffie-Hellman key exchange KeySpecificInfo structure. See
            RFC 2631, or X9.42, for further details.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.KeySpecificInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             KeySpecificInfo ::= Sequence {
                 algorithm OBJECT IDENTIFIER,
                 counter OCTET STRING SIZE (4..4)
             }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X9.OtherInfo">
            ANS.1 def for Diffie-Hellman key exchange OtherInfo structure. See
            RFC 2631, or X9.42, for further details.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.OtherInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             OtherInfo ::= Sequence {
                 keyInfo KeySpecificInfo,
                 partyAInfo [0] OCTET STRING OPTIONAL,
                 suppPubInfo [2] OCTET STRING
             }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X9.X962NamedCurves">
            table of the current named curves defined in X.962 EC-DSA.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X962NamedCurves.GetByOid(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
             return the X9ECParameters object for the named curve represented by
             the passed in object identifier. Null if the curve isn't present.
            
             @param oid an object identifier representing a named curve, if present.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X962NamedCurves.GetOid(System.String)">
             return the object identifier signified by the passed in name. Null
             if there is no object identifier associated with name.
            
             @return the object identifier associated with name, if present.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X962NamedCurves.GetName(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            return the named curve name represented by the given object identifier.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X9.X962NamedCurves.Names">
            returns an enumeration containing the name strings for curves
            contained in this structure.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X962Parameters.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            Parameters ::= CHOICE {
               ecParameters ECParameters,
               namedCurve   CURVES.&amp;id({CurveNames}),
               implicitlyCA Null
            }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X9.X9Curve">
            ASN.1 def for Elliptic-Curve Curve structure. See
            X9.62, for further details.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X9Curve.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             Curve ::= Sequence {
                 a               FieldElement,
                 b               FieldElement,
                 seed            BIT STRING      OPTIONAL
             }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X9.X9ECParameters">
            ASN.1 def for Elliptic-Curve ECParameters structure. See
            X9.62, for further details.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X9.X9ECParameters.CurveEntry">
             Return the ASN.1 entry representing the Curve.
            
             @return the X9Curve for the curve in these parameters.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X9.X9ECParameters.FieldIDEntry">
             Return the ASN.1 entry representing the FieldID.
            
             @return the X9FieldID for the FieldID in these parameters.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X9.X9ECParameters.BaseEntry">
             Return the ASN.1 entry representing the base point G.
            
             @return the X9ECPoint for the base point in these parameters.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X9ECParameters.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             ECParameters ::= Sequence {
                 version         Integer { ecpVer1(1) } (ecpVer1),
                 fieldID         FieldID {{FieldTypes}},
                 curve           X9Curve,
                 base            X9ECPoint,
                 order           Integer,
                 cofactor        Integer OPTIONAL
             }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X9.X9ECPoint">
            class for describing an ECPoint as a Der object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X9ECPoint.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             ECPoint ::= OCTET STRING
            </pre>
            <p>
            Octet string produced using ECPoint.GetEncoded().</p>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X9.X9FieldElement">
            Class for processing an ECFieldElement as a DER object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X9FieldElement.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             FieldElement ::= OCTET STRING
            </pre>
            <p>
            <ol>
            <li> if <i>q</i> is an odd prime then the field element is
            processed as an Integer and converted to an octet string
            according to x 9.62 4.3.1.</li>
            <li> if <i>q</i> is 2<sup>m</sup> then the bit string
            contained in the field element is converted into an octet
            string with the same ordering padded at the front if necessary.
            </li>
            </ol>
            </p>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X9.X9FieldID">
            ASN.1 def for Elliptic-Curve Field ID structure. See
            X9.62, for further details.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X9FieldID.#ctor(Org.BouncyCastle.Math.BigInteger)">
            Constructor for elliptic curves over prime fields
            <code>F<sub>2</sub></code>.
            @param primeP The prime <code>p</code> defining the prime field.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X9FieldID.#ctor(System.Int32,System.Int32)">
            Constructor for elliptic curves over binary fields
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k1 The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X9FieldID.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            Constructor for elliptic curves over binary fields
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k1 The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k2 The integer <code>k2</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k3 The integer <code>k3</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>..
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X9FieldID.ToAsn1Object">
            Produce a Der encoding of the following structure.
            <pre>
             FieldID ::= Sequence {
                 fieldType       FIELD-ID.&amp;id({IOSet}),
                 parameters      FIELD-ID.&amp;Type({IOSet}{&#64;fieldType})
             }
            </pre>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X9.X9ObjectIdentifiers.IdDsaWithSha1">
            id-dsa-with-sha1 OBJECT IDENTIFIER ::=  { iso(1) member-body(2)
                  us(840) x9-57 (10040) x9cm(4) 3 }
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X9.X9ObjectIdentifiers.X9x63Scheme">
            X9.63
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X9.X9ObjectIdentifiers.ansi_x9_42">
            X9.42
        </member>
        <member name="T:Org.BouncyCastle.Crypto.AeadUsage">
            <summary>
            Enum to specify how the associated data will be introduced into the AEAD cipher
            during processing.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Algorithm">
            <summary>
            The basic algorithm marker.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Algorithm.Name">
            <summary>
            Return a readable version of the algorithm name.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Algorithm.Mode">
            <summary>
            Return any algorithm mode associated with this algorithm marker.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.AlgorithmMode">
            <summary>
            An enum representing all the modes available across the full algorithm set.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricDHKey">
            <summary>
            Base class for DH keys.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricDHKey.Algorithm">
            <summary>
            Return the algorithm this DSA key is for.
            </summary>
            <value>The key's algorithm.</value>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricDHKey.DomainParameters">
            <summary>
            Return the DH domain parameters associated with this key.
            </summary>
            <value>The DH domain parameters for this key.</value>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricDHKey.GetEncoded">
            <summary>
            Return an ASN.1 encoded representation of the implementing key.
            </summary>
            <returns>An encoded representation of the key.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricDHPrivateKey">
            <summary>
            Class for Digital Signature Algorithm (DSA) private keys.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricDHPrivateKey.#ctor(Org.BouncyCastle.Crypto.Algorithm,Org.BouncyCastle.Crypto.Asymmetric.DHDomainParameters,Org.BouncyCastle.Math.BigInteger)">
            <summary>
            Base constructor for a Diffie-Hellman private key.
            </summary>
            <param name="algorithm">The algorithm marker for this key.</param>
            <param name="parameters">The domain parameters for this key.</param>
            <param name="x">The private X value for this key.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricDHPrivateKey.#ctor(Org.BouncyCastle.Crypto.Algorithm,System.Byte[])">
            <summary>
            Constructor from an algorithm and an encoding of a PrivateKeyInfo object containing a DSA private key.
            </summary>
            <param name="algorithm">Algorithm marker to associate with the key.</param>
            <param name="enc">An encoding of a PrivateKeyInfo object.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricDHPrivateKey.#ctor(Org.BouncyCastle.Crypto.Algorithm,Org.BouncyCastle.Asn1.Pkcs.PrivateKeyInfo)">
            <summary>
            Constructor from an algorithm and a PrivateKeyInfo object containing a DSA private key.
            </summary>
            <param name="algorithm">Algorithm marker to associate with the key.</param>
            <param name="privateKeyInfo">A PrivateKeyInfo object.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricDHPrivateKey.GetEncoded">
            <summary>
            Return an ASN.1 encoded representation of the implementing key in a PrivateKeyInfo structure.
            </summary>
            <returns>An encoded representation of the key.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricDHPrivateKey.X">
            <summary>
            Return the private X value.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricDHPrivateKey.Equals(System.Object)">
            <summary>
            Compare this key to another object.
            </summary>
            <param name="o">The other object.</param>
            <returns>true if this equals o, false otherwise.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricDHPrivateKey.GetHashCode">
            <summary>
            Return the hashcode for this key.
            </summary>
            <returns>The key's hashcode.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricDHPublicKey">
            <summary>
            Class for Diffie-Hellman public keys.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricDHPublicKey.#ctor(Org.BouncyCastle.Crypto.Algorithm,System.Byte[])">
            <summary>
            Constructor from an algorithm and an encoding of a SubjectPublicKeyInfo object containing a Diffie-Hellman public key.
            </summary>
            <param name="algorithm">Algorithm marker to associate with the key.</param>
            <param name="enc">An encoding of a SubjectPublicKeyInfo object.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricDHPublicKey.#ctor(Org.BouncyCastle.Crypto.Algorithm,Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo)">
            <summary>
            Constructor from an algorithm and a SubjectPublicKeyInfo object containing a Diffie-Hellman public key.
            </summary>
            <param name="algorithm">Algorithm marker to associate with the key.</param>
            <param name="publicKeyInfo">A SubjectPublicKeyInfo object.</param>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricDHPublicKey.Y">
            <summary>
            Return the public value Y.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricDHPublicKey.GetEncoded">
            <summary>
            Return an ASN.1 encoded representation of the implementing key in a SubjectPublicKeyInfo structure.
            </summary>
            <returns>An encoded representation of the key.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricDsaKey">
            <summary>
            Base class for DSA keys.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricDsaKey.Algorithm">
            <summary>
            Return the algorithm this DSA key is for.
            </summary>
            <value>The key's algorithm.</value>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricDsaKey.DomainParameters">
            <summary>
            Return the DSA domain parameters associated with this key.
            </summary>
            <value>The DSA domain parameters for this key.</value>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricDsaKey.GetEncoded">
            <summary>
            Return an ASN.1 encoded representation of the implementing key.
            </summary>
            <returns>An encoded representation of the key.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricDsaPrivateKey">
            <summary>
            Class for Digital Signature Algorithm (DSA) private keys.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricDsaPrivateKey.#ctor(Org.BouncyCastle.Crypto.Algorithm,Org.BouncyCastle.Crypto.Asymmetric.DsaDomainParameters,Org.BouncyCastle.Math.BigInteger)">
            <summary>
            Base constructor for a DSA private key.
            </summary>
            <param name="algorithm">The algorithm marker for this key.</param>
            <param name="parameters">The domain parameters for this key.</param>
            <param name="x">The private X value for this key.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricDsaPrivateKey.#ctor(Org.BouncyCastle.Crypto.Algorithm,System.Byte[])">
            <summary>
            Constructor from an algorithm and an encoding of a PrivateKeyInfo object containing a DSA private key.
            </summary>
            <param name="algorithm">Algorithm marker to associate with the key.</param>
            <param name="enc">An encoding of a PrivateKeyInfo object.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricDsaPrivateKey.#ctor(Org.BouncyCastle.Crypto.Algorithm,Org.BouncyCastle.Asn1.Pkcs.PrivateKeyInfo)">
            <summary>
            Constructor from an algorithm and a PrivateKeyInfo object containing a DSA private key.
            </summary>
            <param name="algorithm">Algorithm marker to associate with the key.</param>
            <param name="privateKeyInfo">A PrivateKeyInfo object.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricDsaPrivateKey.GetEncoded">
            <summary>
            Return an ASN.1 encoded representation of the implementing key in a PrivateKeyInfo structure.
            </summary>
            <returns>An encoded representation of the key.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricDsaPrivateKey.X">
            <summary>
            Return the private X value.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricDsaPrivateKey.Equals(System.Object)">
            <summary>
            Compare this key to another object.
            </summary>
            <param name="o">The other object.</param>
            <returns>true if this equals o, false otherwise.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricDsaPrivateKey.GetHashCode">
            <summary>
            Return the hashcode for this key.
            </summary>
            <returns>The key's hashcode.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricDsaPublicKey">
            <summary>
            Class for Digital Signature Algorithm (DSA) public keys.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricDsaPublicKey.#ctor(Org.BouncyCastle.Crypto.Algorithm,System.Byte[])">
            <summary>
            Constructor from an algorithm and an encoding of a SubjectPublicKeyInfo object containing a DSA public key.
            </summary>
            <param name="algorithm">Algorithm marker to associate with the key.</param>
            <param name="enc">An encoding of a SubjectPublicKeyInfo object.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricDsaPublicKey.#ctor(Org.BouncyCastle.Crypto.Algorithm,Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo)">
            <summary>
            Constructor from an algorithm and a SubjectPublicKeyInfo object containing a DSA public key.
            </summary>
            <param name="algorithm">Algorithm marker to associate with the key.</param>
            <param name="publicKeyInfo">A SubjectPublicKeyInfo object.</param>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricDsaPublicKey.Y">
            <summary>
            Return the public value Y.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricDsaPublicKey.GetEncoded">
            <summary>
            Return an ASN.1 encoded representation of the implementing key in a SubjectPublicKeyInfo structure.
            </summary>
            <returns>An encoded representation of the key.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricECKey">
            <summary>
            Base class for Elliptic Curve (EC) keys.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricECKey.Algorithm">
            <summary>
            Return the algorithm this Elliptic Curve key is for.
            </summary>
            <value>The key's algorithm.</value>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricECKey.DomainParameters">
            <summary>
            Return the Elliptic Curve domain parameters associated with this key.
            </summary>
            <value>The EC domain parameters for the key.</value>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricECKey.GetEncoded">
            <summary>
            Return an ASN.1 encoded representation of the implementing key.
            </summary>
            <returns>An encoded representation of the key.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricECPrivateKey.#ctor(Org.BouncyCastle.Crypto.Algorithm,System.Byte[])">
            <summary>
            Constructor from an algorithm and an encoding of a PrivateKeyInfo object containing an EC private key.
            </summary>
            <param name="ecAlg">Algorithm marker to associate with the key.</param>
            <param name="encoding">An encoding of a PrivateKeyInfo object.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricECPrivateKey.#ctor(Org.BouncyCastle.Crypto.Algorithm,Org.BouncyCastle.Asn1.Pkcs.PrivateKeyInfo)">
            <summary>
            Constructor from an algorithm and a PrivateKeyInfo object containing an EC private key.
            </summary>
            <param name="ecAlg">Algorithm marker to associate with the key.</param>
            <param name="privateKeyInfo">A PrivateKeyInfo object.</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricECPublicKey">
            <summary>
            Class for Elliptic Curve (EC) public keys.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricECPublicKey.#ctor(Org.BouncyCastle.Crypto.Algorithm,System.Byte[])">
            <summary>
            Constructor from an algorithm and an encoding of a SubjectPublicKeyInfo object containing an EC public key.
            </summary>
            <param name="ecAlg">Algorithm marker to associate with the key.</param>
            <param name="publicKeyInfoEncoding">An encoding of a SubjectPublicKeyInfo object.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricECPublicKey.#ctor(Org.BouncyCastle.Crypto.Algorithm,Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo)">
            <summary>
            Constructor from an algorithm and a SubjectPublicKeyInfo object containing an EC public key.
            </summary>
            <param name="ecAlg">Algorithm marker to associate with the key.</param>
            <param name="publicKeyInfo">A SubjectPublicKeyInfo object.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricECPublicKey.GetEncoded">
            <summary>
            Return an ASN.1 encoded representation of the implementing key in a SubjectPublicKeyInfo structure.
            </summary>
            <returns>An encoded representation of the key.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricKeyPair`2">
            <summary>
            Carrier class for a public key and its associated private key. This class will check the key
            pair on construction.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricKeyPair`2.#ctor(`0,`1)">
             Create a public/private key pair.
            
             @param publicKey the public key component.
             @param privateKey the private key component.
             @throws IllegalArgumentException if the public and private key arguments are inconsistent.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricKeyPair`2.PublicKey">
            <summary>
            Gets the public key of the pair.
            </summary>
            <value>The public key.</value>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricKeyPair`2.PrivateKey">
            <summary>
            Gets the private key of the pair.
            </summary>
            <value>The private key.</value>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricKeyPairGenerator`3">
            <summary>
            Base class for a generator of public/private key pairs.
            </summary>
            <typeparam name="TParam">Base parameter type.</typeparam>
            <typeparam name="TPublic">Type of the public key in the key pair.</typeparam>
            <typeparam name="TPrivate">Type of the private key in the key pair.</typeparam>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricKeyPairGenerator`3.Parameters">
            <summary>
            Return the parameters associated with this key pair generator.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricKeyPairGenerator`3.GenerateKeyPair">
            <summary>
            Generate a new key pair in accordance with the generator's parameter set.
            </summary>
            <returns>A new key pair.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricNHKey.GetEncoded">
            <summary>
            Return an ASN.1 encoded representation of the implementing key.
            </summary>
            <returns>An encoded representation of the key.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricNHPrivateKey">
            <summary>
            Class for NewHope (NH) private keys.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricNHPrivateKey.#ctor(Org.BouncyCastle.Crypto.Algorithm,System.Byte[])">
            <summary>
            Constructor from an algorithm and an encoding of a PrivateKeyInfo object containing a NewHope private key.
            </summary>
            <param name="alg">Algorithm marker to associate with the key.</param>
            <param name="encoding">An encoding of a PrivateKeyInfo object.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricNHPrivateKey.#ctor(Org.BouncyCastle.Crypto.Algorithm,Org.BouncyCastle.Asn1.Pkcs.PrivateKeyInfo)">
            <summary>
            Constructor from an algorithm and a PrivateKeyInfo object containing a NewHope private key.
            </summary>
            <param name="algorithm">Algorithm marker to associate with the key.</param>
            <param name="privateKeyInfo">A PrivateKeyInfo object.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricNHPrivateKey.GetEncoded">
            <summary>
            Return an ASN.1 encoded representation of the implementing key in a PrivateKeyInfo structure.
            </summary>
            <returns>An encoded representation of the key.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricNHPublicKey">
            <summary>
            Class for NewHope (NH) public keys.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricNHPublicKey.#ctor(Org.BouncyCastle.Crypto.Algorithm,System.Byte[])">
            <summary>
            Constructor from an algorithm and an encoding of a SubjectPublicKeyInfo object containing a NewHope public key.
            </summary>
            <param name="algorithm">Algorithm marker to associate with the key.</param>
            <param name="enc">An encoding of a SubjectPublicKeyInfo object.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricNHPublicKey.#ctor(Org.BouncyCastle.Crypto.Algorithm,Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo)">
            <summary>
            Constructor from an algorithm and a SubjectPublicKeyInfo object containing a NewHope public key.
            </summary>
            <param name="algorithm">Algorithm marker to associate with the key.</param>
            <param name="publicKeyInfo">A SubjectPublicKeyInfo object.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricNHPublicKey.GetEncoded">
            <summary>
            Return an ASN.1 encoded representation of the implementing key in a SubjectPublicKeyInfo structure.
            </summary>
            <returns>An encoded representation of the key.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricRsaKey">
            <summary>
            Base class for RSA keys.
            <para>
            Note: the module attempts to prevent accidental recent use of RSA keys for signing and encryption purposes by associating
            a specific usage with a modulus. If the module is not running in approved mode this behavior can be overridden by
            setting the system property "Org.BouncyCastle.Rsa.AllowMultiUse" to "true".
            </para>
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricRsaKey.Usage">
            <summary>
            Specific RSA key usages.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricRsaKey.Usage.Undefined">
            <summary>No key usage defined yet.</summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricRsaKey.Usage.SignOrVerify">
            <summary>Key usage signing or verification.</summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricRsaKey.Usage.EncryptOrDecrypt">
            <summary>Key usage encryption or decryption.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricRsaKey.Algorithm">
            <summary>
            Return the algorithm this RSA key is for.
            </summary>
            <value>The key's algorithm.</value>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricRsaKey.Modulus">
            <summary>
            Return the modulus for this RSA key.
            </summary>
            <value>The key's modulus.</value>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricRsaKey.CanBeUsed(Org.BouncyCastle.Crypto.Asymmetric.AsymmetricRsaKey.Usage)">
            <summary>
            Check to see if a key can be used for a specific usage. Essentially this will return false if
            the modulus is associated with a different usage already. The system property
            "Org.BouncyCastle.Rsa.AllowMultiUse" can be set to "true" to override this check.
            </summary>
            <returns><c>true</c> if the modulus is already associated with the usage, or has not being used already; otherwise, <c>false</c>.</returns>
            <param name="usage">Usage for the RSA key.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricRsaKey.GetEncoded">
            <summary>
            Return an ASN.1 encoded representation of the implementing key.
            </summary>
            <returns>An encoded representation of the key.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricRsaPrivateKey">
            <summary>
            Class for RSA private keys.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricRsaPrivateKey.#ctor(Org.BouncyCastle.Crypto.Algorithm,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            <summary>
            Basic constructor for an RSA private key with CRT factors.
            </summary>
            <param name="algorithm">Algorithm marker.</param>
            <param name="modulus">The modulus.</param>
            <param name="publicExponent">The public exponent.</param>
            <param name="privateExponent">The private exponent.</param>
            <param name="p">The prime P.</param>
            <param name="q">The prime Q.</param>
            <param name="dp">The prime exponent of P.</param>
            <param name="dq">The prime exponent of Q.</param>
            <param name="qInv">The CRT coefficient.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricRsaPrivateKey.#ctor(Org.BouncyCastle.Crypto.Algorithm,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            <summary>
            Basic constructor for an RSA private key with simple components.
            </summary>
            <param name="algorithm">Algorithm marker.</param>
            <param name="modulus">The modulus.</param>
            <param name="privateExponent">The private exponent.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricRsaPrivateKey.#ctor(Org.BouncyCastle.Crypto.Algorithm,System.Byte[])">
            <summary>
            Constructor from an algorithm and an encoding of a PrivateKeyInfo object containing an RSA private key.
            </summary>
            <param name="algorithm">Algorithm marker to associate with the key.</param>
            <param name="encoding">An encoding of a PrivateKeyInfo object.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricRsaPrivateKey.#ctor(Org.BouncyCastle.Crypto.Algorithm,Org.BouncyCastle.Asn1.Pkcs.PrivateKeyInfo)">
            <summary>
            Constructor from an algorithm and a PrivateKeyInfo object containing an RSA private key.
            </summary>
            <param name="algorithm">Algorithm marker to associate with the key.</param>
            <param name="privateKeyInfo">A PrivateKeyInfo object.</param>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricRsaPrivateKey.PublicExponent">
            <summary>
            Return the public exponent.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricRsaPrivateKey.PrivateExponent">
            <summary>
            Return the private exponent.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricRsaPrivateKey.P">
            <summary>
            Return the prime P.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricRsaPrivateKey.Q">
            <summary>
            Return the prime Q.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricRsaPrivateKey.DP">
            <summary>
            Return the prime exponent of P.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricRsaPrivateKey.DQ">
            <summary>
            Return the prime exponent of Q.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricRsaPrivateKey.QInv">
            <summary>
            Return the CRT coefficient.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricRsaPrivateKey.GetEncoded">
            <summary>
            Return an ASN.1 encoded representation of the implementing key in a PrivateKeyInfo structure.
            </summary>
            <returns>An encoded representation of the key.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricRsaPublicKey">
            <summary>
            Class for RSA public keys.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricRsaPublicKey.#ctor(Org.BouncyCastle.Crypto.Algorithm,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            <summary>
            Basic constructor for an RSA public key from its numeric components.
            </summary>
            <param name="algorithm">The algorithm marker.</param>
            <param name="modulus">The modulus.</param>
            <param name="publicExponent">The public exponent.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricRsaPublicKey.#ctor(Org.BouncyCastle.Crypto.Algorithm,System.Byte[])">
            <summary>
            Constructor from an algorithm and an encoding of a SubjectPublicKeyInfo object containing an RSA public key.
            </summary>
            <param name="algorithm">Algorithm marker to associate with the key.</param>
            <param name="publicKeyInfoEncoding">An encoding of a SubjectPublicKeyInfo object.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricRsaPublicKey.#ctor(Org.BouncyCastle.Crypto.Algorithm,Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo)">
            <summary>
            Constructor from an algorithm and a SubjectPublicKeyInfo object containing an RSA public key.
            </summary>
            <param name="algorithm">Algorithm marker to associate with the key.</param>
            <param name="publicKeyInfo">A SubjectPublicKeyInfo object.</param>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricRsaPublicKey.PublicExponent">
            <summary>
            Return the public exponent.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricRsaPublicKey.GetEncoded">
            <summary>
            Return an ASN.1 encoded representation of the implementing key in a SubjectPublicKeyInfo structure.
            </summary>
            <returns>An encoded representation of the key.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricSphincsKey">
            <summary>
            Base class for SPHINCS-256 keys.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricSphincsKey.Algorithm">
            <summary>
            Return the algorithm this SPHINCS key is for.
            </summary>
            <value>The key's algorithm.</value>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricSphincsKey.TreeDigestAlgorithm">
            <summary>
            Return the digest algorithm used to construct the tree for the public key.
            </summary>
            <value>The key digest algorithm for tree construction.</value>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricSphincsKey.GetKeyData">
            <summary>
            Return the key data (a byte representation of the digest tree used in signature processing).
            </summary>
            <returns>The key data.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricSphincsKey.GetEncoded">
            <summary>
            Return an ASN.1 encoded representation of the implementing key.
            </summary>
            <returns>An encoded representation of the key.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricSphincsPrivateKey">
            <summary>
            Representation for SPHINCS-256 private keys.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricSphincsPrivateKey.#ctor(Org.BouncyCastle.Crypto.Algorithm,System.Byte[])">
            <summary>
            Constructor from an algorithm and an encoding of a PrivateKeyInfo object containing a SPHINCS private key.
            </summary>
            <param name="algorithm">Algorithm marker to associate with the key.</param>
            <param name="encoding">An encoding of a PrivateKeyInfo object.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricSphincsPrivateKey.#ctor(Org.BouncyCastle.Crypto.Algorithm,Org.BouncyCastle.Asn1.Pkcs.PrivateKeyInfo)">
            <summary>
            Constructor from an algorithm and a PrivateKeyInfo object containing a SPHINCS private key.
            </summary>
            <param name="algorithm">Algorithm marker to associate with the key.</param>
            <param name="privateKeyInfo">A PrivateKeyInfo object.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricSphincsPrivateKey.GetEncoded">
            <summary>
            Return an ASN.1 encoded representation of the implementing key in a PrivateKeyInfo structure.
            </summary>
            <returns>An encoded representation of the key.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricSphincsPrivateKey.GetKeyData">
            <summary>
            Return the key data (a byte representation of the digest tree used in signature generation).
            </summary>
            <returns>The key data.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricSphincsPublicKey">
            <summary>
            Representation for SPHINCS-256 public keys.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricSphincsPublicKey.#ctor(Org.BouncyCastle.Crypto.Algorithm,System.Byte[])">
            <summary>
            Constructor from an algorithm and an encoding of a SubjectPublicKeyInfo object containing a SPHINCS public key.
            </summary>
            <param name="algorithm">Algorithm marker to associate with the key.</param>
            <param name="enc">An encoding of a SubjectPublicKeyInfo object.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricSphincsPublicKey.#ctor(Org.BouncyCastle.Crypto.Algorithm,Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo)">
            <summary>
            Constructor from an algorithm and a SubjectPublicKeyInfo object containing a SPHINCS public key.
            </summary>
            <param name="algorithm">Algorithm marker to associate with the key.</param>
            <param name="publicKeyInfo">A SubjectPublicKeyInfo object.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricSphincsPublicKey.GetEncoded">
            <summary>
            Return an ASN.1 encoded representation of the implementing key in a SubjectPublicKeyInfo structure.
            </summary>
            <returns>An encoded representation of the key.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.AsymmetricSphincsPublicKey.GetKeyData">
            <summary>
            Return the key data (a byte representation of the digest tree used in signature verification).
            </summary>
            <returns>The key data.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.DHDomainParameters.#ctor(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
              Minimal usable parameters.
            
             @param p the prime p defining the Galois field.
             @param g the generator of the multiplicative subgroup of order g.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.DHDomainParameters.#ctor(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,System.Int32)">
             Minimal usable parameters with a private value length (PKCS#3).
            
             @param p the prime p defining the Galois field.
             @param g the generator of the multiplicative subgroup of order g.
             @param l the maximum bit length for the private value.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.DHDomainParameters.#ctor(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
             Minimal constructor for parameters able to be used to verify a public key.
            
             @param p the prime p defining the Galois field.
             @param g the generator of the multiplicative subgroup of order g.
             @param q specifies the prime factor of p - 1
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.DHDomainParameters.#ctor(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,System.Int32)">
             Minimal constructor for parameters able to be used to verify a public key with a private value length.
            
             @param p the prime p defining the Galois field.
             @param g the generator of the multiplicative subgroup of order g.
             @param q specifies the prime factor of p - 1
             @param l the maximum bit length for the private value.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.DHDomainParameters.#ctor(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,System.Int32,System.Int32)">
             Parameters which can verify a public key with private value lengths.
            
             @param p the prime p defining the Galois field.
             @param g the generator of the multiplicative subgroup of order g.
             @param q specifies the prime factor of p - 1
             @param m the minimum bit length for the private value.
             @param l the maximum bit length for the private value.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.DHDomainParameters.#ctor(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Crypto.Asymmetric.DHValidationParameters)">
             Standard constructor - the full X9.42 parameter set.
            
             @param p the prime p defining the Galois field.
             @param g the generator of the multiplicative subgroup of order g.
             @param q specifies the prime factor of p - 1
             @param j optionally specifies the value that satisfies the equation p = jq+1
             @param validation parameters for validating these domain parameters.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.DHDomainParameters.#ctor(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,System.Int32,Org.BouncyCastle.Crypto.Asymmetric.DHValidationParameters)">
             X9.42 parameters with private value length.
            
             @param p the prime p defining the Galois field.
             @param g the generator of the multiplicative subgroup of order g.
             @param q specifies the prime factor of p - 1
             @param l the maximum bit length for the private value.
             @param validation parameters for validating these domain parameters.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.DHDomainParameters.#ctor(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,System.Int32,System.Int32,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Crypto.Asymmetric.DHValidationParameters)">
             Base constructor - the full domain parameter set.
            
             @param p the prime p defining the Galois field.
             @param g the generator of the multiplicative subgroup of order g.
             @param q specifies the prime factor of p - 1
             @param m the minimum bit length for the private value.
             @param l the maximum bit length for the private value.
             @param j optionally specifies the value that satisfies the equation p = jq+1
             @param validation parameters for validating these domain parameters.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Asymmetric.DHDomainParameters.P">
             Return the prime p defining the Galois field.
            
             @return the prime p.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Asymmetric.DHDomainParameters.G">
             Return the generator of the multiplicative subgroup of order g.
            
             @return the generator g.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Asymmetric.DHDomainParameters.Q">
             Return q, the prime factor of p - 1
            
             @return q value
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Asymmetric.DHDomainParameters.J">
             Return the subgroup factor J, which satisifes the equation p=jq+1, if present.
            
             @return subgroup factor, or null.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Asymmetric.DHDomainParameters.M">
             Return the minimum length of the private value.
            
             @return the minimum length of the private value in bits.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Asymmetric.DHDomainParameters.L">
             Return the private value length in bits - if set, zero otherwise
            
             @return the private value length in bits, zero otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.DHValidationParameters.#ctor(System.Byte[])">
             Base constructor - a seed, the counter will be set to -1.
            
             @param seed the seed used to generate the parameters.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.DHValidationParameters.#ctor(System.Byte[],System.Int32)">
             Constructor with a seed and a (p, q) counter for it.
            
             @param seed the seed used to generate the parameters.
             @param counter the counter value associated with using the seed to generate the parameters.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.DHValidationParameters.#ctor(System.Byte[],System.Int32,System.Int32)">
             Base constructor with a seed, counter, and usage index.
            
             @param seed the seed value.
             @param counter  (p, q) counter - -1 if not avaliable.
             @param usageIndex the usage index.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Asymmetric.DHValidationParameters.Counter">
             Return the (p, q) counter value.
            
             @return  the (p, q) counter value, -1 if unavailable.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.DHValidationParameters.GetSeed">
             Return the seed used for the parameter generation.
            
             @return the seed array.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Asymmetric.DHValidationParameters.UsageIndex">
             Return the usage index, -1 if none given.
            
             @return the usage index.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Asymmetric.DsaDomainParameters">
            <summary>
            Container class for DSA domain parameters.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Asymmetric.DsaValidationParameters">
            <summary>
            Validation parameters for confirming DSA parameter generation.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.DsaValidationParameters.#ctor(System.Byte[])">
            <summary>
            Base constructor - a seed, the counter will be set to -1.
            </summary>
            <param name="seed">The seed used to generate the parameters.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.DsaValidationParameters.#ctor(System.Byte[],System.Int32)">
            <summary>
            Constructor with a seed and a (p, q) counter for it.
            </summary>
            <param name="seed">The seed used to generate the parameters.</param>
            <param name="counter">The counter value associated with using the seed to generate the parameters.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.DsaValidationParameters.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Base constructor with a seed, counter, and usage index.
            </summary>
            <param name="seed">The seed value.</param>
            <param name="counter">(p, q) counter - -1 if not avaliable.</param>
            <param name="usageIndex">The usage index.</param>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Asymmetric.DsaValidationParameters.Counter">
            <summary>
            Return the (p, q) counter value.
            </summary>
            <value>The (p, q) counter value, -1 if unavailable.</value>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.DsaValidationParameters.GetSeed">
            <summary>
            Return the seed used for the parameter generation.
            </summary>
            <returns>The the seed array.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Asymmetric.DsaValidationParameters.UsageIndex">
            <summary>
            Return the usage index, -1 if none given.
            </summary>
            <value>The usage index.</value>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Asymmetric.ECDomainParameters">
            <summary>
            Container class for Elliptic Curve domain parameters.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.ECDomainParameters.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECPoint,Org.BouncyCastle.Math.BigInteger)">
            <summary>
            Constructor that assumes the co-factor h is 1.
            </summary>
            <param name="curve">The curve for these domain parameters.</param>
            <param name="G">The base point G for the domain parameters.</param>
            <param name="n">The order for the domain parameters.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.ECDomainParameters.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECPoint,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            <summary>
            Constructor with explicit co-factor.
            </summary>
            <param name="curve">The curve for these domain parameters.</param>
            <param name="G">The base point G for the domain parameters.</param>
            <param name="n">The order for the domain parameters.</param>
            <param name="h">The co-factor.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.ECDomainParameters.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECPoint,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,System.Byte[])">
            <summary>
            Constructor with explicit co-factor and generation seed.
            </summary>
            <param name="curve">The curve for these domain parameters.</param>
            <param name="G">The base point G for the domain parameters.</param>
            <param name="n">The order for the domain parameters.</param>
            <param name="h">The co-factor.</param>
            <param name="seed">The seed value used to generate the domain parameters.</param>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Asymmetric.ECDomainParameters.Curve">
             Return the curve associated with these domain parameters.
            
             @return the domain parameters' curve.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Asymmetric.ECDomainParameters.G">
             Return the base point associated with these domain parameters.
            
             @return the domain parameters' base point.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Asymmetric.ECDomainParameters.N">
             Return the order associated with these domain parameters.
            
             @return the domain parameters' order.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Asymmetric.ECDomainParameters.H">
             Return the co-factor associated with these domain parameters.
            
             @return the domain parameters' co-factor.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.ECDomainParameters.GetSeed">
             Return the generation seed associated with these domain parameters.
            
             @return the domain parameters' seed.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.ECDomainParametersIndex.LookupDomainParameters(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
             Retrieve an EC based domain parameter by OID. A custom curve will be returned if one is available.
            
             @param paramOid object identifier for the domain parameters.
             @return the matching domain parameters if found, null otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.ECDomainParametersIndex.LookupDomainParameters(Org.BouncyCastle.Crypto.Asymmetric.IECDomainParametersID)">
             Retrieve an EC based domain parameter by parameter ID. A custom curve will be returned if one is available.
            
             @param paramID identifier for the domain parameters.
             @return the matching domain parameters if found, null otherwise.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Asymmetric.ECImplicitDomainParameters">
            <summary>
            Extension class that identifies this domain parameter set as being the ImplicitlyCa domain
            parameters for this JVM.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.ECImplicitDomainParameters.#ctor(Org.BouncyCastle.Crypto.Asymmetric.ECDomainParameters)">
            <summary>
            Base constructor.
            </summary>
            <param name="domainParameters">The ImplicitlyCa domain parameters.</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Asymmetric.NamedECDomainParameters">
            <summary>
            EC domain parameters associated with a specific object identifier.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.NamedECDomainParameters.#ctor(Org.BouncyCastle.Asn1.DerObjectIdentifier,Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECPoint,Org.BouncyCastle.Math.BigInteger)">
            <summary>
            Constructor that assumes the co-factor h is 1.
            </summary>
            <param name="id">The object identifier that represents these parameters.</param>
            <param name="curve">The curve for these domain parameters.</param>
            <param name="G">The base point G for the domain parameters.</param>
            <param name="n">The order for the domain parameters.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.NamedECDomainParameters.#ctor(Org.BouncyCastle.Asn1.DerObjectIdentifier,Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECPoint,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            <summary>
            Constructor with explicit co-factor.
            </summary>
            <param name="id">The object identifier that represents these parameters.</param>
            <param name="curve">The curve for these domain parameters.</param>
            <param name="G">The base point G for the domain parameters.</param>
            <param name="n">The order for the domain parameters.</param>
            <param name="h">The co-factor.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.NamedECDomainParameters.#ctor(Org.BouncyCastle.Asn1.DerObjectIdentifier,Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECPoint,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,System.Byte[])">
            <summary>
            Constructor with explicit co-factor and generation seed.
            </summary>
            <param name="id">The object identifier that represents these parameters.</param>
            <param name="curve">The curve for these domain parameters.</param>
            <param name="G">The base point G for the domain parameters.</param>
            <param name="n">The order for the domain parameters.</param>
            <param name="h">The co-factor.</param>
            <param name="seed">The seed value used to generate the domain parameters.</param>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Asymmetric.NamedECDomainParameters.ID">
            <summary>
            Return object identifier that identifies these parameters.
            </summary>
            <value>The OID that names this parameter set.</value>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Asymmetric.PrimeCertaintyCalculator.GetDefaultCertainty(System.Int32)">
            <summary>
            Return the current wisdom on prime certainty requirements.
            </summary>
            <returns>A certainty value.</returns>
            <param name="keySizeInBits">Size of the key being generated.</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Check">
            <summary>
            Collection of methods for producing data length exceptions.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.CryptoOperationError">
            <summary>
            Base error class for operational errors.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.CryptoStatus.MacValue">
            <summary>
            The initial value is a placeholder, to be replaced by an actual MAC calculated by the core-mac
            tool (as a post-build event).
            </summary>
            <remarks>The first few bytes are "_BCFIPS_MAC_", the rest was randomly generated.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.CryptoStatus.IsReady">
            <summary>Check to see if the FIPS module is ready for operation.</summary>
            <returns><c>true</c> if the module is ready for operation with all self-tests complete.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.CryptoStatus.IsErrorStatus">
            <summary>
            Return true if the module is in error status, false otherwise.
            </summary>
            <returns><c>true</c>, if an error has been detected, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.CryptoStatus.GetStatusMessage">
            <summary>
            Return a message indicating the current status.
            </summary>
            <returns>READY if all is well, an exception message otherwise.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.CryptoStatus.GetModuleHMac">
            <summary>
            Return the HMAC used to verify that the code contained in the assembly is the same.
            </summary>
            <returns>the internally calculated HMAC for the assembly.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.DataLengthException">
            this exception is thrown if a buffer that is meant to have output
            copied into it turns out to be too short, or if we've been given
            insufficient input. In general this exception will Get thrown rather
            than an ArrayOutOfBounds exception.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.DataLengthException.#ctor">
            base constructor.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.DataLengthException.#ctor(System.String)">
             create a DataLengthException with the given message.
            
             @param message the message to be carried with the exception.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.DigestAlgorithm">
            <summary>
            Algorithm marker specifically for use with message digests and HMACs.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.DigestFactory`1.AlgorithmDetails">
            <summary>The algorithm details object for calculators made by this factory.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.DigestFactory`1.CreateCalculator">
            <summary>
            Create a stream calculator for the digest algorithm associated with this factory. The stream
            calculator is used for the actual operation of entering the data to be digested
            and producing the digest block.
            </summary>
            <returns>A calculator producing an IBlockResult with the final digest in it.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.DrbgPseudoRandom.BlockSize">
            <summary>
            Return the block size of the underlying DRBG
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.ExchangePair">
            <summary>
            Pair for a value exchange algorithm where the responding party has no private key, such as NewHope.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ExchangePair.#ctor(Org.BouncyCastle.Crypto.IAsymmetricPublicKey,System.Byte[])">
            <summary>
            Base constructor.
            </summary>
            <param name="key">The responding party's public key.</param>
            <param name="shared">The calculated shared value.</param>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.ExchangePair.PublicKey">
            <summary>
            Return the responding party's public key.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ExchangePair.GetSharedValue">
            <summary>
            Return the shared value that is associated with the two public keys involved.
            </summary>
            <returns>The shared value.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.CtrSP800Drbg">
            <summary>
            An SP800-90A CTR DRBG.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Fips.CtrSP800Drbg.#ctor(Org.BouncyCastle.Crypto.Internal.IBlockCipher,System.Int32,System.Int32,Org.BouncyCastle.Crypto.IEntropySource,System.Byte[],System.Byte[])">
            Construct a SP800-90A CTR DRBG.
            <p>
            Minimum entropy requirement is the security strength requested.
            </p>
            @param engine underlying block cipher to use to support DRBG
            @param keySizeInBits size of the key to use with the block cipher.
            @param securityStrength security strength required (in bits)
            @param entropySource source of entropy to use for seeding/reseeding.
            @param personalizationString personalization string to distinguish this DRBG (may be null).
            @param nonce nonce to further distinguish this DRBG (may be null).
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Fips.CtrSP800Drbg.BlockSize">
             Return the block size (in bits) of the DRBG.
            
             @return the number of bits produced on each internal round of the DRBG.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Fips.CtrSP800Drbg.SecurityStrength">
             Return the security strength of the DRBG.
            
             @return the security strength (in bits) of the DRBG.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Fips.CtrSP800Drbg.Generate(System.Byte[],System.Byte[],System.Boolean)">
             Populate a passed in array with random data.
            
             @param output output array for generated bits.
             @param additionalInput additional input to be added to the DRBG in this step.
             @param predictionResistant true if a reseed should be forced, false otherwise.
            
             @return number of bits generated, -1 if a reseed required.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Fips.CtrSP800Drbg.Reseed(System.Byte[])">
             Reseed the DRBG.
            
             @param additionalInput additional input to be added to the DRBG in this step.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Fips.CtrSP800Drbg.expandKey(System.Byte[])">
            Note that the input key must already be large enough to hold its expanded form
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Fips.CtrSP800Drbg.padKey(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Pad out a key for TDEA, setting odd parity for each byte.
            
             @param keyMaster
             @param keyOff
             @param tmp
             @param tmpOff
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Fips.DesEdeKeyGenerator.Init(Org.BouncyCastle.Crypto.Internal.KeyGenerationParameters)">
            <summary>
            Initialise the key generator - if strength is set to zero
            the key generated will be 192 bits in size, otherwise
            strength can be 128 or 192 (or 112 or 168 if you don't count
            parity bits), depending on whether you wish to do 2-key or 3-key
            triple DES.
            </summary>
            <param name="param">the parameters to be used for key generation</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Fips.DrbgUtilities.HashDF(Org.BouncyCastle.Crypto.Internal.IDigest,System.Byte[],System.Int32)">
            Used by both Dual EC and Hash.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.DrbgUtilities.LyingEntropySource">
            <summary>
            Lying entropy source for self testing
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsAes">
            <summary>
            Source class for FIPS approved implementations of AES based algorithms.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsAes.Alg">
            <summary>
            Raw AES algorithm, can be used for creating general purpose AES keys.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsAes.Alg128">
            <summary>
            Algorithm tag for AES with 128 bit key.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsAes.Alg192">
            <summary>
            Algorithm tag for AES with 192 bit key.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsAes.Alg256">
            <summary>
            Algorithm tag for AES with 256 bit key.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsAes.KeyGen128">
            <summary>
            Parameters to use for creating a 128 bit AES key generator.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsAes.KeyGen192">
            <summary>
            Parameters to use for creating a 192 bit AES key generator.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsAes.KeyGen256">
            <summary>
            Parameters to use for creating a 256 bit AES key generator.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsAes.Ecb">
            <summary>
            AES in electronic code book (ECB) mode.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsAes.Cbc">
            <summary>
            AES in cipher block chaining (CBC) mode.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsAes.Cfb8">
            <summary>
             AES in cipher feedback (CFB) mode, 8 bit block size.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsAes.Cfb128">
            <summary>
            AES in cipher feedback (CFB) mode, 128 bit block size.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsAes.Ofb">
            <summary>
            AES in output feedback (OFB) mode - 128 bit block size.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsAes.Ctr">
            <summary>
             AES in counter (CTR) mode.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsAes.CbcWithCS1">
            <summary>
             AES in CBC mode with cipher text stealing type CS1.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsAes.CbcWithCS2">
            <summary>
             AES in CBC mode with cipher text stealing type CS2.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsAes.CbcWithCS3">
            <summary>
             AES in CBC mode with cipher text stealing type CS3.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsAes.Ccm">
            <summary>
             AES in counter with CBC-MAC (CCM).
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsAes.Gcm">
            <summary>
            AES in Galois/Counter Mode (GCM).
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsAes.CMac">
            <summary>
            AES cipher-based CMAC algorithm.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsAes.GMac">
            <summary>
            AES cipher-based GMAC algorithm.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsAes.KW">
            <summary>
            AES as a FIPS SP800-38F/RFC 3394 key wrapper.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsAes.KWP">
            <summary>
            AES as a FIPS SP800-38F key wrapper with padding.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsAes.Key">
            <summary>
            AES key class.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsAes.KeyGenerationParameters">
            <summary>
            AES key generation parameters base class.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsAes.KeyGenerator">
            <summary>
            AES key generator.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Fips.FipsAes.KeyGenerator.GenerateKey">
            <summary>
            Generate a key.
            </summary>
            <returns>An AES key.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsAes.Parameters">
            <summary>
            Base class for simple AES parameters.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsAes.ParametersWithIV">
            <summary>
            Base class for AES parameters requiring an initialization vector.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsAes.AuthenticationParameters">
            <summary>
            Base authentication parameters class for use with MACs.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsAes.AuthenticationParametersWithIV">
            <summary>
            Base authentication parameters class for use with MACs and AEAD ciphers requiring a nonce or IV.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Fips.FipsAes.AuthenticationParametersWithIV.WithIV(Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Create a new parameter set with a different IV based on the output
            of the passed in random.
            </summary>
            <returns>A copy of the current parameter set with the new IV.</returns>
            <param name="random">A SecureRandom for deriving the IV.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Fips.FipsAes.AuthenticationParametersWithIV.WithIV(Org.BouncyCastle.Security.SecureRandom,System.Int32)">
            <summary>
            Create a new parameter set with a different IV based on the output
            of the passed in random.
            </summary>
            <returns>A copy of the current parameter set with the new IV.</returns>
            <param name="random">A SecureRandom for deriving the IV.</param>
            <param name="ivLen">Length of the IV to generate.</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsAes.WrapParameters">
            <summary>
            Base class for AES key wrap parameters.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsDrbg">
            <summary>
            Source class for FIPS approved implementations of Deterministic Random Bit Generators (DRBGs) from SP 800-90A.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsDrbg.Sha1">
            <summary>
            HASH DRBG - SHA-1
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsDrbg.Sha224">
            <summary>
            HASH DRBG - SHA-224
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsDrbg.Sha256">
            <summary>
            HASH DRBG - SHA-256
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsDrbg.Sha384">
            <summary>
            HASH DRBG - SHA-384
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsDrbg.Sha512">
            <summary>
            HASH DRBG - SHA-512
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsDrbg.Sha512_224">
            <summary>
            HASH DRBG - SHA-512/224
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsDrbg.Sha512_256">
            <summary>
            HASH DRBG - SHA-512/256
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsDrbg.Sha1HMac">
            <summary>
            HMAC DRBG - SHA-1
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsDrbg.Sha224HMac">
            <summary>
            HMAC DRBG - SHA-224
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsDrbg.Sha256HMac">
            <summary>
            HMAC DRBG - SHA-256
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsDrbg.Sha384HMac">
            <summary>
            HMAC DRBG - SHA-384
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsDrbg.Sha512HMac">
            <summary>
            HMAC DRBG - SHA-512
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsDrbg.Sha512_224HMac">
            <summary>
            HMAC DRBG - SHA-512/224
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsDrbg.Sha512_256HMac">
            <summary>
            HMAC DRBG - SHA-512/256
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsDrbg.CtrTripleDes168">
            <summary>
            CTR DRBG - 3-Key TripleDES
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsDrbg.CtrAes128">
            <summary>
            CTR DRBG - 128 bit AES
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsDrbg.CtrAes192">
            <summary>
            CTR DRBG - 192 bit AES
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsDrbg.CtrAes256">
            <summary>
            CTR DRBG - 256 bit AES
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsDrbg.BuilderService">
            <summary>
            Service class for DRBG SecureRandom builder retrieval.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsDrbg.Base">
            <summary>
            Base class for DRBG SecureRandom construction.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Fips.FipsDrbg.Base.FromDefaultEntropy">
            <summary>
            Return a builder using an EntropySourceProvider based on the default SecureRandom with
            predictionResistant set to false.
            <para>
            Any SecureRandom created from a builder constructed like this will make use of input passed to SecureRandom.setSeed() if
            the default SecureRandom does for its generateSeed() call.
            </para>
            </summary>
            <returns>A new Builder instance.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Fips.FipsDrbg.Base.FromEntropySource(Org.BouncyCastle.Security.SecureRandom,System.Boolean)">
            <summary>
            Construct a builder with an EntropySourceProvider based on the passed in SecureRandom and the passed in value for prediction resistance.
            </summary>
            <returns>A new Builder instance.</returns>
            <param name="entropySource">A source of entropy.</param>
            <param name="predictionResistant">true if this entropySource is prediction resistant, false otherwise.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Fips.FipsDrbg.Base.FromEntropySource(Org.BouncyCastle.Crypto.IEntropySourceProvider)">
            <summary>
            Create a builder which makes creates the SecureRandom objects from a specified entropy source provider.
            <para>
            Note: If this method is used any calls to setSeed() in the resulting SecureRandom will be ignored.
            </para>
            </summary>
            <returns>A new Builder instance.</returns>
            <param name="entropySourceProvider">A provider of EntropySource objects.</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsDrbg.Builder">
            <summary>
            Builder for SecureRandom objects based on the FIPS DRBGs.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Fips.FipsDrbg.Builder.SetPersonalizationString(System.Byte[])">
            <summary>
            Set the personalization string for DRBG SecureRandoms created by this builder.
            </summary>
            <returns>The current Builder instance.</returns>
            <param name="personalizationString">The personalisation string for the underlying DRBG.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Fips.FipsDrbg.Builder.SetSecurityStrength(System.Int32)">
            <summary>
            Set the security strength required for DRBGs used in building SecureRandom objects.
            </summary>
            <returns>The current Builder instance.</returns>
            <param name="securityStrength">The security strength (in bits)</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Fips.FipsDrbg.Builder.SetEntropyBitsRequired(System.Int32)">
            <summary>
            Set the amount of entropy bits required for seeding and reseeding DRBGs used in building SecureRandom objects.
            </summary>
            <returns>The current Builder instance.</returns>
            <param name="entropyBitsRequired">The number of bits of entropy to be requested from the entropy source on each seed/reseed.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Fips.FipsDrbg.Builder.Build(System.Byte[],System.Boolean)">
            <summary>
            Build a SecureRandom based on a SP 800-90A DRBG.
            </summary>
            <param name="nonce">nonce value to use in DRBG construction.</param>
            <param name="predictionResistant">specify whether the underlying DRBG in the resulting SecureRandom should reseed on each request for bytes.</param>
            <returns>a SecureRandom supported by a DRBG.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Fips.FipsDrbg.Builder.Build(System.Byte[],System.Boolean,System.Byte[])">
            <summary>
            Build a SecureRandom based on a SP 800-90A DRBG.
            </summary>
            <param name="nonce">Nonce value to use in DRBG construction.</param>
            <param name="predictionResistant">Specify whether the underlying DRBG in the resulting SecureRandom should reseed on each request for bytes.</param>
            <param name="additionalInput">Initial additional input to be used for generating the initial continuous health check block by the DRBG.</param>
            <returns>a SecureRandom supported by a DRBG.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsDsa">
            <summary>
            Source class for FIPS approved implementations of DSA based algorithms.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsDsa.Alg">
            <summary>
            DSA key marker, can be used for creating general purpose DSA keys.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsDsa.Dsa">
            <summary>
            DSA algorithm parameter source - default is SHA-384
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsDsa.SignatureParameters">
            <summary>
            Configuration parameters for DSA signatures.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsDsa.KeyGenerationParameters">
            <summary>
            Parameters for DSA key pair generation.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Fips.FipsDsa.KeyGenerationParameters.#ctor(Org.BouncyCastle.Crypto.Asymmetric.DsaDomainParameters)">
            <summary>
            Base constructor for the default algorithm ID.
            </summary>
            <param name="domainParameters">DSA domain parameters representing the parameter set any generated keys will be for.</param>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Fips.FipsDsa.KeyGenerationParameters.DomainParameters">
            <summary>
            Return the DSA domain parameters for this object.
            </summary>
            <value>The DSA domain parameter set.</value>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsDsa.DomainGenParameters">
            <summary>
            Parameters for DSA domain parameter generation.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Fips.FipsDsa.DomainGenParameters.#ctor(System.Int32)">
            <summary>
            Construct just from strength (L) with a default value for N (160 for 1024, 256 for greater)
            and a default certainty.
            </summary>
            <param name="strength">Desired length of prime P in bits (the effective key size).</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Fips.FipsDsa.DomainGenParameters.#ctor(System.Int32,System.Int32)">
            <summary>
            Construct without a usage index, this will do a random construction of G.
            </summary>
            <param name="L">Desired length of prime P in bits (the effective key size).</param>
            <param name="N">Desired length of prime Q in bits.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Fips.FipsDsa.DomainGenParameters.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Construct for a specific usage index - this has the effect of using verifiable canonical generation of G.
            </summary>
            <param name="L">Desired length of prime P in bits (the effective key size).</param>
            <param name="N">Desired length of prime Q in bits.</param>
            <param name="usageIndex">A valid usage index.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Fips.FipsDsa.DomainGenParameters.#ctor(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            <summary>
            Construct from initial prime values, this will do a random construction of G.
            </summary>
            <param name="p">The prime P.</param>
            <param name="q">The prime Q.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Fips.FipsDsa.DomainGenParameters.#ctor(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,System.Byte[],System.Int32)">
            <summary>
            Construct for a specific usage index and initial prime values - this has the effect of using verifiable canonical generation of G.
            </summary>
            <param name="p">The prime P.</param>
            <param name="q">The prime Q.</param>
            <param name="seed">Seed used in the generation of (p, q).</param>
            <param name="usageIndex">A valid usage index.</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsDsa.DomainParametersGenerator">
            <summary>
            Domain parameter generator for DSA.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Fips.FipsDsa.DomainParametersGenerator.#ctor(Org.BouncyCastle.Crypto.Fips.FipsDsa.DomainGenParameters,Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Base constructor.
            </summary>
            <param name="parameters">domain generation parameters.</param>
            <param name="random">A source of randomness for the parameter generation.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Fips.FipsDsa.DomainParametersGenerator.GenerateDomainParameters">
            <summary>
            Generate a new set of DSA domain parameters.
            </summary>
            <returns>A new set of DSADomainParameters</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsDsa.DomainParametersValidator">
            <summary>
            Domain parameter validator for DSA.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Fips.FipsDsa.DomainParametersValidator.#ctor(Org.BouncyCastle.Crypto.Fips.FipsDigestAlgorithm,Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Base constructor - for 186-4
            </summary>
            <param name="digestAlgorithm">Digest to use in prime calculations.</param>
            <param name="random">Source of randomness for prime number testing.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Fips.FipsDsa.DomainParametersValidator.#ctor(Org.BouncyCastle.Crypto.Fips.FipsDsa.DomainParametersValidator.Version,Org.BouncyCastle.Crypto.Fips.FipsDigestAlgorithm,Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Base constructor.
            </summary>
            <param name="version">The version of DSS the validator is for.</param>
            <param name="digestAlgorithm">Digest to use in prime calculations.</param>
            <param name="random">Source of randomness for prime number testing.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Fips.FipsDsa.DomainParametersValidator.IsValidPAndQ(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,System.Byte[],System.Int32)">
            <summary>
            Validate P and Q against the passed in seed and counter.
            </summary>
            <param name="p">The prime P.</param>
            <param name="q">The prime Q.</param>
            <param name="seed">The seed P and Q were derived from.</param>
            <param name="counter">The number of iterations required to derive P.</param>
            <returns>true if the P and Q values are the expected ones, false otherwise.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Fips.FipsDsa.DomainParametersValidator.IsPartiallyValidG(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            <summary>
            Do a partial validation of g against p and q.
            </summary>
            <param name="p">The prime P.</param>
            <param name="q">The prime Q.</param>
            <param name="g">The generator G associated with P and Q.</param>
            <returns>true if the generator is partially valid, false otherwise.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Fips.FipsDsa.DomainParametersValidator.IsValidG(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,System.Byte[],System.Byte,Org.BouncyCastle.Math.BigInteger)">
            <summary>
            Do a full validation of g against p and q by including the seed and index
            associated with g's related parameters.
            </summary>
            <param name="p">The prime P.</param>
            <param name="q">The prime Q.</param>
            <param name="seed">The domain parameter seed used to generate p and q.</param>
            <param name="index">The 8 bit usage index for G.</param>
            <param name="g">The generator G associated with P and Q.</param>
            <returns>true if the generator is valid, false otherwise.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsDsa.KeyPairGenerator">
            <summary>
            Key pair generator for DSA. Create one these via CryptoServicesRegistrar.CreateGenerator() using the KeyGenerationParameters
            object as the key.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Fips.FipsDsa.KeyPairGenerator.#ctor(Org.BouncyCastle.Crypto.Fips.FipsDsa.KeyGenerationParameters,Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Construct a key pair generator for DSA keys.
            </summary>
            <param name="keyGenParameters">Domain parameters and algorithm for the generated key.</param>
            <param name="random">A source of randomness for calculating the private value.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Fips.FipsDsa.KeyPairGenerator.GenerateKeyPair">
            <summary>
            Generate a new DSA key pair.
            </summary>
            <returns>A new AsymmetricKeyPair containing a DSA key pair.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsEC">
            <summary>
            Source class for FIPS approved implementations of Elliptic Curve (EC) algorithms.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsEC.Alg">
            <summary>
            Basic Elliptic Curve algorithm marker, can be used for creating general purpose Elliptic Curve keys.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsEC.Dsa">
            <summary>
            Elliptic Curve DSA algorithm parameter source - default is SHA-384.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsEC.Cdh">
            <summary>
            Elliptic Curve cofactor Diffie-Hellman algorithm parameter source.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsEC.DomainParams">
            <summary>
            ECDomainParametersID for the NIST defined EC domain parameters.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Fips.FipsEC.DomainParams.Values">
            <summary>
            Return a list of the common NIST curves.
            </summary>
            <returns>A list of the common NIST curves.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsEC.AgreementParameters">
            <summary>
            Parameters for EC key agreement.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Fips.FipsEC.AgreementParameters.#ctor(Org.BouncyCastle.Crypto.Fips.FipsAlgorithm)">
            <summary>
            Default constructor which specifies returning the raw secret on agreement calculation.
            </summary>
            <param name="agreementAlgorithm">The agreement algorithm (DH or CDH).</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Fips.FipsEC.AgreementParameters.WithKeyMaterialGenerator(Org.BouncyCastle.Crypto.IKMGenerator)">
            <summary>
            Add a key material generator for doing final processing on the agreed value.
            </summary>
            <returns>A new parameter set, including key material generator.</returns>
            <param name="kmGenerator">The key material generator to use.</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsEC.SignatureParameters">
            <summary>
            Configuration parameters for EC DSA signatures.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsEC.KeyGenerationParameters">
            <summary>
            Parameters for EC key pair generation.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Fips.FipsEC.KeyGenerationParameters.#ctor(Org.BouncyCastle.Crypto.Asymmetric.ECDomainParameters)">
            <summary>
            Constructor for the default algorithm ID.
            </summary>
            <param name="domainParameters">EC domain parameters representing the curve any generated keys will be for.</param>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Fips.FipsEC.KeyGenerationParameters.DomainParameters">
            <summary>
            Return the EC domain parameters for this object.
            </summary>
            <value>The EC domain parameter set.</value>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsEC.KeyPairGenerator">
            <summary>
            Key pair generator for EC. Create one these via CryptoServicesRegistrar.CreateGenerator() using the KeyGenerationParameters
            object as the key.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Fips.FipsEC.KeyPairGenerator.#ctor(Org.BouncyCastle.Crypto.Fips.FipsEC.KeyGenerationParameters,Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Construct a key pair generator for EC keys,
            </summary>
            <param name="keyGenParameters">Domain parameters and algorithm for the generated key.</param>
            <param name="random">A source of randomness for calculating the private value.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Fips.FipsEC.KeyPairGenerator.GenerateKeyPair">
            <summary>
            Generate a new EC key pair.
            </summary>
            <returns>A new AsymmetricKeyPair containing an EC key pair.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsKdf">
            <summary>
            Source class for FIPS approved Key Derivation Function (KDF) implementations.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsKdf.X963">
            <summary>
            Parameters configuration for ASN X9.63-2001
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsKdf.Concatenation">
            <summary>
            Algorithm marker for concatenating KDF in FIPS SP 800-56A/B
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsKdf.Tls1_0">
            <summary>
            Algorithm marker for Transport Layer Security Version 1.0 (TLSv1.0)
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsKdf.Tls1_1">
            <summary>
            Algorithm marker for Transport Layer Security Version 1.1 (TLSv1.1)
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsKdf.Tls1_2">
            <summary>
            Algorithm marker for Transport Layer Security Version 1.2 (TLSv1.2)
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsKdf.TlsKdfBuilder">
            <summary>
            Builder for the TLS 1.0 key derivation function.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsKdf.TlsKdfWithPrfBuilder">
            <summary>
            Builder for the TLS 1.1/1.2 key derivation function.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsKdf.AgreementKdfParameters">
            <summary>
            Parameters for the X9.63 and CONCATENATION key derivation function.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsKdf.TlsStage">
            <summary>
            TLS protocol stages for KDF usage.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsKdf.TlsKdfParameters">
            <summary>
            Parameters for the TLS 1.0 key derivation function.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsKdf.TlsKdfWithPrfParameters">
            <summary>
            Parameters for the TLS 1.1/1.2 key derivation function.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsKdfKmg">
            <summary>
            A key material generator based around a KDF.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Fips.FipsKdfKmg.#ctor(Org.BouncyCastle.Crypto.Fips.FipsKdf.AgreementKdfBuilderService,System.Byte[],System.Int32)">
            <summary>
            Construct a KDF to process the agreed value with. The outputSize parameter determines how many bytes
            will be generated.
            </summary>
            <param name="kdfBuilder">KDF algorithm builder to use for parameter creation.</param>
            <param name="iv">The iv parameter for KDF initialization.</param>
            <param name="outputSize">The size of the output to be generated from the KDF.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Fips.FipsKdfKmg.#ctor(Org.BouncyCastle.Crypto.Fips.FipsKdf.AgreementKdfBuilderService,Org.BouncyCastle.Crypto.Fips.FipsPrfAlgorithm,System.Byte[],System.Int32)">
            <summary>
            Construct a KDF using the given PRF to process the agreed value with. The outputSize parameter determines how many bytes
            will be generated.
            </summary>
            <param name="kdfBuilder">KDF algorithm builder to use for parameter creation.</param>
            <param name="prf">The PRF to use in the KDF.</param>
            <param name="iv">The iv parameter for KDF initialization.</param>
            <param name="outputSize">The size of the output to be generated from the KDF.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Fips.FipsKdfKmg.Generate(System.Byte[])">
            <summary>
            Generate a byte array containing key material based on the passed in agreed value.
            </summary>
            <param name="agreed">The agreed value calculated during the agreement process.</param>
            <returns>A byte[] array containing the generated key material to use.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Fips.FipsParameters.Algorithm">
            <summary>
            Return the algorithm these parameters are associated with.
            </summary>
            <value>The algorithm these parameters are for.</value>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsPbkd">
            <summary>
            Source class for FIPS approved implementations of Password-Based Key Derivation algorithms.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsPbkd.ALGORITHM_PBKDF2">
            <summary>
            Algorithm ID for PBKDF2 (PKCS#5 scheme 2)
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsPbkd.PbkdF2">
            <summary>
            PBKDF2 deriver source - default PRF is HMAC(SHA-1)
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsPbkd.Parameters">
            <summary>
            PBKD parameters.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsPrfAlgorithm">
            <summary>
            Specific type for representing FIPS algorithms which act as pseudo-random-functions. 
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Fips.FipsPrfKmg.#ctor(Org.BouncyCastle.Crypto.Fips.FipsPrfAlgorithm,System.Byte[])">
            <summary>
            Contruct a PRF algorithm and salt to process the Z value with (as in SP 800-56C)
            </summary>
            <param name="prfAlgorithm">PRF represent the HMAC algorithm to use.</param>
            <param name="salt">The salt to use to initialise the PRF</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsRsa">
            <summary>
            Source class for FIPS approved implementations of RSA algorithms.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsRsa.WrapOaep">
            <summary>
             RSA OAEP key wrap algorithm parameter source - default is SHA-384
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsRsa.Pkcs1v15">
            <summary>
            RSA PKCS#1 v1.5 signature  algorithm parameter source - default is SHA-384
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsRsa.X931">
            <summary>
            RSA X9.31 signature algorithm parameter source - default is SHA-384
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsRsa.Pss">
            <summary>
            RSA PSS signature  algorithm parameter source - default is SHA-384
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsRsa.OaepWrapParameters">
            <summary>
            OAEP key wrap parameters base class.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsRsa.SignatureParameters">
            <summary>
            PKCS#1.5/X9.31 signature parameters base class.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsRsa.PssSignatureParameters">
            <summary>
            PSS signature parameters base class.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsRsa.KeyGenerationParameters">
            <summary>
            Parameters for RSA key pair generation.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Fips.FipsRsa.KeyGenerationParameters.#ctor(Org.BouncyCastle.Math.BigInteger,System.Int32)">
            <summary>
            Base constructor - a default certainty will be calculated.
            </summary>
            <param name="publicExponent">The public exponent to use.</param>
            <param name="keySize">The key size (in bits)</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Fips.FipsRsa.KeyGenerationParameters.#ctor(Org.BouncyCastle.Math.BigInteger,System.Int32,System.Int32)">
            <summary>
            Base constructor with certainty.
            </summary>
            <param name="publicExponent">The public exponent to use.</param>
            <param name="keySize">The key size (in bits)</param>
            <param name="certainty">Certainty to use for prime number calculation.</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsRsa.KeyPairGenerator">
            <summary>
            Key pair generator for RSA. Create one these via CryptoServicesRegistrar.CreateGenerator() using the KeyGenerationParameters
            object as the key.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Fips.FipsSecureRandom.BlockSize">
            <summary>
            Return the block size of the underlying DRBG.
            </summary>
            <value>Number of bits produced each cycle.</value>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Fips.FipsSecureRandom.SecurityStrength">
            <summary>
            Return the security strength of the DRBG.
            </summary>
            <value>The security strength (in bits) of the DRBG.</value>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Fips.FipsSecureRandom.Reseed">
            <summary>
            Force a reseed of this instance.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Fips.FipsSecureRandom.Reseed(System.Byte[])">
            <summary>
            Force a reseed with additional input.
            </summary>
            <param name="additionalInput">Additional input to be used in conjunction with reseed.</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsShs">
            <summary>
            Source class for implementations of FIPS approved secure hash algorithms.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsShs.Sha1">
            <summary>
            The SHA-1 Digest marker.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsShs.Sha224">
            <summary>
            The SHA-224 Digest marker.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsShs.Sha256">
            <summary>
            The SHA-256 Digest marker.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsShs.Sha384">
            <summary>
            The SHA-384 Digest marker.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsShs.Sha512">
            <summary>
            The SHA-512 Digest marker.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsShs.Sha512_224">
            <summary>
            The SHA512(224) Digest marker.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsShs.Sha512_256">
            <summary>
            The SHA512(256) Digest marker.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsShs.Sha3_224">
            <summary>
            The SHA3-224 Digest marker.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsShs.Sha3_256">
            <summary>
            The SHA3-256 Digest marker.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsShs.Sha3_384">
            <summary>
            The SHA3-384 Digest marker.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsShs.Sha3_512">
            <summary>
            The SHA3-512 Digest marker.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsShs.Sha1HMac">
            <summary>
            The SHA-1 HMAC parameters source.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsShs.Sha224HMac">
            <summary>
            The SHA-224 HMAC parameters source.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsShs.Sha256HMac">
            <summary>
            The SHA-256 HMAC parameters source.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsShs.Sha384HMac">
            <summary>
            The SHA-384 HMAC parameters source.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsShs.Sha512HMac">
            <summary>
            The SHA-512 HMAC parameters source.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsShs.Sha512_224HMac">
            <summary>
            The SHA-512(224) HMAC parameters source.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsShs.Sha512_256HMac">
            <summary>
            The SHA-512(256) HMAC parameters source.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsShs.Shake128">
            <summary>
            The SHAKE128 parameters source.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsShs.Shake256">
            <summary>
            The SHAKE256 parameters source.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsShs.Parameters">
            <summary>
            Generic digest parameters.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsShs.XofParameters">
            <summary>
            Generic eXpandable output function (XOF) parameters.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsShs.AuthenticationParameters">
            <summary>
            Parameters for HMAC modes.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Fips.FipsShs.AuthenticationParameters.MacSizeInBits">
            <summary>
            Return the size of the MAC these parameters are for.
            </summary>
            <value>The MAC size in bits.</value>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Fips.FipsShs.AuthenticationParameters.WithMacSize(System.Int32)">
            <summary>
            Create a new parameter set with the specified MAC size associated with it.
            </summary>
            <returns>The new parameter set.</returns>
            <param name="macSizeInBits">Mac size in bits.</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsShs.Key">
            <summary>
            HMAC key class.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsTripleDes">
            <summary>
            Source class for FIPS approved implementations of Triple-DES based algorithms.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsTripleDes.Alg">
            <summary>
            Raw Triple-DES algorithm, can be used for creating general purpose Triple-DES keys.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsTripleDes.Alg112">
            <summary>
            Algorithm tag for Triple-DES with 128 bit (112 effective bits) key.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsTripleDes.Alg168">
            <summary>
            Algorithm tag for Triple-DES with 192 bit (168 effective bits) key.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsTripleDes.KeyGen112">
            <summary>
            Parameters to use for creating a 112 bit Triple-DES key generator.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsTripleDes.KeyGen168">
            <summary>
            Parameters to use for creating a 168 bit Triple-DES key generator.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsTripleDes.Ecb">
            <summary>
            Triple-DES in electronic code book (ECB) mode.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsTripleDes.Cbc">
            <summary>
            Triple-DES in cipher block chaining (CBC) mode.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsTripleDes.Cfb8">
            <summary>
            Triple-DES in cipher feedback (CFB) mode, 8 bit block size.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsTripleDes.Cfb64">
            <summary>
            Triple-DES in cipher feedback (CFB) mode, 128 bit block size.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsTripleDes.Ofb">
            <summary>
            Triple-DES in output feedback (OFB) mode - 128 bit block size.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsTripleDes.Ctr">
            <summary>
             Triple-DES in counter (CTR) mode.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsTripleDes.CbcWithCS1">
            <summary>
             Triple-DES in CBC mode with cipher text stealing type CS1.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsTripleDes.CbcWithCS2">
            <summary>
             Triple-DES in CBC mode with cipher text stealing type CS2.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsTripleDes.CbcWithCS3">
            <summary>
             Triple-DES in CBC mode with cipher text stealing type CS3.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsTripleDes.TKW">
            <summary>
            Triple-DES as a FIPS SP800-38F/RFC 3394 key wrapper.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Fips.FipsTripleDes.CMac">
            <summary>
            Triple-DES cipher-based CMAC algorithm.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsTripleDes.Key">
            <summary>
            Triple-DES key class.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsTripleDes.KeyGenerationParameters">
            <summary>
            Triple-DES key generation parameters base class.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsTripleDes.KeyGenerator">
            <summary>
            Triple-DES key generator.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsTripleDes.Parameters">
            <summary>
            Base class for simple Triple-DES parameters.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsTripleDes.ParametersWithIV">
            <summary>
            Base class for Triple-DES parameters requiring an initialization vector.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsTripleDes.AuthenticationParameters">
            <summary>
            Base authentication parameters class for use with MACs.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.FipsTripleDes.WrapParameters">
            <summary>
            Base class for Triple-DES key wrap parameters.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Fips.HashSP800Drbg.#ctor(Org.BouncyCastle.Crypto.Internal.IDigest,System.Int32,Org.BouncyCastle.Crypto.IEntropySource,System.Byte[],System.Byte[])">
            Construct a SP800-90A Hash DRBG.
            <p>
            Minimum entropy requirement is the security strength requested.
            </p>
            @param digest  source digest to use for DRB stream.
            @param securityStrength security strength required (in bits)
            @param entropySource source of entropy to use for seeding/reseeding.
            @param personalizationString personalization string to distinguish this DRBG (may be null).
            @param nonce nonce to further distinguish this DRBG (may be null).
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Fips.HashSP800Drbg.BlockSize">
             Return the block size (in bits) of the DRBG.
            
             @return the number of bits produced on each internal round of the DRBG.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Fips.HashSP800Drbg.SecurityStrength">
             Return the security strength of the DRBG.
            
             @return the security strength (in bits) of the DRBG.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Fips.HashSP800Drbg.Generate(System.Byte[],System.Byte[],System.Boolean)">
             Populate a passed in array with random data.
            
             @param output output array for generated bits.
             @param additionalInput additional input to be added to the DRBG in this step.
             @param predictionResistant true if a reseed should be forced, false otherwise.
            
             @return number of bits generated, -1 if a reseed required.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Fips.HashSP800Drbg.Reseed(System.Byte[])">
             Reseed the DRBG.
            
             @param additionalInput additional input to be added to the DRBG in this step.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Fips.HMacSP800Drbg">
            A SP800-90A HMAC DRBG.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Fips.HMacSP800Drbg.#ctor(Org.BouncyCastle.Crypto.Internal.IMac,System.Int32,Org.BouncyCastle.Crypto.IEntropySource,System.Byte[],System.Byte[])">
            Construct a SP800-90A Hash DRBG.
            <p>
            Minimum entropy requirement is the security strength requested.
            </p>
            @param hMac Hash MAC to base the DRBG on.
            @param securityStrength security strength required (in bits)
            @param entropySource source of entropy to use for seeding/reseeding.
            @param personalizationString personalization string to distinguish this DRBG (may be null).
            @param nonce nonce to further distinguish this DRBG (may be null).
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Fips.HMacSP800Drbg.BlockSize">
             Return the block size (in bits) of the DRBG.
            
             @return the number of bits produced on each round of the DRBG.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Fips.HMacSP800Drbg.SecurityStrength">
             Return the security strength of the DRBG.
            
             @return the security strength (in bits) of the DRBG.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Fips.HMacSP800Drbg.Generate(System.Byte[],System.Byte[],System.Boolean)">
             Populate a passed in array with random data.
            
             @param output output array for generated bits.
             @param additionalInput additional input to be added to the DRBG in this step.
             @param predictionResistant true if a reseed should be forced, false otherwise.
            
             @return number of bits generated, -1 if a reseed required.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Fips.HMacSP800Drbg.Reseed(System.Byte[])">
             Reseed the DRBG.
            
             @param additionalInput additional input to be added to the DRBG in this step.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.Aes">
            <summary>
            Source class for non-approved mode AES based modes and algorithms.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Aes.OpenPgpCfb">
            <summary>
            AES in OpenPGP CFB Mode.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.Aes.ParametersWithIV">
            <summary>
            Base class for general AES parameters requiring an initialization vector.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.Aes.AuthenticationParametersWithIV">
            <summary>
            Base authentication parameters class for use with MACs and AEAD ciphers requiring a nonce or IV.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.Arc4">
            <summary>
            Source class for ARC4/RC4 based algorithms.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Arc4.Alg">
            <summary>
            Raw ARC4/RC4 algorithm, can be used for creating general purpose Camellia keys.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Arc4.KeyGen">
            <summary>
            Parameters to use for creating an ARC4/RC4 key generator (default is 128 bits).
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Arc4.Stream">
            <summary>
            Standard ARC4/RC4 stream mode.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.Arc4.Key">
            <summary>
            ARC4/RC4 key class.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.Arc4.KeyGenerationParameters">
            <summary>
            Base ARC4/RC4 key generation parameters.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.Arc4.KeyGenerator">
            <summary>
            ARC4/RC4 key generator.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.General.Arc4.KeyGenerator.GenerateKey">
            <summary>
            Generate a key.
            </summary>
            <returns>An ARC4 key.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.Arc4.Parameters">
            <summary>
            Base class for stanard ARC4/RC4 mode of operation.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.Camellia">
            <summary>
            Source class for Camellia based algorithms.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Camellia.Alg">
            <summary>
            Raw Camellia algorithm, can be used for creating general purpose Camellia keys.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Camellia.Alg128">
            <summary>
            Algorithm tag for Camellia with 128 bit key.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Camellia.Alg192">
            <summary>
            Algorithm tag for Camellia with 192 bit key.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Camellia.Alg256">
            <summary>
            Algorithm tag for Camellia with 256 bit key.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Camellia.KeyGen128">
            <summary>
            Parameters to use for creating a 128 bit Camellia key generator.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Camellia.KeyGen192">
            <summary>
            Parameters to use for creating a 192 bit Camellia key generator.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Camellia.KeyGen256">
            <summary>
            Parameters to use for creating a 256 bit Camellia key generator.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Camellia.Ecb">
            <summary>
            Camellia in electronic code book (ECB) mode.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Camellia.Cbc">
            <summary>
            Camellia in cipher block chaining (CBC) mode.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Camellia.Cfb8">
            <summary>
             Camellia in cipher feedback (CFB) mode, 8 bit block size.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Camellia.Cfb128">
            <summary>
            Camellia in cipher feedback (CFB) mode, 128 bit block size.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Camellia.Ofb">
            <summary>
            Camellia in output feedback (OFB) mode - 128 bit block size.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Camellia.Ctr">
            <summary>
             Camellia in counter (CTR) mode.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Camellia.CbcWithCS1">
            <summary>
             Camellia in CBC mode with cipher text stealing type CS1.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Camellia.CbcWithCS2">
            <summary>
             Camellia in CBC mode with cipher text stealing type CS2.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Camellia.CbcWithCS3">
            <summary>
             Camellia in CBC mode with cipher text stealing type CS3.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Camellia.Ccm">
            <summary>
             Camellia in counter with CBC-MAC (CCM).
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Camellia.Gcm">
            <summary>
            Camellia in Galois/Counter Mode (GCM).
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Camellia.OpenPgpCfb">
            <summary>
            Camellia in OpenPGP CFB Mode.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Camellia.CMac">
            <summary>
            Camellia cipher-based CMAC algorithm.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Camellia.GMac">
            <summary>
            Camellia cipher-based GMAC algorithm.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Camellia.KW">
            <summary>
            Camellia as a General SP800-38F/RFC 3657 key wrapper.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Camellia.KWP">
            <summary>
            Camellia as a General SP800-38F key wrapper with padding.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.Camellia.Key">
            <summary>
            Camellia key class.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.Camellia.KeyGenerationParameters">
            <summary>
            Camellia key generation parameters base class.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.Camellia.KeyGenerator">
            <summary>
            Camellia key generator.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.General.Camellia.KeyGenerator.GenerateKey">
            <summary>
            Generate a key.
            </summary>
            <returns>A Camellia key.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.Camellia.Parameters">
            <summary>
            Base class for simple Camellia parameters.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.Camellia.ParametersWithIV">
            <summary>
            Base class for Camellia parameters requiring an initialization vector.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.Camellia.AuthenticationParameters">
            <summary>
            Base authentication parameters class for use with MACs.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.Camellia.AuthenticationParametersWithIV">
            <summary>
            Base authentication parameters class for use with MACs and AEAD ciphers requiring a nonce or IV.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.Camellia.WrapParameters">
            <summary>
            Base class for Camellia key wrap parameters.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.ChaCha.EStream">
            <summary>
            ChaCha in eSTREAM mode, as described in the eSTREAM submission, with an 8 byte nonce.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.ChaCha.Ietf">
            <summary>
            ChaCha in IETF mode, as described in RFC 7539, with a 12 byte nonce.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.ChaCha.Key">
            <summary>
            ChaCha key class.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.ChaCha.KeyGenerationParameters">
            <summary>
            ChaCha key generation parameters base class.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.ChaCha.KeyGenerator">
            <summary>
            ChaCha key generator.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.General.ChaCha.KeyGenerator.GenerateKey">
            <summary>
            Generate a key.
            </summary>
            <returns>A ChaCha key.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.Dsa">
            <summary>
            Source class for non-FIPS implementations of DSA based algorithms.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.EC">
            <summary>
            Source class for non-FIPS implementations of Elliptic Curve (EC) based algorithms.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.ElGamal.WrapOaep">
            <summary>
             ElGamal OAEP key wrap algorithm parameter source - default is SHA-384
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.ElGamal.WrapPkcs1v15">
            <summary>
             ElGamal PKCS#1.5 key wrap algorithm parameter source.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.ElGamal.OaepWrapParameters">
            <summary>
            OAEP key wrap parameters base class.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.ElGamal.Pkcs1v15WrapParameters">
            <summary>
            Parameters for use with PKCS#1 v1.5 formatted key wrapping/unwrapping and encryption/decryption.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.ElGamal.KeyGenerationParameters">
            <summary>
            ElGamal key pair generation parameters.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.General.ElGamal.KeyGenerationParameters.#ctor(Org.BouncyCastle.Crypto.Asymmetric.DHDomainParameters)">
             Base constructor for specific domain parameters.
            
             @param domainParameters the DH domain parameters.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.General.ElGamal.KeyGenerationParameters.#ctor(Org.BouncyCastle.Crypto.Parameters.Parameters{Org.BouncyCastle.Crypto.General.GeneralAlgorithm},Org.BouncyCastle.Crypto.Asymmetric.DHDomainParameters)">
             Constructor for specifying the ElGamal algorithm explicitly.
            
             @param parameters the particular parameter set to generate keys for.
             @param domainParameters DH domain parameters representing the curve any generated keys will be for.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.ElGamal.KeyPairGenerator">
            <summary>
            ElGamal key pair generator class.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.NewHope">
            <summary>
            Source class for the PQC key-exchange algorithm NewHope
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.NewHope.Alg">
            <summary>
            Raw NewHope algorithm marker.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.NewHope.Sha3_256">
            <summary>
            Perform key exchange calculations using SHA3_256 to process the result.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.NewHope.KeyGen">
            <summary>
            Service generator handle for NewHope key pair generation.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.NewHope.Parameters">
            <summary>
            Base class for the NewHope key exchange parameters.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.NewHope.KeyGenerationParameters">
            <summary>
            Parameters for NewHope key pair generation.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.NewHope.KeyPairGenerator">
            <summary>
            Base class for NewHope key pair generation.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.Pbkd">
            <summary>
             Source class for implementations of Password-Based Key Derivation Algorithms
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Pbkd.ALGORITHM_PKCS12">
            <summary>
            Algorithm ID for PKCS#12
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Pbkd.ALGORITHM_OPENSSL">
            <summary>
            Algorithm ID for OpenSSL
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Pbkd.Pkcs12">
            <summary>
            PKCS#12 PBE algorithm parameter source - default PRF is SHA-1
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Pbkd.OpenSsl">
            <summary>
            OpenSSL PBE algorithm parameter source - PRF is MD5
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.Pbkd.Pkcs12BuilderService">
            <summary>
            PKCS12 password based key deriver builder service.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.Pbkd.OpenSslBuilderService">
            <summary>
            OpenSSL password based key deriver builder service.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.Pbkd.PbkdParameters">
            <summary>
            General PBKD parameters.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.Pbkd.OpenSslParameters">
            <summary>
            OpenSSL PBKD parameters.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.Poly1305">
            <summary>
            Source class for Poly1305 MAC calculators.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Poly1305.Alg">
            <summary>
            Raw Poly1305 algorithm, can be used for creating general purpose Poly1305 keys.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Poly1305.KeyGen256">
            <summary>
            Parameters to use for creating a 256 bit Poly1305 key generator.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Poly1305.Mac">
            <summary>
            Standard Poly1305 MAC mode.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.Poly1305.AuthenticationParameters">
            <summary>
            Base authentication parameters class for use the Poly1305 MAC.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.General.Poly1305.AuthenticationParameters.MacSizeInBits">
            <summary>
            Return the size of the MAC these parameters are for.
            </summary>
            <value>The MAC size in bits.</value>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.General.Poly1305.AuthenticationParameters.WithMacSize(System.Int32)">
            <summary>
            Create a new parameter set with the specified MAC size associated with it.
            </summary>
            <returns>The new parameter set.</returns>
            <param name="macSizeInBits">Mac size in bits.</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.Poly1305.Key">
            <summary>
            Poly1305 key class.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.Poly1305.KeyGenerationParameters">
            <summary>
            Poly1305 key generation parameters base class.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.Poly1305.KeyGenerator">
            <summary>
            Poly1305 key generator.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.General.Poly1305.KeyGenerator.GenerateKey">
            <summary>
            Generate a key.
            </summary>
            <returns>A Poly1305 key.</returns>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Rsa.WrapPkcs1v15">
            <summary>
             RSA PKCS#1.5 key wrap algorithm parameter source.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.Rsa.Pkcs1v15WrapParameters">
            <summary>
            Parameters for use with PKCS#1 v1.5 formatted key wrapping/unwrapping and encryption/decryption.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.Seed">
            <summary>
            Source class for SEED based algorithms.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Seed.Alg">
            <summary>
            Raw SEED algorithm, can be used for creating general purpose SEED keys.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Seed.KeyGen128">
            <summary>
            Parameters to use for creating a 128 bit SEED key generator.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Seed.Ecb">
            <summary>
            SEED in electronic code book (ECB) mode.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Seed.Cbc">
            <summary>
            SEED in cipher block chaining (CBC) mode.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Seed.Cfb8">
            <summary>
             SEED in cipher feedback (CFB) mode, 8 bit block size.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Seed.Cfb128">
            <summary>
            SEED in cipher feedback (CFB) mode, 128 bit block size.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Seed.Ofb">
            <summary>
            SEED in output feedback (OFB) mode - 128 bit block size.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Seed.Ctr">
            <summary>
             SEED in counter (CTR) mode.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Seed.CbcWithCS1">
            <summary>
             SEED in CBC mode with cipher text stealing type CS1.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Seed.CbcWithCS2">
            <summary>
             SEED in CBC mode with cipher text stealing type CS2.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Seed.CbcWithCS3">
            <summary>
             SEED in CBC mode with cipher text stealing type CS3.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Seed.Ccm">
            <summary>
             SEED in counter with CBC-MAC (CCM).
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Seed.Gcm">
            <summary>
            SEED in Galois/Counter Mode (GCM).
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Seed.CMac">
            <summary>
            SEED cipher-based CMAC algorithm.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Seed.GMac">
            <summary>
            SEED cipher-based GMAC algorithm.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Seed.KW">
            <summary>
            SEED as a General SP800-38F/RFC 4010 key wrapper.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Seed.KWP">
            <summary>
            SEED as a General SP800-38F key wrapper with padding.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.Seed.Key">
            <summary>
            SEED key class.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.Seed.KeyGenerationParameters">
            <summary>
            SEED key generation parameters base class.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.Seed.KeyGenerator">
            <summary>
            SEED key generator.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.General.Seed.KeyGenerator.GenerateKey">
            <summary>
            Generate a key.
            </summary>
            <returns>A SEED key.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.Seed.Parameters">
            <summary>
            Base class for simple SEED parameters.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.Seed.ParametersWithIV">
            <summary>
            Base class for SEED parameters requiring an initialization vector.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.Seed.AuthenticationParameters">
            <summary>
            Base authentication parameters class for use with MACs.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.Seed.AuthenticationParametersWithIV">
            <summary>
            Base authentication parameters class for use with MACs and AEAD ciphers requiring a nonce or IV.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.Seed.WrapParameters">
            <summary>
            Base class for SEED key wrap parameters.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.Serpent">
            <summary>
            Source class for Serpent based algorithms.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Serpent.Alg">
            <summary>
            Raw Serpent algorithm, can be used for creating general purpose Serpent keys.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Serpent.Alg128">
            <summary>
            Algorithm tag for Serpent with 128 bit key.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Serpent.Alg192">
            <summary>
            Algorithm tag for Serpent with 192 bit key.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Serpent.Alg256">
            <summary>
            Algorithm tag for Serpent with 256 bit key.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Serpent.KeyGen128">
            <summary>
            Parameters to use for creating a 128 bit Serpent key generator.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Serpent.KeyGen192">
            <summary>
            Parameters to use for creating a 192 bit Serpent key generator.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Serpent.KeyGen256">
            <summary>
            Parameters to use for creating a 256 bit Serpent key generator.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Serpent.Ecb">
            <summary>
            Serpent in electronic code book (ECB) mode.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Serpent.Cbc">
            <summary>
            Serpent in cipher block chaining (CBC) mode.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Serpent.Cfb8">
            <summary>
             Serpent in cipher feedback (CFB) mode, 8 bit block size.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Serpent.Cfb128">
            <summary>
            Serpent in cipher feedback (CFB) mode, 128 bit block size.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Serpent.Ofb">
            <summary>
            Serpent in output feedback (OFB) mode - 128 bit block size.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Serpent.Ctr">
            <summary>
             Serpent in counter (CTR) mode.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Serpent.CbcWithCS1">
            <summary>
             Serpent in CBC mode with cipher text stealing type CS1.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Serpent.CbcWithCS2">
            <summary>
             Serpent in CBC mode with cipher text stealing type CS2.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Serpent.CbcWithCS3">
            <summary>
             Serpent in CBC mode with cipher text stealing type CS3.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Serpent.Ccm">
            <summary>
             Serpent in counter with CBC-MAC (CCM).
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Serpent.Gcm">
            <summary>
            Serpent in Galois/Counter Mode (GCM).
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Serpent.CMac">
            <summary>
            Serpent cipher-based CMAC algorithm.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Serpent.GMac">
            <summary>
            Serpent cipher-based GMAC algorithm.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Serpent.KW">
            <summary>
            Serpent as a General SP800-38F key wrapper.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Serpent.KWP">
            <summary>
            Serpent as a General SP800-38F key wrapper with padding.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.Serpent.Key">
            <summary>
            Serpent key class.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.Serpent.KeyGenerationParameters">
            <summary>
            Serpent key generation parameters base class.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.Serpent.KeyGenerator">
            <summary>
            Serpent key generator.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.General.Serpent.KeyGenerator.GenerateKey">
            <summary>
            Generate a key.
            </summary>
            <returns>A Serpent key.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.Serpent.Parameters">
            <summary>
            Base class for simple Serpent parameters.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.Serpent.ParametersWithIV">
            <summary>
            Base class for Serpent parameters requiring an initialization vector.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.Serpent.AuthenticationParameters">
            <summary>
            Base authentication parameters class for use with MACs.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.Serpent.AuthenticationParametersWithIV">
            <summary>
            Base authentication parameters class for use with MACs and AEAD ciphers requiring a nonce or IV.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.Serpent.WrapParameters">
            <summary>
            Base class for Serpent key wrap parameters.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.Sphincs">
            <summary>
            Source class for the PQC signature algorithm SPHINCS-256
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Sphincs.Alg">
            <summary>
            Raw SPHINCS-256 algorithm marker.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.Sphincs.Sphincs256">
            <summary>
            Base parameters object for SPHINCS-256 - default is SHA-512.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.Sphincs.KeyGenerationParameters">
            <summary>
            Parameters for SPHINCS-256 key pair generation.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.General.Sphincs.KeyGenerationParameters.#ctor">
            <summary>
            Constructor for the default algorithm ID.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.General.Sphincs.KeyGenerationParameters.#ctor(Org.BouncyCastle.Crypto.DigestAlgorithm)">
            <summary>
            Constructor specifying a particular tree digest.
            </summary>
            <param name="treeDigest">Tree digest to use for key and eventual signature construction</param>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.General.Sphincs.KeyGenerationParameters.TreeDigestAlgorithm">
            <summary>
            Return the digest algorithm used to construct the tree for the public key.
            </summary>
            <value>The key digest algorithm for tree construction.</value>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.Sphincs.KeyPairGenerator">
            <summary>
            Key pair generator for SPHINCS-256. Create one these via CryptoServicesRegistrar.CreateGenerator() using the KeyGenerationParameters
            object as the key.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.General.Sphincs.KeyPairGenerator.#ctor(Org.BouncyCastle.Crypto.General.Sphincs.KeyGenerationParameters,Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Construct a key pair generator for SPHINCS-256 keys,
            </summary>
            <param name="keyGenParameters">Domain parameters and algorithm for the generated key.</param>
            <param name="random">A source of randomness for calculating the private value.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.General.Sphincs.KeyPairGenerator.GenerateKeyPair">
            <summary>
            Generate a new SPHINCS-256 key pair.
            </summary>
            <returns>A new AsymmetricKeyPair containing an SPHINCS-256 key pair.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.TripleDes">
            <summary>
            Source class for non-approved mode Triple-DES based modes and algorithms.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.General.TripleDes.OpenPgpCfb">
            <summary>
            Triple-DES in OpenPGP CFB Mode.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.TripleDes.ParametersWithIV">
            <summary>
            Base class for general Triple-DES parameters requiring an initialization vector.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.General.TripleDes.AuthenticationParametersWithIV">
            <summary>
            Base authentication parameters class for use with MACs and AEAD ciphers requiring a nonce or IV.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IAeadBlockCipherService">
            <summary>
            General service interface for block ciphers that can be used with AEAD algorithms.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IAeadCipher">
            <summary>
            Extension of cipher which provides for the processing of AAD in addition to the plain text/cipher text.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IAeadCipher.AadStream">
            <summary>
            Gets the stream for reading/writing data to be processed.
            </summary>
            <value>The stream associated representing the AAD for this cipher.</value>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IAeadCipher.MacSizeInBits">
            <summary>
            Gets the size of the MAC.
            </summary>
            <value>The size of the MAC.</value>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IAeadCipher.GetMac">
            <summary>
            Return the MAC calculated processing the data given to this cipher.
            </summary>
            <returns>The AEAD cipher's MAC.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IAeadCipherBuilder`1">
            <summary>
            Base interface for AEAD cipher builders.
            </summary>
            <typeparam name="A">algorithm details type parameter.</typeparam>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IAeadCipherBuilder`1.BuildAeadCipher(Org.BouncyCastle.Crypto.AeadUsage,System.IO.Stream)">
            <summary>
            Build a cipher for the algorithm and parameter details in this builder.
            </summary>
            <param name="usage">The manner in which associated data will be introduced.</param>
            <param name="stream">The stream to write/read any encrypted/decrypted data.</param>
            <returns></returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IAeadCipherService">
            <summary>
            Service interface for AEAD ciphers.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IAeadCipherService.CreateAeadDecryptorBuilder``1(``0)">
            <summary>
            Return an AEAD cipher builder which will build decrypting ciphers.
            </summary>
            <typeparam name="A">The type of the details for AEAD cipher to be produced.</typeparam>
            <param name="algorithmDetails">The algorithm and parameter details for the type of AEAD cipher to be produced.</param>
            <returns></returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IAeadCipherService.CreateAeadEncryptorBuilder``1(``0)">
            <summary>
            Return an AEAD cipher builder which will build encrypting ciphers.
            </summary>
            <typeparam name="A">The type of the details for AEAD cipher to be produced.</typeparam>
            <param name="algorithmDetails">The algorithm and parameter details for the type of AEAD cipher to be produced.</param>
            <returns></returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IAeadDecryptorBuilderProvider`1">
            <summary>
            Interface for a provider of AEAD decryptor builders.
            </summary>
            <typeparam name="A">The algorithm/parameter details type the builders are for.</typeparam>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IAeadDecryptorBuilderProvider`1.CreateAeadDecryptorBuilder(`0)">
            <summary>
            Create an AEAD decryptor builder for the given details.
            </summary>
            <param name="algorithmDetails">The algorithm/parameter details type the builder is for.</param>
            <returns>An AEAD cipher builder which produces decryptors for the given details.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IAeadEncryptorBuilderProvider`1">
            <summary>
            Interface for a provider of AEAD encryptor builders.
            </summary>
            <typeparam name="A">The algorithm/parameter details type the builders are for.</typeparam>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IAeadEncryptorBuilderProvider`1.CreateAeadEncryptorBuilder(`0)">
            <summary>
            Create an AEAD encryptor builder for the given details.
            </summary>
            <param name="algorithmDetails">The algorithm/parameter details type the builder is for.</param>
            <returns>An AEAD cipher builder which produces encryptors for the given details.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IAgreementCalculator`1">
            <summary>
            Base interface for a calculator used in key agreement.
            </summary>
            <typeparam name="A">The algorithm/parameter details type the agreement calculators are for.</typeparam>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IAgreementCalculator`1.AlgorithmDetails">
            <summary>The algorithm details object for calculators made by this factory.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IAgreementCalculator`1.Calculate(Org.BouncyCastle.Crypto.IAsymmetricPublicKey)">
            <summary>
            Calculate the agreement using the passed in public key.
            </summary>
            <param name="publicKey">The public key of the other party.</param>
            <returns>A byte array containing the agreed value.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IAgreementCalculatorProvider`1">
            <summary>
            Interface for a provider of key agreement calculators.
            </summary>
            <typeparam name="A">The algorithm/parameter details type the key agreement calculators are for.</typeparam>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IAgreementCalculatorProvider`1.CreateAgreementCalculator(`0)">
            <summary>
            Return a key agreement calculator as described in the passed in algorithm details object.
            </summary>
            <param name="algorithmDetails">The details of the key agreement algorithm is required.</param>
            <returns>A new agreement.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IAgreementCalculatorService">
            <summary>
            Base interface for a service to support the creation of key agreement calculators.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IAgreementCalculatorService.CreateAgreementCalculator``1(``0)">
            <summary>
            Return a key agreement calculator as described in the passed in algorithm details object.
            </summary>
            <typeparam name="A">The type of the details for the key agreement algorithm to be produced.</typeparam>
            <param name="algorithmDetails">The details of the key agreement algorithm is required.</param>
            <returns>A new agreement.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IAsymmetricKey">
            <summary>
            Base interface for Public/Private keys.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IAsymmetricKey.GetEncoded">
            <summary>
            Return an ASN.1 encoding of the key wrapped in a PrivateKeyInfo or a SubjectPublicKeyInfo structure.
            </summary>
            <returns>An encoding of a PrivateKeyInfo or a SubjectPublicKeyInfo structure.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IAsymmetricKeyPairGenerator`3">
            <summary>
            Base interface for a generator of public/private key pairs.
            </summary>
            <typeparam name="TParam">Base parameter type.</typeparam>
            <typeparam name="TPublic">Type of the public key in the key pair.</typeparam>
            <typeparam name="TPrivate">Type of the private key in the key pair.</typeparam>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IAsymmetricKeyPairGenerator`3.Parameters">
            <summary>
            Return the parameters associated with this key pair generator.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IAsymmetricKeyPairGenerator`3.GenerateKeyPair">
            <summary>
            Generate a new key pair in accordance with the generator's parameter set.
            </summary>
            <returns>A new key pair.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IAsymmetricPrivateKey">
            <summary>
            Marker interface for private keys.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IAsymmetricPublicKey">
            <summary>
            Marker interface for public keys.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IAuthenticationParameters`2">
            <summary>
            Base interface for authentication parameters (used with MAC/HMAC algorithms).
            </summary>
            <typeparam name="TParam">Underlying type implementing the interface.</typeparam>
            <typeparam name="TAlg">The algorithm marker type.</typeparam>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IAuthenticationParameters`2.MacSizeInBits">
            <summary>
            Return the size of the MAC these parameters are for.
            </summary>
            <value>The MAC size in bits.</value>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IAuthenticationParameters`2.WithMacSize(System.Int32)">
            <summary>
            Create a new parameter set with the specified MAC size associated with it.
            </summary>
            <returns>The new parameter set.</returns>
            <param name="macSizeInBits">Mac size in bits.</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IAuthenticationParametersWithIV`2">
            <summary>
            Base interface for authentication parameters with IVs (used with AEAD algorithms).
            </summary>
            <typeparam name="TParam">Underlying type implementing the interface.</typeparam>
            <typeparam name="TAlg">The algorithm marker type.</typeparam>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IAuthenticationParametersWithIV`2.WithIV(Org.BouncyCastle.Security.SecureRandom,System.Int32)">
            <summary>
            Return an implementation of the parameters with an IV constructed from the passed in SecureRandom of length ivLen.
            </summary>
            <returns>A new set of parameters.</returns>
            <param name="random">Source of randomness for iv (nonce)</param>
            <param name="ivLen">Length of the iv (nonce) in bytes to use with the algorithm.</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IBlockCipher">
            <summary>
            Base interface for a cipher that requires block aligned input.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IBlockCipher.BlockSize">
            <summary>
            The block size for this cipher.
            </summary>
            <value>The size of the block.</value>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBlockCipher.GetMaxOutputSize(System.Int32)">
            <summary>
            Return the size of the output buffer required for a Write() plus a
            close() with the write() being passed inputLen bytes.
            <para>
            The returned size may be dependent on the initialisation of this cipher
            and may not be accurate once subsequent input data is processed as the cipher may
            add, add or remove padding, as it sees fit.
            </para>
            </summary>
            <returns>The space required to accommodate a call to processBytes and doFinal with inputLen bytes of input.</returns>
            <param name="inputLen">The length of the expected input.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBlockCipher.GetUpdateOutputSize(System.Int32)">
            <summary>
            Return the size of the output buffer required for a write() with the write() being
            passed inputLen bytes and just updating the cipher output.
            </summary>
            <returns>The space required to accommodate a call to processBytes with inputLen bytes of input.</returns>
            <param name="inputLen">The length of the expected input.</param>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IBlockCipher.Stream">
            <summary>
            Gets the stream for reading/writing data processed/to be processed.
            </summary>
            <value>The stream associated with this block cipher.</value>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IBlockCipherBuilder`1">
            <summary>
            Base interface for block cipher builders.
            </summary>
            <typeparam name="A">algorithm details type parameter.</typeparam>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IBlockCipherBuilder`1.AlgorithmDetails">
            <summary>
            Return the algorithm and parameter details associated with any block cipher built.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IBlockCipherBuilder`1.BlockSize">
            <summary>
            Return the blocksize for the underlying block cipher.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBlockCipherBuilder`1.GetMaxOutputSize(System.Int32)">
            <summary>
            Return the maximum output size that a given input will produce.
            </summary>
            <param name="inputLen">the length of the expected input.</param>
            <returns>The maximum possible output size that can produced for the expected input length.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBlockCipherBuilder`1.BuildPaddedCipher(System.IO.Stream,Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding)">
            <summary>
            Build a cipher that operates on the passed in stream and uses the passed in padding.
            </summary>
            <param name="stream">The stream to write/read any encrypted/decrypted data.</param>
            <param name="padding">The padding to use with the data processed.</param>
            <returns>A cipher based around the given stream and padding</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBlockCipherBuilder`1.BuildBlockCipher(System.IO.Stream)">
            <summary>
            Build a block cipher that operates on the passed in stream.
            </summary>
            <param name="stream">The stream to write/read any encrypted/decrypted data.</param>
            <returns>A cipher based around the given stream.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IBlockCipherService">
            <summary>
            Service interface for block ciphers.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBlockCipherService.CreateBlockDecryptorBuilder``1(``0)">
            <summary>
            Return a block cipher builder for decrypting block ciphers.
            </summary>
            <typeparam name="A">The type of the details for the block cipher to be produced.</typeparam>
            <param name="algorithmDetails">The algorithm and parameter details for the type of block cipher to be produced.</param>
            <returns>A builder for decrypting block ciphers for the passed in details.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBlockCipherService.CreateBlockEncryptorBuilder``1(``0)">
            <summary>
            Return a block cipher builder for encrypting block ciphers.
            </summary>
            <typeparam name="A">The type of the details for the block cipher to be produced.</typeparam>
            <param name="algorithmDetails">The algorithm and parameter details for the type of block cipher to be produced.</param>
            <returns>A builder for encrypting block ciphers for the passed in details.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBlockCipherService.CreateDecryptorBuilder``1(``0)">
            <summary>
            Return a block cipher builder for decrypting ciphers.
            </summary>
            <typeparam name="A">The type of the details for the cipher to be produced.</typeparam>
            <param name="algorithmDetails">The algorithm and parameter details for the type of cipher to be produced.</param>
            <returns>A builder for decrypting ciphers for the passed in details.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBlockCipherService.CreateEncryptorBuilder``1(``0)">
            <summary>
            Return a block cipher builder for encrypting ciphers.
            </summary>
            <typeparam name="A">The type of the details for the cipher to be produced.</typeparam>
            <param name="algorithmDetails">The algorithm and parameter details for the type of cipher to be produced.</param>
            <returns>A builder for encrypting ciphers for the passed in details.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBlockCipherService.CreateKeyWrapper``1(``0)">
            <summary>
            Return a key wrapper.
            </summary>
            <typeparam name="A">The type of the details for the key wrapper to be produced.</typeparam>
            <param name="algorithmDetails">The algorithm and parameter details for the type of key wrapper to be produced.</param>
            <returns>A key wrapper for the passed in details.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBlockCipherService.CreateKeyUnwrapper``1(``0)">
            <summary>
            Return a key unwrapper.
            </summary>
            <typeparam name="A">The type of the details for the key unwrapper to be produced.</typeparam>
            <param name="algorithmDetails">The algorithm and parameter details for the type of key unwrapper to be produced.</param>
            <returns>A key unwrapper for the passed in details.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IBlockDecryptorBuilderProvider`1">
            <summary>
            Interface for a provider of block cipher decryptor builders.
            </summary>
            <typeparam name="A">The algorithm/parameter details type the builders are for.</typeparam>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBlockDecryptorBuilderProvider`1.CreateBlockDecryptorBuilder(`0)">
            <summary>
            Create a block decryptor builder for the given details.
            </summary>
            <param name="algorithmDetails">The algorithm/parameter details type the builder is for.</param>
            <returns>A block cipher builder which produces decryptors for the given details.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IBlockEncryptorBuilderProvider`1">
            <summary>
            Interface for a provider of block cipher encryptor builders.
            </summary>
            <typeparam name="A">The algorithm/parameter details type the builders are for.</typeparam>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBlockEncryptorBuilderProvider`1.CreateBlockEncryptorBuilder(`0)">
            <summary>
            Create a block encryptor builder for the given details.
            </summary>
            <param name="algorithmDetails">The algorithm/parameter details type the builder is for.</param>
            <returns>A block cipher builder which produces encryptors for the given details.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IBlockResult">
            <summary>
            Operators that reduce their input to a single block return an object
            of this type.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IBlockResult.Length">
            <summary>
            Return the number of bytes in the result
            </summary>
            <value>The length of the result in bytes.</value>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBlockResult.Collect">
            <summary>
            Return the final result of the operation. Note: this a reference, clearing it will
            have the same effect as clearing the object.
            </summary>
            <returns>A block of bytes, representing the result of an operation.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBlockResult.Collect(System.Byte[],System.Int32)">
            <summary>
            Store the final result of the operation by copying it into the destination array. Note:
            this has the effect of clearing the object.
            </summary>
            <returns>The number of bytes copied into destination.</returns>
            <param name="destination">The byte array to copy the result into.</param>
            <param name="offset">The offset into destination to start copying the result at.</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IBlockResultWithDigest">
            <summary>
            Return type for operators that produce a block of data and an associated message digest.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBlockResultWithDigest.CollectDigest">
            <summary>
            Return the digest associated with the final result of the operation. Note: this a reference, clearing it will
            have the same effect as clearing the object.
            </summary>
            <returns>A digest associated with the result of an operation.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBlockResultWithDigest.CollectDigest(System.Byte[],System.Int32)">
            <summary>
            Store the digest associated with the final result of the operation by copying it into the destination array. Note:
            this has the effect of clearing the object.
            </summary>
            <returns>The number of bytes copied into destination.</returns>
            <param name="destination">The byte array to copy the digest into.</param>
            <param name="offset">The offset into destination to start copying the digest at.</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IBlockResultWithRecoveredMessage">
            <summary>
            Return type for operators that produce a block of data and an associated recovered message.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBlockResultWithRecoveredMessage.CollectRecoveredMessage">
            <summary>
            Return the recovered message associated with this result.
            </summary>
            <returns>a recovered message object.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.ICharToByteConverter">
            <summary>
            Interface for a converter that produces a byte encoding for a char array.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.ICharToByteConverter.Type">
            <summary>
            Return the type of the conversion.
            </summary>
            <value>The type name for the conversion.</value>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ICharToByteConverter.Convert(System.Char[])">
            <summary>
            Return a byte encoded representation of the passed in char array.
            </summary>
            <param name="str">The char array to convert</param>
            <returns>A byte encoding of str.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.ICipher">
            <summary>
            Base interface for a ciphers that do not require data to be block aligned.
            <para>
            Note: In cases where the underlying algorithm is block based, these ciphers may add or remove padding as needed.
            </para>
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ICipher.GetMaxOutputSize(System.Int32)">
            <summary>
            Return the size of the output buffer required for a Write() plus a
            close() with the write() being passed inputLen bytes.
            <para>
            The returned size may be dependent on the initialisation of this cipher
            and may not be accurate once subsequent input data is processed as the cipher may
            add, add or remove padding, as it sees fit.
            </para>
            </summary>
            <returns>The space required to accommodate a call to processBytes and doFinal with inputLen bytes of input.</returns>
            <param name="inputLen">The length of the expected input.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ICipher.GetUpdateOutputSize(System.Int32)">
            <summary>
            Return the size of the output buffer required for a write() with the write() being
            passed inputLen bytes and just updating the cipher output.
            </summary>
            <returns>The space required to accommodate a call to processBytes with inputLen bytes of input.</returns>
            <param name="inputLen">The length of the expected input.</param>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.ICipher.Stream">
            <summary>
            Gets the stream for reading/writing data processed/to be processed.
            </summary>
            <value>The stream associated with this cipher.</value>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.ICipherBuilder`1">
            <summary>
            Base interface for cipher builders.
            </summary>
            <typeparam name="A">algorithm details type parameter.</typeparam>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.ICipherBuilder`1.AlgorithmDetails">
            <summary>
            Return the algorithm and parameter details associated with any cipher built.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ICipherBuilder`1.GetMaxOutputSize(System.Int32)">
            <summary>
            Return the maximum output size that a given input will produce.
            </summary>
            <param name="inputLen">the length of the expected input.</param>
            <returns>The maximum possible output size that can produced for the expected input length.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ICipherBuilder`1.BuildCipher(System.IO.Stream)">
            <summary>
            Build a cipher that operates on the passed in stream.
            </summary>
            <param name="stream">The stream to write/read any encrypted/decrypted data.</param>
            <returns>A cipher based around the given stream.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.ICipherBuilderWithKey`1">
            <summary>
            A cipher builder that can also return the key it was initialized with.
            </summary>
            <typeparam name="A">The algorithm details parameter type.</typeparam>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.ICipherBuilderWithKey`1.Key">
            <summary>
            Return the key we were initialized with.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.ICryptoServiceType`1">
            <summary>
            Marker interface for classes that can be used with CryptoServicesRegistrar.CreateService()
            </summary>
            <typeparam name="S">The service produced.</typeparam>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IGenerationServiceType`1">
            <summary>
            Marker interface for classes that can be used with CryptoServicesRegistrar.CreateGenerator()
            </summary>
            <typeparam name="S">The generator produced.</typeparam>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IFactoryServiceType`1">
            <summary>
            Marker interface for factory classes that can be used with CryptoServicesRegistrar.CreateService()
            </summary>
            <typeparam name="S">The factory service produced.</typeparam>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IBuilderServiceType`1">
            <summary>
            Marker interface for builder classes that can be used with CryptoServicesRegistrar.CreateService()
            </summary>
            <typeparam name="S">The builder service produced.</typeparam>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IDatedVerifierFactory`1">
            <summary>
            Base interface for factories that produce stream-based signature verifiers which are only
            valid within a particular date range.
            </summary>
            <typeparam name="A">Configuration parameters type for the verifiers.</typeparam>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDatedVerifierFactory`1.IsValidAt(System.DateTime)">
            <summary>
            Return true if this verify is valid at the passed in time.
            </summary>
            <param name="dateTime">The date/time to check validity of the verifier at.</param>
            <returns>true if a signature at dateTime is valid, false otherwise.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IDecryptorBuilderProvider`1">
            <summary>
            Interface describing a provider of cipher builders for creating decrypting ciphers.
            </summary>
            <typeparam name="A">The algorithm details/parameter type for the cipher builders produced.</typeparam>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDecryptorBuilderProvider`1.CreateDecryptorBuilder(`0)">
            <summary>
            Return a cipher builder for creating decrypting ciphers.
            </summary>
            <param name="algorithmDetails">The algorithm details/parameters to use to create the final cipher.</param>
            <returns>A new cipher builder.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IDigestFactory`1">
            <summary>
            Base interface for operator factories that create stream-based digest calculators.
            </summary>
            <typeparam name="A">The algorithm details/parameter type for the digest factory.</typeparam>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IDigestFactory`1.AlgorithmDetails">
            <summary>The algorithm details object for calculators made by this factory.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IDigestFactory`1.DigestLength">
            <summary>Return the size of the digest associated with this factory.</summary>
            <returns>The length of the digest produced by this calculators from this factory in bytes.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDigestFactory`1.CreateCalculator">
            <summary>
            Create a stream calculator for the digest associated with this factory. The stream
            calculator is used for the actual operation of entering the data to be digested
            and producing the digest block.
            </summary>
            <returns>A calculator producing an IBlockResult with the final digest in it.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IDigestFactoryProvider`1">
            <summary>
            Interface describing a provider of digest factory objects.
            </summary>
            <typeparam name="A">The algorithm details/parameter type for the digest factories produced.</typeparam>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDigestFactoryProvider`1.CreateDigestFactory(`0)">
            <summary>
            Return a new digest factory for the passed in algorithm details.
            </summary>
            <param name="algorithmDetails">The algorithm details/parameters to use to create the factory.</param>
            <returns>A new digest factory.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IDrbg">
            <summary>
            Interface to SP800-90A/X9.31 deterministic random bit generators.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IDrbg.BlockSize">
            <summary>
            Return the block size of the DRBG.
            </summary>
            <value>The block size (in bits) produced by each round of the DRBG.</value>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IDrbg.SecurityStrength">
            <summary>
            Return the security strength of the DRBG.
            </summary>
            <value>The security strength (in bits) of the DRBG.</value>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDrbg.Generate(System.Byte[],System.Byte[],System.Boolean)">
            <summary>
            Populate a passed in array with random data.
            </summary>
            <param name="output">Output array for generated bits.</param>
            <param name="additionalInput">Additional input to be added to the DRBG in this step.</param>
            <param name="predictionResistant"><c>true</c> if a reseed should be forced, <c>false</c> otherwise.</param>
            <returns>number of bits generated, -1 if a reseed required.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDrbg.Reseed(System.Byte[])">
            <summary>
            Reseed the DRBG.
            </summary>
            <param name="additionalInput">Additional input to be added to the DRBG in this step.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDrbg.CreateSelfTest(Org.BouncyCastle.Crypto.Algorithm)">
            <summary>
            Return a KAT for the DRBG - used prior to initialisation.
            </summary>
            <returns>A self test</returns>
            <param name="algorithm">The algorithm type</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDrbg.CreateReseedSelfTest(Org.BouncyCastle.Crypto.Algorithm)">
            <summary>
            Return a KAT for the DRBG - used prior to reseed.
            </summary>
            <returns>A reseed self test</returns>
            <param name="algorithm">The algorithm type</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IDrbgBuilder`1">
            <summary>
            Interface for builders of SecureRandom objects based on DRBGs.
            </summary>
            <typeparam name="TRand">The type of SecureRandom produced, e.g. FipsSecureRandom</typeparam>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDrbgBuilder`1.SetPersonalizationString(System.Byte[])">
            <summary>
            Set the personalization string to be used in building the final DRBG.
            </summary>
            <param name="personalizationString">The personalization string for the final DRBG.</param>
            <returns>The current builder.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDrbgBuilder`1.SetSecurityStrength(System.Int32)">
            <summary>
            Set the security strength for the underlying DRBG.
            </summary>
            <param name="securityStrength"></param>
            <returns>The current builder.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDrbgBuilder`1.SetEntropyBitsRequired(System.Int32)">
            <summary>
            Set how many bits of entropy are required for each reseeding of the DRBG.
            </summary>
            <param name="entropyBitsRequired">Number of entropy bit required on a seed/reseed.</param>
            <returns>The current builder.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDrbgBuilder`1.Build(System.Byte[],System.Boolean)">
            <summary>
            Produce a SecureRandom of type TRand based on a DRBG.
            </summary>
            <param name="nonce">A nonce to use in underlying DRBG initialization.</param>
            <param name="predictionResistant">True if the underlying DRBG is to be operated in prediction resistant mode, false otherwise.</param>
            <returns>The final SecureRandom built from an underlying DRBG.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDrbgBuilder`1.Build(System.Byte[],System.Boolean,System.Byte[])">
            <summary>
            Produce a SecureRandom of type TRand based on a DRBG.
            </summary>
            <param name="nonce">A nonce to use in underlying DRBG initialization.</param>
            <param name="predictionResistant">True if the underlying DRBG is to be operated in prediction resistant mode, false otherwise.</param>
            <param name="additionalInput">An additional input parameter for DRBG intialization.</param>
            <returns>The final SecureRandom built from an underlying DRBG.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IDrbgBuilderService`1">
            <summary>
            Service interface for builders of SecureRandom objects based on DRBGs.
            </summary>
            <typeparam name="TRand">The type of SecureRandom produced, e.g. FipsSecureRandom</typeparam>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDrbgBuilderService`1.FromDefaultEntropy">
            <summary>
            Create a builder for a DRBG that will be seeded using the default entropy source for the module.
            </summary>
            <returns>A builder for a SecureRandom based on a DRBG.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDrbgBuilderService`1.FromEntropySource(Org.BouncyCastle.Security.SecureRandom,System.Boolean)">
            <summary>
            Create a builder for a DRBG that will be seeded using the passed in entropy source based on
            a SecureRandom which should be considered to be prediction resistant or not.
            </summary>
            <param name="entropySource">A source of entropy for DRBG seeding.</param>
            <param name="predictionResistant">true if the entropy source can be considered prediction resistant, false otherwise.</param>
            <returns>A builder for a SecureRandom based on a DRBG seeded using entropySource.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDrbgBuilderService`1.FromEntropySource(Org.BouncyCastle.Crypto.IEntropySourceProvider)">
            <summary>
            Create a builder for a DRBG that will be seeded using entropy sources created from the passed in entropy source provider.
            </summary>
            <param name="entropySourceProvider">A provider of entropy sources.</param>
            <returns>A builder for a SecureRandom based on a DRBG seeded using entropy sources from the provider.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IEntropySource">
            <summary>
            Base interface describing an entropy source for a DRBG.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IEntropySource.IsPredictionResistant">
            <summary>
            Return whether or not this entropy source is regarded as prediction resistant.
            </summary>
            <value><c>true</c> if this instance is prediction resistant; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IEntropySource.GetEntropy">
            <summary>
            Return a byte array of entropy.
            </summary>
            <returns>The entropy bytes.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IEntropySource.EntropySize">
            <summary>
            Return the number of bits of entropy this source can produce.
            </summary>
            <value>The size, in bits, of the return value of getEntropy.</value>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IEntropySourceProvider">
            <summary>
            Base interface describing a provider of entropy sources.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IEntropySourceProvider.Get(System.Int32)">
            <summary>
            Return an entropy source providing a block of entropy.
            </summary>
            <param name="bitsRequired">The size of the block of entropy required.</param>
            <returns>An entropy source providing bitsRequired blocks of entropy.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IExchangePairGeneratorService">
            <summary>
            Service interface for NewHope style key material exchange generators.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IExchangePairGeneratorService.GenerateExchange(Org.BouncyCastle.Crypto.IAsymmetricPublicKey)">
            <summary>
            Generate an exchange pair based on the sender public key.
            </summary>
            <param name="senderPublicKey">The public key of the exchange initiator.</param>
            <returns>An ExchangePair derived from the sender public key.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IKdfCalculator`1">
            <summary>
            Base interface factories that produce KDF output.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IKdfCalculator`1.AlgorithmDetails">
            <summary>The algorithm details object for KDF results made by this factory.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IKdfCalculator`1.GetResult(System.Int32)">
            <summary>
            Provide a result block of the given size in bytes.
            </summary>
            <param name="outputLength">The number of bytes contained in the result.</param>
            <returns>a block result containing the generated bytes.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IKdfCalculatorService">
            <summary>
            Service interface for KDF calculators.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IKdfCalculatorService.CreateCalculator``1(``0)">
            <summary>
            Create a KDF calculator configured using the algorithmDetails parameter.
            </summary>
            <typeparam name="A">The parameter type associated with algorithmDetails</typeparam>
            <param name="algorithmDetails">The configuration parameters for the returned KDF calculator.</param>
            <returns>A new KDF calculator.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IKey">
            <summary>
            Base interface for keys.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IKey.Algorithm">
            <summary>
            Gets the algorithm the key is for.
            </summary>
            <returns>The key's algorithm.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IKey.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:Org.BouncyCastle.Crypto.IKey"/>.
            </summary>
            <param name="o">The <see cref="T:System.Object"/> to compare with the current <see cref="T:Org.BouncyCastle.Crypto.IKey"/>.</param>
            <returns><c>true</c> if the specified <see cref="T:System.Object"/> is equal to the current
            <see cref="T:Org.BouncyCastle.Crypto.IKey"/>; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IKey.GetHashCode">
            <summary>
            Return the hash code for the key.
            </summary>
            <returns>A hash code for this instance that is suitable for use in hashing algorithms and data structures such as a hash table.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IKeyUnwrapper`1">
            <summary>
            Base interface for a key unwrapper.
            </summary>
            <typeparam name="A">The algorithm details/parameter type for the key unwrapper.</typeparam>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IKeyUnwrapper`1.AlgorithmDetails">
            <summary>
            The parameter set used to configure this key unwrapper.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IKeyUnwrapper`1.Unwrap(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Unwrap the passed in data.
            </summary>
            <param name="cipherText">The array containing the data to be unwrapped.</param>
            <param name="offset">The offset into cipherText at which the unwrapped data starts.</param>
            <param name="length">The length of the data to be unwrapped.</param>
            <returns>an IBlockResult containing the unwrapped key data.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IKeyUnwrapperProvider`1">
            <summary>
            Interface describing a provider of key unwrapper objects.
            </summary>
            <typeparam name="A">The algorithm details/parameter type for the key unwrappers produced.</typeparam>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IKeyUnwrapperProvider`1.CreateKeyUnwrapper(`0)">
            <summary>
            Return a new key unwrapper for the passed in algorithm details.
            </summary>
            <param name="algorithmDetails">The algorithm details/parameters to use to create the unwrapper.</param>
            <returns>A new key unwrapper.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IKeyUnwrappingService">
            <summary>
            Service interface for key unwrappers.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IKeyUnwrappingService.CreateKeyUnwrapper``1(``0)">
            <summary>
            Create a key unwrapper configured using the algorithmDetails parameter.
            </summary>
            <typeparam name="A">The parameter type associated with algorithmDetails</typeparam>
            <param name="algorithmDetails">The configuration parameters for the returned key unwrapper.</param>
            <returns>A new key unwrapper.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IKeyWrapper`1">
            <summary>
            Base interface for a key wrapper.
            </summary>
            <typeparam name="A">The algorithm details/parameter type for the key wrapper.</typeparam>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IKeyWrapper`1.AlgorithmDetails">
            <summary>
            The parameter set used to configure this key wrapper.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IKeyWrapper`1.Wrap(System.Byte[])">
            <summary>
            Wrap the passed in key data.
            </summary>
            <param name="keyData">The key data to be wrapped.</param>
            <returns>an IBlockResult containing the wrapped key data.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IKeyWrapperProvider`1">
            <summary>
            Interface describing a provider of key wrapper objects.
            </summary>
            <typeparam name="A">The algorithm details/parameter type for the key wrappers produced.</typeparam>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IKeyWrapperProvider`1.CreateKeyWrapper(`0)">
            <summary>
            Return a new key wrapper for the passed in algorithm details.
            </summary>
            <param name="algorithmDetails">The algorithm details/parameters to use to create the wrapper.</param>
            <returns>A new key wrapper.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IKeyWrappingService">
            <summary>
            Service interface for key wrappers.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IKeyWrappingService.CreateKeyWrapper``1(``0)">
            <summary>
            Create a make factory configured using the algorithmDetails parameter.
            </summary>
            <typeparam name="A">The parameter type associated with algorithmDetails</typeparam>
            <param name="algorithmDetails">The configuration parameters for the returned key wrapper.</param>
            <returns>A new key wrapper.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IKMGenerator">
            <summary>
            Base interface for key material generators used in key agreement.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IKMGenerator.Generate(System.Byte[])">
            <summary>
            Generate key material using the passed in agreed value.
            </summary>
            <param name="agreed">The agreed value calculated from key agreement.</param>
            <returns>The key material derived from agreed and any internal parameters.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IMacFactory`1">
            <summary>
            Base interface for operator factories that create stream-based MAC calculators.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IMacFactory`1.AlgorithmDetails">
            <summary>The algorithm details object for calculators made by this factory.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IMacFactory`1.MacLength">
            <summary>Return the size of the MAC associated with this factory.</summary>
            <returns>The length of the MAC produced by this calculators from this factory in bytes.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IMacFactory`1.CreateCalculator">
            <summary>
            Create a stream calculator for the MAC associated with this factory. The stream
            calculator is used for the actual operation of entering the data into the MAC calculator
            and producing the MAC block.
            </summary>
            <returns>A calculator producing an IBlockResult with the final MAC in it.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IMacFactoryProvider`1">
            <summary>
            Interface describing a provider of MAC calculator factory objects.
            </summary>
            <typeparam name="A">The algorithm details/parameter type for the MAC calculator factories produced.</typeparam>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IMacFactoryProvider`1.CreateMacFactory(`0)">
            <summary>
            Return a new MAC calculator factory for the passed in algorithm details.
            </summary>
            <param name="algorithmDetails">The algorithm details/parameters to use to create the factory.</param>
            <returns>A new MAC calculator factory.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IMacFactoryService">
            <summary>
            Service interface for MAC factory objects.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IMacFactoryService.CreateMacFactory``1(``0)">
            <summary>
            Create a MAC factory configured using the algorithmDetails parameter.
            </summary>
            <typeparam name="A">The parameter type associated with algorithmDetails</typeparam>
            <param name="algorithmDetails">The configuration parameters for the returned MAC factory.</param>
            <returns>A new MAC factory.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Agreement.ECDHCBasicAgreement">
             P1363 7.2.2 ECSVDP-DHC
            
             ECSVDP-DHC is Elliptic Curve Secret Value Derivation Primitive,
             Diffie-Hellman version with cofactor multiplication. It is based on
             the work of [DH76], [Mil86], [Kob87], [LMQ98] and [Kal98a]. This
             primitive derives a shared secret value from one party's private key
             and another party's public key, where both have the same set of EC
             domain parameters. If two parties correctly execute this primitive,
             they will produce the same output. This primitive can be invoked by a
             scheme to derive a shared secret key; specifically, it may be used
             with the schemes ECKAS-DH1 and DL/ECKAS-DH2. It does not assume the
             validity of the input public key (see also Section 7.2.1).
             <p>
             Note: As stated P1363 compatibility mode with ECDH can be preset, and
             in this case the implementation doesn't have a ECDH compatibility mode
             (if you want that just use ECDHBasicAgreement and note they both implement
             BasicAgreement!).</p>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.AsymmetricCipherKeyPair">
            a holding class for public/private parameter pairs.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.AsymmetricCipherKeyPair.#ctor(Org.BouncyCastle.Crypto.Internal.AsymmetricKeyParameter,Org.BouncyCastle.Crypto.Internal.AsymmetricKeyParameter)">
             basic constructor.
            
             @param publicParam a public key parameters object.
             @param privateParam the corresponding private key parameters.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Internal.AsymmetricCipherKeyPair.Public">
             return the public key parameters.
            
             @return the public key parameters.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Internal.AsymmetricCipherKeyPair.Private">
             return the private key parameters.
            
             @return the private key parameters.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.BufferedAeadBlockCipher">
            The AEAD block ciphers already handle buffering internally, so this class
            just takes care of implementing IBufferedCipher methods.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.BufferedAeadBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.Internal.ICipherParameters)">
             initialise the cipher.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param param the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.BufferedAeadBlockCipher.GetBlockSize">
             return the blocksize for the underlying cipher.
            
             @return the blocksize for the underlying cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.BufferedAeadBlockCipher.GetUpdateOutputSize(System.Int32)">
             return the size of the output buffer required for an update
             an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update
             with len bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.BufferedAeadBlockCipher.GetOutputSize(System.Int32)">
             return the size of the output buffer required for an update plus a
             doFinal with an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update and doFinal
             with len bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.BufferedAeadBlockCipher.ProcessByte(System.Byte,System.Byte[],System.Int32)">
             process a single byte, producing an output block if necessary.
            
             @param in the input byte.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.BufferedAeadBlockCipher.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
             process an array of bytes, producing output if necessary.
            
             @param in the input byte array.
             @param inOff the offset at which the input data starts.
             @param len the number of bytes to be copied out of the input array.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.BufferedAeadBlockCipher.DoFinal(System.Byte[],System.Int32)">
             Process the last block in the buffer.
            
             @param out the array the block currently being held is copied into.
             @param outOff the offset at which the copying starts.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there is insufficient space in out for
             the output, or the input is not block size aligned and should be.
             @exception InvalidOperationException if the underlying cipher is not
             initialised.
             @exception InvalidCipherTextException if padding is expected and not found.
             @exception DataLengthException if the input is not block size
             aligned.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.BufferedAeadBlockCipher.Reset">
            Reset the buffer and cipher. After resetting the object is in the same
            state as it was after the last init (if there was one).
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.BufferedBlockCipher">
            A wrapper class that allows block ciphers to be used to process data in
            a piecemeal fashion. The BufferedBlockCipher outputs a block only when the
            buffer is full and more data is being added, or on a doFinal.
            <p>
            Note: in the case where the underlying cipher is either a CFB cipher or an
            OFB one the last block may not be a multiple of the block size.
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.BufferedBlockCipher.#ctor">
            constructor for subclasses
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.BufferedBlockCipher.#ctor(Org.BouncyCastle.Crypto.Internal.IBlockCipher)">
             Create a buffered block cipher without padding.
            
             @param cipher the underlying block cipher this buffering object wraps.
             false otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.BufferedBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.Internal.ICipherParameters)">
             initialise the cipher.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param param the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.BufferedBlockCipher.GetBlockSize">
             return the blocksize for the underlying cipher.
            
             @return the blocksize for the underlying cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.BufferedBlockCipher.GetUpdateOutputSize(System.Int32)">
             return the size of the output buffer required for an update
             an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update
             with len bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.BufferedBlockCipher.GetOutputSize(System.Int32)">
             return the size of the output buffer required for an update plus a
             doFinal with an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update and doFinal
             with len bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.BufferedBlockCipher.ProcessByte(System.Byte,System.Byte[],System.Int32)">
             process a single byte, producing an output block if necessary.
            
             @param in the input byte.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.BufferedBlockCipher.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
             process an array of bytes, producing output if necessary.
            
             @param in the input byte array.
             @param inOff the offset at which the input data starts.
             @param len the number of bytes to be copied out of the input array.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.BufferedBlockCipher.DoFinal(System.Byte[],System.Int32)">
             Process the last block in the buffer.
            
             @param out the array the block currently being held is copied into.
             @param outOff the offset at which the copying starts.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there is insufficient space in out for
             the output, or the input is not block size aligned and should be.
             @exception InvalidOperationException if the underlying cipher is not
             initialised.
             @exception InvalidCipherTextException if padding is expected and not found.
             @exception DataLengthException if the input is not block size
             aligned.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.BufferedBlockCipher.Reset">
            Reset the buffer and cipher. After resetting the object is in the same
            state as it was after the last init (if there was one).
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.CipherKeyGenerator">
            The base class for symmetric, or secret, cipher key generators.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.CipherKeyGenerator.Init(Org.BouncyCastle.Crypto.Internal.KeyGenerationParameters)">
             initialise the key generator.
            
             @param param the parameters to be used for key generation
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.CipherKeyGenerator.GenerateKey">
             Generate a secret key.
            
             @return a byte array containing the key value.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Digests.GeneralDigest">
            base implementation of MD4 family style digest as outlined in
            "Handbook of Applied Cryptography", pages 344 - 347.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Digests.KeccakDigest">
            <summary>
            Implementation of Keccak based on following KeccakNISTInterface.c from http://keccak.noekeon.org/
            </summary>
            <remarks>
            Following the naming conventions used in the C source code to enable easy review of the implementation.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Digests.KeccakDigest.GetByteLength">
             Return the size of block that the compression function is applied to in bytes.
            
             @return internal byte length of a block.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Digests.LongDigest">
            Base class for SHA-384 and SHA-512.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Digests.LongDigest.#ctor">
            Constructor for variable length word
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Digests.LongDigest.#ctor(Org.BouncyCastle.Crypto.Internal.Digests.LongDigest)">
            Copy constructor.  We are using copy constructors in place
            of the object.Clone() interface as this interface is not
            supported by J2ME.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Digests.LongDigest.AdjustByteCounts">
            adjust the byte counts so that byteCount2 represents the
            upper long (less 3 bits) word of the byte count.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Digests.MD5Digest">
            implementation of MD5 as outlined in "Handbook of Applied Cryptography", pages 346 - 347.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Digests.MD5Digest.#ctor(Org.BouncyCastle.Crypto.Internal.Digests.MD5Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Digests.MD5Digest.Reset">
            reset the chaining variables to the IV values.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Digests.Sha1Digest">
             implementation of SHA-1 as outlined in "Handbook of Applied Cryptography", pages 346 - 349.
            
             It is interesting to ponder why the, apart from the extra IV, the other difference here from MD5
             is the "endianness" of the word processing!
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Digests.Sha1Digest.#ctor(Org.BouncyCastle.Crypto.Internal.Digests.Sha1Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Digests.Sha1Digest.Reset">
            reset the chaining variables
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Digests.Sha224Digest">
            SHA-224 as described in RFC 3874
            <pre>
                    block  word  digest
            SHA-1   512    32    160
            SHA-224 512    32    224
            SHA-256 512    32    256
            SHA-384 1024   64    384
            SHA-512 1024   64    512
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Digests.Sha224Digest.#ctor">
            Standard constructor
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Digests.Sha224Digest.#ctor(Org.BouncyCastle.Crypto.Internal.Digests.Sha224Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Digests.Sha224Digest.Reset">
            reset the chaining variables
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Digests.Sha256Digest">
             Draft FIPS 180-2 implementation of SHA-256. <b>Note:</b> As this is
             based on a draft this implementation is subject to change.
            
             <pre>
                     block  word  digest
             SHA-1   512    32    160
             SHA-256 512    32    256
             SHA-384 1024   64    384
             SHA-512 1024   64    512
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Digests.Sha256Digest.#ctor(Org.BouncyCastle.Crypto.Internal.Digests.Sha256Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Digests.Sha256Digest.Reset">
            reset the chaining variables
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Digests.Sha384Digest">
             Draft FIPS 180-2 implementation of SHA-384. <b>Note:</b> As this is
             based on a draft this implementation is subject to change.
            
             <pre>
                     block  word  digest
             SHA-1   512    32    160
             SHA-256 512    32    256
             SHA-384 1024   64    384
             SHA-512 1024   64    512
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Digests.Sha384Digest.#ctor(Org.BouncyCastle.Crypto.Internal.Digests.Sha384Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Digests.Sha384Digest.Reset">
            reset the chaining variables
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Digests.Sha3Digest">
            <summary>
            Implementation of SHA-3 based on following KeccakNISTInterface.c from http://keccak.noekeon.org/
            </summary>
            <remarks>
            Following the naming conventions used in the C source code to enable easy review of the implementation.
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Digests.Sha512Digest">
             Draft FIPS 180-2 implementation of SHA-512. <b>Note:</b> As this is
             based on a draft this implementation is subject to change.
            
             <pre>
                     block  word  digest
             SHA-1   512    32    160
             SHA-256 512    32    256
             SHA-384 1024   64    384
             SHA-512 1024   64    512
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Digests.Sha512Digest.#ctor(Org.BouncyCastle.Crypto.Internal.Digests.Sha512Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Digests.Sha512Digest.Reset">
            reset the chaining variables
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Digests.Sha512tDigest">
            FIPS 180-4 implementation of SHA-512/t
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Digests.Sha512tDigest.#ctor(System.Int32)">
            Standard constructor
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Digests.Sha512tDigest.#ctor(Org.BouncyCastle.Crypto.Internal.Digests.Sha512tDigest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Digests.Sha512tDigest.Reset">
            reset the chaining variables
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Digests.ShakeDigest">
            <summary>
            Implementation of SHAKE based on following KeccakNISTInterface.c from http://keccak.noekeon.org/
            </summary>
            <remarks>
            Following the naming conventions used in the C source code to enable easy review of the implementation.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.EC.CustomNamedCurves.GetByOid(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
             return the X9ECParameters object for the named curve represented by
             the passed in object identifier. Null if the curve isn't present.
            
             @param oid an object identifier representing a named curve, if present.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.EC.CustomNamedCurves.GetOid(System.String)">
             return the object identifier signified by the passed in name. Null
             if there is no object identifier associated with name.
            
             @return the object identifier associated with name, if present.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.EC.CustomNamedCurves.GetName(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            return the named curve name represented by the given object identifier.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Internal.EC.CustomNamedCurves.Names">
            returns an enumeration containing the name strings for curves
            contained in this structure.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Encodings.OaepEncoding">
            Optimal Asymmetric Encryption Padding (OAEP) - see PKCS 1 V 2.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Encodings.OaepEncoding.DecodeBlock(System.Byte[],System.Int32,System.Int32)">
            @exception InvalidCipherTextException if the decrypted block turns out to
            be badly formatted.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Encodings.OaepEncoding.ItoOSP(System.Int32,System.Byte[])">
            int to octet string.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Encodings.OaepEncoding.maskGeneratorFunction1(System.Byte[],System.Int32,System.Int32,System.Int32)">
            mask generator function, as described in PKCS1v2.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Encodings.Pkcs1Encoding">
            this does your basic Pkcs 1 v1.5 padding - whether or not you should be using this
            depends on your application - see Pkcs1 Version 2 for details.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Internal.Encodings.Pkcs1Encoding.NOT_STRICT_LENGTH_ENABLED_PROPERTY">
            some providers fail to include the leading zero in PKCS1 encoded blocks. If you need to
            work with one of these set the system property org.bouncycastle.pkcs1.strict to false.
            <p>
            The system property is checked during construction of the encoding object, it is set to 
            true by default.
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Encodings.Pkcs1Encoding.#ctor(Org.BouncyCastle.Crypto.Internal.IAsymmetricBlockCipher)">
            Basic constructor.
            @param cipher
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Encodings.Pkcs1Encoding.#ctor(Org.BouncyCastle.Crypto.Internal.IAsymmetricBlockCipher,System.Int32)">
            Constructor for decryption with a fixed plaintext length.
            
            @param cipher The cipher to use for cryptographic operation.
            @param pLen Length of the expected plaintext.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Encodings.Pkcs1Encoding.#ctor(Org.BouncyCastle.Crypto.Internal.IAsymmetricBlockCipher,System.Byte[])">
            Constructor for decryption with a fixed plaintext length and a fallback
            value that is returned, if the padding is incorrect.
            
            @param cipher
                       The cipher to use for cryptographic operation.
            @param fallback
                       The fallback value, we don't to a arraycopy here.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Encodings.Pkcs1Encoding.CheckPkcs1Encoding(System.Byte[],System.Int32)">
            Checks if the argument is a correctly PKCS#1.5 encoded Plaintext
            for encryption.
            
            @param encoded The Plaintext.
            @param pLen Expected length of the plaintext.
            @return Either 0, if the encoding is correct, or -1, if it is incorrect.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Encodings.Pkcs1Encoding.DecodeBlockOrRandom(System.Byte[],System.Int32,System.Int32)">
            Decode PKCS#1.5 encoding, and return a random value if the padding is not correct.
            
            @param in The encrypted block.
            @param inOff Offset in the encrypted block.
            @param inLen Length of the encrypted block.
            @param pLen Length of the desired output.
            @return The plaintext without padding, or a random value if the padding was incorrect.
            
            @throws InvalidCipherTextException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Encodings.Pkcs1Encoding.DecodeBlock(System.Byte[],System.Int32,System.Int32)">
            @exception InvalidCipherTextException if the decrypted block is not in Pkcs1 format.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Engines.AesFastEngine">
             an implementation of the AES (Rijndael)), from FIPS-197.
             <p>
             For further details see: <a href="http://csrc.nist.gov/encryption/aes/">http://csrc.nist.gov/encryption/aes/</a>.
            
             This implementation is based on optimizations from Dr. Brian Gladman's paper and C code at
             <a href="http://fp.gladman.plus.com/cryptography_technology/rijndael/">http://fp.gladman.plus.com/cryptography_technology/rijndael/</a>
            
             There are three levels of tradeoff of speed vs memory
             Because java has no preprocessor), they are written as three separate classes from which to choose
            
             The fastest uses 8Kbytes of static tables to precompute round calculations), 4 256 word tables for encryption
             and 4 for decryption.
            
             The middle performance version uses only one 256 word table for each), for a total of 2Kbytes),
             adding 12 rotate operations per round to compute the values contained in the other tables from
             the contents of the first
            
             The slowest version uses no static tables at all and computes the values in each round
             </p>
             <p>
             This file contains the fast version with 8Kbytes of static tables for round precomputation
             </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Engines.AesFastEngine.GenerateWorkingKey(System.Byte[],System.Boolean)">
            Calculate the necessary round keys
            The number of calculations depends on key size and block size
            AES specified a fixed block size of 128 bits and key sizes 128/192/256 bits
            This code is written assuming those are the only possible values
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Engines.AesFastEngine.#ctor">
            default constructor - 128 bit block size.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Engines.AesFastEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.Internal.ICipherParameters)">
             initialise an AES cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Engines.CamelliaEngine">
            Camellia - based on RFC 3713.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Engines.ChaChaEngine">
            <summary>
            Implementation of Daniel J. Bernstein's ChaCha stream cipher.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Engines.ChaChaEngine.#ctor">
            <summary>
            Creates a 20 rounds ChaCha engine.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Engines.ChaChaEngine.#ctor(System.Int32)">
            <summary>
            Creates a ChaCha engine with a specific number of rounds.
            </summary>
            <param name="rounds">the number of rounds (must be an even number).</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Engines.ChaChaEngine.ChachaCore(System.Int32,System.UInt32[],System.UInt32[])">
            <summary>
            ChaCha function.
            </summary>
            <param name="rounds">The number of ChaCha rounds to execute</param>
            <param name="input">The input words.</param>
            <param name="x">The ChaCha state to modify.</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Engines.DesEdeEngine">
            <remarks>A class that provides a basic DESede (or Triple DES) engine.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Engines.DesEdeEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.Internal.ICipherParameters)">
             initialise a DESede cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Engines.DesEngine">
            <remarks>A class that provides a basic DES engine.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Engines.DesEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.Internal.ICipherParameters)">
             initialise a DES cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Internal.Engines.DesEngine.bytebit">
            what follows is mainly taken from "Applied Cryptography", by
            Bruce Schneier, however it also bears great resemblance to Richard
            Outerbridge's D3DES...
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Engines.DesEngine.GenerateWorkingKey(System.Boolean,System.Byte[])">
             Generate an integer based working key based on our secret key
             and what we processing we are planning to do.
            
             Acknowledgements for this routine go to James Gillogly and Phil Karn.
                     (whoever, and wherever they are!).
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Engines.DesEngine.DesFunc(System.Int32[],System.Byte[],System.Int32,System.Byte[],System.Int32)">
            the DES engine.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Engines.ElGamalEngine">
            this does your basic ElGamal algorithm.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Engines.ElGamalEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.Internal.ICipherParameters)">
             initialise the ElGamal engine.
            
             @param forEncryption true if we are encrypting, false otherwise.
             @param param the necessary ElGamal key parameters.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Engines.ElGamalEngine.GetInputBlockSize">
             Return the maximum size for an input block to this engine.
             For ElGamal this is always one byte less than the size of P on
             encryption, and twice the length as the size of P on decryption.
            
             @return maximum size for an input block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Engines.ElGamalEngine.GetOutputBlockSize">
             Return the maximum size for an output block to this engine.
             For ElGamal this is always one byte less than the size of P on
             decryption, and twice the length as the size of P on encryption.
            
             @return maximum size for an output block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Engines.ElGamalEngine.ProcessBlock(System.Byte[],System.Int32,System.Int32)">
             Process a single block using the basic ElGamal algorithm.
            
             @param in the input array.
             @param inOff the offset into the input buffer where the data starts.
             @param length the length of the data to be processed.
             @return the result of the ElGamal process.
             @exception DataLengthException the input block is too large.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Engines.RC4Engine.Init(System.Boolean,Org.BouncyCastle.Crypto.Internal.ICipherParameters)">
             initialise a RC4 cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Engines.RsaBlindedEngine">
            this does your basic RSA algorithm with blinding
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Engines.RsaBlindedEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.Internal.ICipherParameters)">
             initialise the RSA engine.
            
             @param forEncryption true if we are encrypting, false otherwise.
             @param param the necessary RSA key parameters.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Engines.RsaBlindedEngine.GetInputBlockSize">
             Return the maximum size for an input block to this engine.
             For RSA this is always one byte less than the key size on
             encryption, and the same length as the key size on decryption.
            
             @return maximum size for an input block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Engines.RsaBlindedEngine.GetOutputBlockSize">
             Return the maximum size for an output block to this engine.
             For RSA this is always one byte less than the key size on
             decryption, and the same length as the key size on encryption.
            
             @return maximum size for an output block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Engines.RsaBlindedEngine.ProcessBlock(System.Byte[],System.Int32,System.Int32)">
             Process a single block using the basic RSA algorithm.
            
             @param inBuf the input array.
             @param inOff the offset into the input buffer where the data starts.
             @param inLen the length of the data to be processed.
             @return the result of the RSA process.
             @exception DataLengthException the input block is too large.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Engines.RsaCoreEngine">
            this does your basic RSA algorithm.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Engines.RsaCoreEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.Internal.ICipherParameters)">
             initialise the RSA engine.
            
             @param forEncryption true if we are encrypting, false otherwise.
             @param param the necessary RSA key parameters.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Engines.RsaCoreEngine.GetInputBlockSize">
             Return the maximum size for an input block to this engine.
             For RSA this is always one byte less than the key size on
             encryption, and the same length as the key size on decryption.
            
             @return maximum size for an input block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Engines.RsaCoreEngine.GetOutputBlockSize">
             Return the maximum size for an output block to this engine.
             For RSA this is always one byte less than the key size on
             decryption, and the same length as the key size on encryption.
            
             @return maximum size for an output block.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Engines.Salsa20Engine">
            <summary>
            Implementation of Daniel J. Bernstein's Salsa20 stream cipher, Snuffle 2005
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Internal.Engines.Salsa20Engine.StateSize">
            Constants 
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Engines.Salsa20Engine.#ctor">
            <summary>
            Creates a 20 round Salsa20 engine.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Engines.Salsa20Engine.#ctor(System.Int32)">
            <summary>
            Creates a Salsa20 engine with a specific number of rounds.
            </summary>
            <param name="rounds">the number of rounds (must be an even number).</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Engines.Salsa20Engine.R(System.UInt32,System.Int32)">
             Rotate left
            
             @param   x   value to rotate
             @param   y   amount to rotate x
            
             @return  rotated x
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Engines.SeedEngine">
            Implementation of the SEED algorithm as described in RFC 4009
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Engines.SerpentEngine">
                 * Serpent is a 128-bit 32-round block cipher with variable key lengths,
                 * including 128, 192 and 256 bit keys conjectured to be at least as
                 * secure as three-key triple-DES.
                 * <p>
                 * Serpent was designed by Ross Anderson, Eli Biham and Lars Knudsen as a
                 * candidate algorithm for the NIST AES Quest.
            	 * </p>
                 * <p>
                 * For full details see <a href="http://www.cl.cam.ac.uk/~rja14/serpent.html">The Serpent home page</a>
            	 * </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Engines.SerpentEngine.MakeWorkingKey(System.Byte[])">
             Expand a user-supplied key material into a session key.
            
             @param key  The user-key bytes (multiples of 4) to use.
             @exception ArgumentException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Engines.SerpentEngine.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Encrypt one block of plaintext.
            
             @param input the array containing the input data.
             @param inOff offset into the in array the data starts at.
             @param output the array the output data will be copied into.
             @param outOff the offset into the out array the output will start at.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Engines.SerpentEngine.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Decrypt one block of ciphertext.
            
             @param input the array containing the input data.
             @param inOff offset into the in array the data starts at.
             @param output the array the output data will be copied into.
             @param outOff the offset into the out array the output will start at.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Engines.SerpentEngineBase.Init(System.Boolean,Org.BouncyCastle.Crypto.Internal.ICipherParameters)">
             initialise a Serpent cipher.
            
             @param encrypting whether or not we are for encryption.
             @param params     the parameters required to set up the cipher.
             @throws IllegalArgumentException if the params argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Engines.SerpentEngineBase.ProcessBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Process one block of input from the array in and write it to
             the out array.
            
             @param in     the array containing the input data.
             @param inOff  offset into the in array the data starts at.
             @param out    the array the output data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @return the number of bytes processed and produced.
             @throws DataLengthException if there isn't enough data in in, or
             space in out.
             @throws IllegalStateException if the cipher isn't initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Engines.SerpentEngineBase.Ib0(System.Int32,System.Int32,System.Int32,System.Int32)">
            InvSO - {13, 3,11, 0,10, 6, 5,12, 1,14, 4, 7,15, 9, 8, 2 } - 15 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Engines.SerpentEngineBase.Sb1(System.Int32,System.Int32,System.Int32,System.Int32)">
            S1 - {15,12, 2, 7, 9, 0, 5,10, 1,11,14, 8, 6,13, 3, 4 } - 14 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Engines.SerpentEngineBase.Ib1(System.Int32,System.Int32,System.Int32,System.Int32)">
            InvS1 - { 5, 8, 2,14,15, 6,12, 3,11, 4, 7, 9, 1,13,10, 0 } - 14 steps.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Engines.SerpentEngineBase.Sb2(System.Int32,System.Int32,System.Int32,System.Int32)">
            S2 - { 8, 6, 7, 9, 3,12,10,15,13, 1,14, 4, 0,11, 5, 2 } - 16 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Engines.SerpentEngineBase.Ib2(System.Int32,System.Int32,System.Int32,System.Int32)">
            InvS2 - {12, 9,15, 4,11,14, 1, 2, 0, 3, 6,13, 5, 8,10, 7 } - 16 steps.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Engines.SerpentEngineBase.Sb3(System.Int32,System.Int32,System.Int32,System.Int32)">
            S3 - { 0,15,11, 8,12, 9, 6, 3,13, 1, 2, 4,10, 7, 5,14 } - 16 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Engines.SerpentEngineBase.Ib3(System.Int32,System.Int32,System.Int32,System.Int32)">
            InvS3 - { 0, 9,10, 7,11,14, 6,13, 3, 5,12, 2, 4, 8,15, 1 } - 15 terms
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Engines.SerpentEngineBase.Sb4(System.Int32,System.Int32,System.Int32,System.Int32)">
            S4 - { 1,15, 8, 3,12, 0,11, 6, 2, 5, 4,10, 9,14, 7,13 } - 15 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Engines.SerpentEngineBase.Ib4(System.Int32,System.Int32,System.Int32,System.Int32)">
            InvS4 - { 5, 0, 8, 3,10, 9, 7,14, 2,12,11, 6, 4,15,13, 1 } - 15 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Engines.SerpentEngineBase.Sb5(System.Int32,System.Int32,System.Int32,System.Int32)">
            S5 - {15, 5, 2,11, 4,10, 9,12, 0, 3,14, 8,13, 6, 7, 1 } - 16 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Engines.SerpentEngineBase.Ib5(System.Int32,System.Int32,System.Int32,System.Int32)">
            InvS5 - { 8,15, 2, 9, 4, 1,13,14,11, 6, 5, 3, 7,12,10, 0 } - 16 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Engines.SerpentEngineBase.Sb6(System.Int32,System.Int32,System.Int32,System.Int32)">
            S6 - { 7, 2,12, 5, 8, 4, 6,11,14, 9, 1,15,13, 3,10, 0 } - 15 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Engines.SerpentEngineBase.Ib6(System.Int32,System.Int32,System.Int32,System.Int32)">
            InvS6 - {15,10, 1,13, 5, 3, 6, 0, 4, 9,14, 7, 2,12, 8,11 } - 15 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Engines.SerpentEngineBase.Sb7(System.Int32,System.Int32,System.Int32,System.Int32)">
            S7 - { 1,13,15, 0,14, 8, 2,11, 7, 4,12,10, 9, 3, 5, 6 } - 16 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Engines.SerpentEngineBase.Ib7(System.Int32,System.Int32,System.Int32,System.Int32)">
            InvS7 - { 3, 0, 6,13, 9,14,15, 8, 5,12,11, 7,10, 1, 4, 2 } - 17 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Engines.SerpentEngineBase.LT">
            Apply the linear transformation to the register set.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Engines.SerpentEngineBase.InverseLT">
            Apply the inverse of the linear transformation to the register set.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Generators.BaseKdfBytesGenerator">
            Basic KDF generator for derived keys and ivs as defined by IEEE P1363a/ISO 18033
            <br/>
            This implementation is based on ISO 18033/P1363a.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Generators.BaseKdfBytesGenerator.#ctor(System.Int32,Org.BouncyCastle.Crypto.Internal.IDigest)">
             Construct a KDF Parameters generator.
            
             @param counterStart value of counter.
             @param digest the digest to be used as the source of derived keys.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Internal.Generators.BaseKdfBytesGenerator.Digest">
            return the underlying digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Generators.BaseKdfBytesGenerator.GenerateBytes(System.Byte[],System.Int32,System.Int32)">
             fill len bytes of the output buffer with bytes generated from
             the derivation function.
            
             @throws ArgumentException if the size of the request will cause an overflow.
             @throws DataLengthException if the out buffer is too small.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Generators.ConcatenationKdfGenerator">
            Generator for Concatenation Key Derivation Function defined in NIST SP 800-56A, Sect 5.8.1
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Generators.ConcatenationKdfGenerator.#ctor(Org.BouncyCastle.Crypto.Internal.IDigest)">
            @param digest the digest to be used as the source of generated bytes
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Internal.Generators.ConcatenationKdfGenerator.Digest">
            return the underlying digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Generators.ConcatenationKdfGenerator.ItoOSP(System.UInt32,System.Byte[])">
            int to octet string.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Generators.ConcatenationKdfGenerator.GenerateBytes(System.Byte[],System.Int32,System.Int32)">
             fill len bytes of the output buffer with bytes generated from
             the derivation function.
            
             @throws DataLengthException if the out buffer is too small.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Generators.DHKeyPairGenerator">
             a Diffie-Hellman key pair generator.
            
             This generates keys consistent for use in the MTI/A0 key agreement protocol
             as described in "Handbook of Applied Cryptography", Pages 516-519.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Generators.DsaKeyPairGenerator">
             a DSA key pair generator.
            
             This Generates DSA keys in line with the method described
             in <i>FIPS 186-3 B.1 FFC Key Pair Generation</i>.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Generators.DsaParametersGenerator">
            Generate suitable parameters for DSA, in line with FIPS 186-2, or FIPS 186-3.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Generators.DsaParametersGenerator.Init(System.Int32,System.Int32,Org.BouncyCastle.Security.SecureRandom)">
            <summary>Initialise the generator</summary>
            <remarks>This form can only be used for older DSA (pre-DSA2) parameters</remarks>
            <param name="size">the size of keys in bits (from 512 up to 1024, and a multiple of 64)</param>
            <param name="certainty">measure of robustness of primes (at least 80 for FIPS 186-2 compliance)</param>
            <param name="random">the source of randomness to use</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Generators.DsaParametersGenerator.Init(Org.BouncyCastle.Crypto.Internal.Parameters.DsaParameterGenerationParameters)">
            <summary>Initialise the generator for DSA 2</summary>
            <remarks>You must use this Init method if you need to generate parameters for DSA 2 keys</remarks>
            <param name="parameters">An instance of <c>DsaParameterGenerationParameters</c> used to configure this generator</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Generators.DsaParametersGenerator.GenerateParameters">
            <summary>Generates a set of <c>DsaParameters</c></summary>
            <remarks>Can take a while...</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Generators.DsaParametersGenerator.GenerateParameters_FIPS186_3">
            generate suitable parameters for DSA, in line with
            <i>FIPS 186-3 A.1 Generation of the FFC Primes p and q</i>.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Generators.ECKeyPairGenerator.GenerateKeyPair">
            Given the domain parameters this routine generates an EC key
            pair in accordance with X9.62 section 5.2.1 pages 26, 27.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Generators.Kdf2BytesGenerator">
            KDF2 generator for derived keys and ivs as defined by IEEE P1363a/ISO 18033
            <br/>
            This implementation is based on IEEE P1363/ISO 18033.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Generators.Kdf2BytesGenerator.#ctor(Org.BouncyCastle.Crypto.Internal.IDigest)">
             Construct a KDF2 bytes generator. Generates key material
             according to IEEE P1363 or ISO 18033 depending on the initialisation.
            
             @param digest the digest to be used as the source of derived keys.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Generators.OpenSslPbeParametersGenerator">
            Generator for PBE derived keys and ivs as usd by OpenSSL.
            <p>
            The scheme is a simple extension of PKCS 5 V2.0 Scheme 1 using MD5 with an
            iteration count of 1.
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Generators.OpenSslPbeParametersGenerator.#ctor">
            Construct a OpenSSL Parameters generator. 
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Generators.OpenSslPbeParametersGenerator.Init(System.Byte[],System.Byte[])">
            Initialise - note the iteration count for this algorithm is fixed at 1.
            
            @param password password to use.
            @param salt salt to use.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Generators.OpenSslPbeParametersGenerator.GenerateDerivedKey(System.Int32)">
            the derived key function, the ith hash of the password and the salt.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Generators.OpenSslPbeParametersGenerator.GenerateDerivedParameters(System.Int32)">
             Generate a key parameter derived from the password, salt, and iteration
             count we are currently initialised with.
            
             @param keySize the size of the key we want (in bits)
             @return a KeyParameter object.
             @exception ArgumentException if the key length larger than the base hash size.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Generators.OpenSslPbeParametersGenerator.GenerateDerivedMacParameters(System.Int32)">
             Generate a key parameter for use with a MAC derived from the password,
             salt, and iteration count we are currently initialised with.
            
             @param keySize the size of the key we want (in bits)
             @return a KeyParameter object.
             @exception ArgumentException if the key length larger than the base hash size.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Generators.Pkcs12ParametersGenerator">
            Generator for Pbe derived keys and ivs as defined by Pkcs 12 V1.0.
            <p>
            The document this implementation is based on can be found at
            <a href="http://www.rsasecurity.com/rsalabs/pkcs/pkcs-12/index.html">
            RSA's Pkcs12 Page</a>
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Generators.Pkcs12ParametersGenerator.#ctor(Org.BouncyCastle.Crypto.Internal.IDigest)">
             Construct a Pkcs 12 Parameters generator.
            
             @param digest the digest to be used as the source of derived keys.
             @exception ArgumentException if an unknown digest is passed in.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Generators.Pkcs12ParametersGenerator.Adjust(System.Byte[],System.Int32,System.Byte[])">
            add a + b + 1, returning the result in a. The a value is treated
            as a BigInteger of length (b.Length * 8) bits. The result is
            modulo 2^b.Length in case of overflow.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Generators.Pkcs12ParametersGenerator.GenerateDerivedKey(System.Int32,System.Int32)">
            generation of a derived key ala Pkcs12 V1.0.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Generators.Pkcs12ParametersGenerator.GenerateDerivedParameters(System.Int32)">
             Generate a key parameter derived from the password, salt, and iteration
             count we are currently initialised with.
            
             @param keySize the size of the key we want (in bits)
             @return a KeyParameter object.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Generators.Pkcs12ParametersGenerator.GenerateDerivedParameters(System.Int32,System.Int32)">
             Generate a key with initialisation vector parameter derived from
             the password, salt, and iteration count we are currently initialised
             with.
            
             @param keySize the size of the key we want (in bits)
             @param ivSize the size of the iv we want (in bits)
             @return a ParametersWithIV object.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Generators.Pkcs12ParametersGenerator.GenerateDerivedMacParameters(System.Int32)">
             Generate a key parameter for use with a MAC derived from the password,
             salt, and iteration count we are currently initialised with.
            
             @param keySize the size of the key we want (in bits)
             @return a KeyParameter object.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Generators.Pkcs5S2ParametersGenerator">
            Generator for Pbe derived keys and ivs as defined by Pkcs 5 V2.0 Scheme 2.
            This generator uses a SHA-1 HMac as the calculation function.
            <p>
            The document this implementation is based on can be found at
            <a href="http://www.rsasecurity.com/rsalabs/pkcs/pkcs-5/index.html">
            RSA's Pkcs5 Page</a></p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Generators.Pkcs5S2ParametersGenerator.#ctor">
            construct a Pkcs5 Scheme 2 Parameters generator.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Generators.Pkcs5S2ParametersGenerator.GenerateDerivedParameters(System.Int32)">
             Generate a key parameter derived from the password, salt, and iteration
             count we are currently initialised with.
            
             @param keySize the size of the key we want (in bits)
             @return a KeyParameter object.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Generators.Pkcs5S2ParametersGenerator.GenerateDerivedParameters(System.Int32,System.Int32)">
             Generate a key with initialisation vector parameter derived from
             the password, salt, and iteration count we are currently initialised
             with.
            
             @param keySize the size of the key we want (in bits)
             @param ivSize the size of the iv we want (in bits)
             @return a ParametersWithIV object.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Generators.Pkcs5S2ParametersGenerator.GenerateDerivedMacParameters(System.Int32)">
             Generate a key parameter for use with a MAC derived from the password,
             salt, and iteration count we are currently initialised with.
            
             @param keySize the size of the key we want (in bits)
             @return a KeyParameter object.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Generators.Poly1305KeyGenerator">
            <summary>
            Generates keys for the Poly1305 MAC.
            </summary>
            <remarks>
            Poly1305 keys are 256 bit keys consisting of a 128 bit secret key used for the underlying block
            cipher followed by a 128 bit {@code r} value used for the polynomial portion of the Mac. <br/>
            The {@code r} value has a specific format with some bits required to be cleared, resulting in an
            effective 106 bit key. <br/>
            A separately generated 256 bit key can be modified to fit the Poly1305 key format by using the
            {@link #clamp(byte[])} method to clear the required bits.
            </remarks>
            <seealso cref="T:Org.BouncyCastle.Crypto.Internal.Macs.Poly1305"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Generators.Poly1305KeyGenerator.engineInit(Org.BouncyCastle.Crypto.Internal.KeyGenerationParameters)">
            <summary>
            Initialises the key generator.
            </summary>
            <remarks>
            Poly1305 keys are always 256 bits, so the key length in the provided parameters is ignored.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Generators.Poly1305KeyGenerator.engineGenerateKey">
            <summary>
            Generates a 256 bit key in the format required for Poly1305 - e.g.
            <code>k[0] ... k[15], r[0] ... r[15]</code> with the required bits in <code>r</code> cleared
            as per <see cref="M:Org.BouncyCastle.Crypto.Internal.Generators.Poly1305KeyGenerator.Clamp(System.Byte[])"/>.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Generators.Poly1305KeyGenerator.Clamp(System.Byte[])">
            <summary>
            Modifies an existing 32 byte key value to comply with the requirements of the Poly1305 key by
            clearing required bits in the <code>r</code> (second 16 bytes) portion of the key.<br/>
            Specifically:
            <ul>
            <li>r[3], r[7], r[11], r[15] have top four bits clear (i.e., are {0, 1, . . . , 15})</li>
            <li>r[4], r[8], r[12] have bottom two bits clear (i.e., are in {0, 4, 8, . . . , 252})</li>
            </ul>
            </summary>
            <param name="key">a 32 byte key value <code>k[0] ... k[15], r[0] ... r[15]</code></param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Generators.Poly1305KeyGenerator.CheckKey(System.Byte[])">
            <summary>
            Checks a 32 byte key for compliance with the Poly1305 key requirements, e.g.
            <code>k[0] ... k[15], r[0] ... r[15]</code> with the required bits in <code>r</code> cleared
            as per <see cref="M:Org.BouncyCastle.Crypto.Internal.Generators.Poly1305KeyGenerator.Clamp(System.Byte[])"/>.
            </summary>
            <param name="key">Key.</param>
            <exception cref="T:System.ArgumentException">if the key is of the wrong length, or has invalid bits set
                      in the <code>r</code> portion of the key.</exception>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Generators.RsaKeyPairGenerator">
            an RSA key pair generator.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Generators.RsaKeyPairGenerator.chooseRandomPrime(System.Int32,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
             Choose a random prime value for use with RSA
            
             @param bitlength the bit-length of the returned prime
             @param e         the RSA public exponent
             @return A prime p, with (p-1) relatively prime to e
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.IAsymmetricBlockCipher">
            <remarks>Base interface for a public/private key block cipher.</remarks>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Internal.IAsymmetricBlockCipher.AlgorithmName">
            <summary>The name of the algorithm this cipher implements.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.IAsymmetricBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.Internal.ICipherParameters)">
            <summary>Initialise the cipher.</summary>
            <param name="forEncryption">Initialise for encryption if true, for decryption if false.</param>
            <param name="parameters">The key or other data required by the cipher.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.IAsymmetricBlockCipher.GetInputBlockSize">
            <returns>The maximum size, in bytes, an input block may be.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.IAsymmetricBlockCipher.GetOutputBlockSize">
            <returns>The maximum size, in bytes, an output block will be.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.IAsymmetricBlockCipher.ProcessBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>Process a block.</summary>
            <param name="inBuf">The input buffer.</param>
            <param name="inOff">The offset into <paramref>inBuf</paramref> that the input block begins.</param>
            <param name="inLen">The length of the input block.</param>
            <exception cref="T:Org.BouncyCastle.Crypto.InvalidCipherTextException">Input decrypts improperly.</exception>
            <exception cref="T:Org.BouncyCastle.Crypto.DataLengthException">Input is too large for the cipher.</exception>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.IAsymmetricCipherKeyPairGenerator">
            interface that a public/private key pair generator should conform to.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.IAsymmetricCipherKeyPairGenerator.Init(Org.BouncyCastle.Crypto.Internal.KeyGenerationParameters)">
             intialise the key pair generator.
            
             @param the parameters the key pair is to be initialised with.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.IAsymmetricCipherKeyPairGenerator.GenerateKeyPair">
             return an AsymmetricCipherKeyPair containing the Generated keys.
            
             @return an AsymmetricCipherKeyPair containing the Generated keys.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.IBasicAgreement">
            The basic interface that basic Diffie-Hellman implementations
            conforms to.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.IBasicAgreement.Init(Org.BouncyCastle.Crypto.Internal.ICipherParameters)">
            initialise the agreement engine.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.IBasicAgreement.GetFieldSize">
            return the field size for the agreement algorithm in bytes.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.IBasicAgreement.CalculateAgreement(Org.BouncyCastle.Crypto.Internal.ICipherParameters)">
            given a public key from a given party calculate the next
            message in the agreement sequence.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.IBlockCipher">
            <remarks>Base interface for a symmetric key block cipher.</remarks>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Internal.IBlockCipher.AlgorithmName">
            <summary>The name of the algorithm this cipher implements.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.IBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.Internal.ICipherParameters)">
            <summary>Initialise the cipher.</summary>
            <param name="forEncryption">Initialise for encryption if true, for decryption if false.</param>
            <param name="parameters">The key or other data required by the cipher.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.IBlockCipher.GetBlockSize">
            <returns>The block size for this cipher, in bytes.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Internal.IBlockCipher.IsPartialBlockOkay">
            <summary>Indicates whether this cipher can handle partial blocks.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.IBlockCipher.ProcessBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>Process a block.</summary>
            <param name="inBuf">The input buffer.</param>
            <param name="inOff">The offset into <paramref>inBuf</paramref> that the input block begins.</param>
            <param name="outBuf">The output buffer.</param>
            <param name="outOff">The offset into <paramref>outBuf</paramref> to write the output block.</param>
            <exception cref="T:Org.BouncyCastle.Crypto.DataLengthException">If input block is wrong size, or outBuf too small.</exception>
            <returns>The number of bytes processed and produced.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.IBlockCipher.Reset">
            <summary>
            Reset the cipher to the same state as it was after the last init (if there was one).
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.IBufferedCipher">
            <remarks>Block cipher engines are expected to conform to this interface.</remarks>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Internal.IBufferedCipher.AlgorithmName">
            <summary>The name of the algorithm this cipher implements.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.IBufferedCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.Internal.ICipherParameters)">
            <summary>Initialise the cipher.</summary>
            <param name="forEncryption">If true the cipher is initialised for encryption,
            if false for decryption.</param>
            <param name="parameters">The key and other data required by the cipher.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.IBufferedCipher.Reset">
            <summary>
            Reset the cipher. After resetting the cipher is in the same state
            as it was after the last init (if there was one).
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.ICipherParameters">
            all parameter classes implement this.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.IDerivationFunction">
            base interface for general purpose byte derivation functions.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Internal.IDerivationFunction.Digest">
            return the message digest used as the basis for the function
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.IDerivationParameters">
            Parameters for key/byte stream derivation classes
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.IDigest">
            interface that a message digest conforms to.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Internal.IDigest.AlgorithmName">
             return the algorithm name
            
             @return the algorithm name
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.IDigest.GetDigestSize">
             return the size, in bytes, of the digest produced by this message digest.
            
             @return the size, in bytes, of the digest produced by this message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.IDigest.GetByteLength">
             return the size, in bytes, of the internal buffer used by this digest.
            
             @return the size, in bytes, of the internal buffer used by this digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.IDigest.Update(System.Byte)">
             update the message digest with a single byte.
            
             @param inByte the input byte to be entered.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.IDigest.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
             update the message digest with a block of bytes.
            
             @param input the byte array containing the data.
             @param inOff the offset into the byte array where the data starts.
             @param len the length of the data.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.IDigest.DoFinal(System.Byte[],System.Int32)">
             Close the digest, producing the final digest value. The doFinal
             call leaves the digest reset.
            
             @param output the array the digest is to be copied into.
             @param outOff the offset into the out array the digest is to start at.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.IDigest.Reset">
            reset the digest back to it's initial state.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.IDsa">
            interface for classes implementing the Digital Signature Algorithm
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.IDsa.Init(System.Boolean,Org.BouncyCastle.Crypto.Internal.ICipherParameters)">
             initialise the signer for signature generation or signature
             verification.
            
             @param forSigning true if we are generating a signature, false
             otherwise.
             @param param key parameters for signature generation.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.IDsa.GenerateSignature(System.Byte[])">
             sign the passed in message (usually the output of a hash function).
            
             @param message the message to be signed.
             @return two big integers representing the r and s values respectively.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.IDsa.VerifySignature(System.Byte[],Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
             verify the message message against the signature values r and s.
            
             @param message the message that was supposed to have been signed.
             @param r the r signature value.
             @param s the s signature value.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.IMac">
            The base interface for implementations of message authentication codes (MACs).
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.IMac.Init(Org.BouncyCastle.Crypto.Internal.ICipherParameters)">
             Initialise the MAC.
            
             @param param the key and other data required by the MAC.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Internal.IMac.AlgorithmName">
             Return the name of the algorithm the MAC implements.
            
             @return the name of the algorithm the MAC implements.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.IMac.GetMacSize">
             Return the block size for this MAC (in bytes).
            
             @return the block size for this MAC in bytes.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.IMac.Update(System.Byte)">
             add a single byte to the mac for processing.
            
             @param in the byte to be processed.
             @exception InvalidOperationException if the MAC is not initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.IMac.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            @param in the array containing the input.
            @param inOff the index in the array the data begins at.
            @param len the length of the input starting at inOff.
            @exception InvalidOperationException if the MAC is not initialised.
            @exception DataLengthException if there isn't enough data in in.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.IMac.DoFinal(System.Byte[],System.Int32)">
            Compute the final stage of the MAC writing the output to the out
            parameter.
            <p>
            doFinal leaves the MAC in the same state it was after the last init.
            </p>
            @param out the array the MAC is to be output to.
            @param outOff the offset into the out buffer the output is to start at.
            @exception DataLengthException if there isn't enough space in out.
            @exception InvalidOperationException if the MAC is not initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.IMac.Reset">
            Reset the MAC. At the end of resetting the MAC should be in the
            in the same state it was after the last init (if there was one).
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Internal.ISigner.AlgorithmName">
             Return the name of the algorithm the signer implements.
            
             @return the name of the algorithm the signer implements.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.ISigner.Init(System.Boolean,Org.BouncyCastle.Crypto.Internal.ICipherParameters)">
             Initialise the signer for signing or verification.
            
             @param forSigning true if for signing, false otherwise
             @param param necessary parameters.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.ISigner.Update(System.Byte)">
            update the internal digest with the byte b
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.ISigner.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            update the internal digest with the byte array in
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.ISigner.GenerateSignature">
            Generate a signature for the message we've been loaded with using
            the key we were initialised with.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.ISigner.VerifySignature(System.Byte[])">
            return true if the internal state represents the signature described
            in the passed in array.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.ISigner.Reset">
            reset the internal state
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.IStreamCipher">
            <summary>The interface stream ciphers conform to.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Internal.IStreamCipher.AlgorithmName">
            <summary>The name of the algorithm this cipher implements.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.IStreamCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.Internal.ICipherParameters)">
            <summary>Initialise the cipher.</summary>
            <param name="forEncryption">If true the cipher is initialised for encryption,
            if false for decryption.</param>
            <param name="parameters">The key and other data required by the cipher.</param>
            <exception cref="T:System.ArgumentException">
            If the parameters argument is inappropriate.
            </exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.IStreamCipher.ReturnByte(System.Byte)">
            <summary>encrypt/decrypt a single byte returning the result.</summary>
            <param name="input">the byte to be processed.</param>
            <returns>the result of processing the input byte.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.IStreamCipher.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Process a block of bytes from <c>input</c> putting the result into <c>output</c>.
            </summary>
            <param name="input">The input byte array.</param>
            <param name="inOff">
            The offset into <c>input</c> where the data to be processed starts.
            </param>
            <param name="length">The number of bytes to be processed.</param>
            <param name="output">The output buffer the processed bytes go into.</param>
            <param name="outOff">
            The offset into <c>output</c> the processed data starts at.
            </param>
            <exception cref="T:Org.BouncyCastle.Crypto.DataLengthException">If the output buffer is too small.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.IStreamCipher.Reset">
            <summary>
            Reset the cipher to the same state as it was after the last init (if there was one).
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Internal.IWrapper.AlgorithmName">
            <summary>The name of the algorithm this cipher implements.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.IXof">
            <remarks>
            With FIPS PUB 202 a new kind of message digest was announced which supported extendable output, or variable digest sizes.
            This interface provides the extra method required to support variable output on a digest implementation.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.IXof.DoFinal(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Output the results of the final calculation for this digest to outLen number of bytes.
            </summary>
            <param name="output">output array to write the output bytes to.</param>
            <param name="outOff">offset to start writing the bytes at.</param>
            <param name="outLen">the number of output bytes requested.</param>
            <returns>the number of bytes written</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.IXof.DoOutput(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Start outputting the results of the final calculation for this digest. Unlike DoFinal, this method
            will continue producing output until the Xof is explicitly reset, or signals otherwise.
            </summary>
            <param name="output">output array to write the output bytes to.</param>
            <param name="outOff">offset to start writing the bytes at.</param>
            <param name="outLen">the number of output bytes requested.</param>
            <returns>the number of bytes written</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.KeyGenerationParameters">
            The base class for parameters to key generators.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.KeyGenerationParameters.#ctor(Org.BouncyCastle.Security.SecureRandom,System.Int32)">
             initialise the generator with a source of randomness
             and a strength (in bits).
            
             @param random the random byte source.
             @param strength the size, in bits, of the keys we want to produce.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Internal.KeyGenerationParameters.Random">
             return the random source associated with this
             generator.
            
             @return the generators random source.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Internal.KeyGenerationParameters.Strength">
             return the bit strength for keys produced by this generator,
            
             @return the strength of the keys this generator produces (in bits).
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Macs.CbcBlockCipherMac">
            standard CBC Block Cipher MAC - if no padding is specified the default of
            pad of zeroes is used.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Macs.CbcBlockCipherMac.#ctor(Org.BouncyCastle.Crypto.Internal.IBlockCipher)">
             create a standard MAC based on a CBC block cipher. This will produce an
             authentication code half the length of the block size of the cipher.
            
             @param cipher the cipher to be used as the basis of the MAC generation.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Macs.CbcBlockCipherMac.#ctor(Org.BouncyCastle.Crypto.Internal.IBlockCipher,Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding)">
             create a standard MAC based on a CBC block cipher. This will produce an
             authentication code half the length of the block size of the cipher.
            
             @param cipher the cipher to be used as the basis of the MAC generation.
             @param padding the padding to be used to complete the last block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Macs.CbcBlockCipherMac.#ctor(Org.BouncyCastle.Crypto.Internal.IBlockCipher,System.Int32)">
            create a standard MAC based on a block cipher with the size of the
            MAC been given in bits. This class uses CBC mode as the basis for the
            MAC generation.
            <p>
            Note: the size of the MAC must be at least 24 bits (FIPS Publication 81),
            or 16 bits if being used as a data authenticator (FIPS Publication 113),
            and in general should be less than the size of the block cipher as it reduces
            the chance of an exhaustive attack (see Handbook of Applied Cryptography).
            </p>
            @param cipher the cipher to be used as the basis of the MAC generation.
            @param macSizeInBits the size of the MAC in bits, must be a multiple of 8.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Macs.CbcBlockCipherMac.#ctor(Org.BouncyCastle.Crypto.Internal.IBlockCipher,System.Int32,Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding)">
            create a standard MAC based on a block cipher with the size of the
            MAC been given in bits. This class uses CBC mode as the basis for the
            MAC generation.
            <p>
            Note: the size of the MAC must be at least 24 bits (FIPS Publication 81),
            or 16 bits if being used as a data authenticator (FIPS Publication 113),
            and in general should be less than the size of the block cipher as it reduces
            the chance of an exhaustive attack (see Handbook of Applied Cryptography).
            </p>
            @param cipher the cipher to be used as the basis of the MAC generation.
            @param macSizeInBits the size of the MAC in bits, must be a multiple of 8.
            @param padding the padding to be used to complete the last block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Macs.CbcBlockCipherMac.Reset">
            Reset the mac generator.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Macs.CMac">
            CMAC - as specified at www.nuee.nagoya-u.ac.jp/labs/tiwata/omac/omac.html
            <p>
            CMAC is analogous to OMAC1 - see also en.wikipedia.org/wiki/CMAC
            </p><p>
            CMAC is a NIST recomendation - see 
            csrc.nist.gov/CryptoToolkit/modes/800-38_Series_Publications/SP800-38B.pdf
            </p><p>
            CMAC/OMAC1 is a blockcipher-based message authentication code designed and
            analyzed by Tetsu Iwata and Kaoru Kurosawa.
            </p><p>
            CMAC/OMAC1 is a simple variant of the CBC MAC (Cipher Block Chaining Message 
            Authentication Code). OMAC stands for One-Key CBC MAC.
            </p><p>
            It supports 128- or 64-bits block ciphers, with any key size, and returns
            a MAC with dimension less or equal to the block size of the underlying 
            cipher.
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Macs.CMac.#ctor(Org.BouncyCastle.Crypto.Internal.IBlockCipher)">
             create a standard MAC based on a CBC block cipher (64 or 128 bit block).
             This will produce an authentication code the length of the block size
             of the cipher.
            
             @param cipher the cipher to be used as the basis of the MAC generation.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Macs.CMac.#ctor(Org.BouncyCastle.Crypto.Internal.IBlockCipher,System.Int32)">
             create a standard MAC based on a block cipher with the size of the
             MAC been given in bits.
             <p/>
             Note: the size of the MAC must be at least 24 bits (FIPS Publication 81),
             or 16 bits if being used as a data authenticator (FIPS Publication 113),
             and in general should be less than the size of the block cipher as it reduces
             the chance of an exhaustive attack (see Handbook of Applied Cryptography).
            
             @param cipher        the cipher to be used as the basis of the MAC generation.
             @param macSizeInBits the size of the MAC in bits, must be a multiple of 8 and @lt;= 128.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Macs.CMac.Reset">
            Reset the mac generator.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Macs.GMac">
            <summary>
            The GMAC specialisation of Galois/Counter mode (GCM) detailed in NIST Special Publication
            800-38D.
            </summary>
            <remarks>
            GMac is an invocation of the GCM mode where no data is encrypted (i.e. all input data to the Mac
            is processed as additional authenticated data with the underlying GCM block cipher).
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Macs.GMac.#ctor(Org.BouncyCastle.Crypto.Internal.Modes.GcmBlockCipher)">
            <summary>
            Creates a GMAC based on the operation of a block cipher in GCM mode.
            </summary>
            <remarks>
            This will produce an authentication code the length of the block size of the cipher.
            </remarks>
            <param name="cipher">the cipher to be used in GCM mode to generate the MAC.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Macs.GMac.#ctor(Org.BouncyCastle.Crypto.Internal.Modes.GcmBlockCipher,System.Int32)">
            <summary>
            Creates a GMAC based on the operation of a 128 bit block cipher in GCM mode.
            </summary>
            <remarks>
            This will produce an authentication code the length of the block size of the cipher.
            </remarks>
            <param name="cipher">the cipher to be used in GCM mode to generate the MAC.</param>
            <param name="macSizeBits">the mac size to generate, in bits. Must be a multiple of 8, between 32 and 128 (inclusive).
            Sizes less than 96 are not recommended, but are supported for specialized applications.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Macs.GMac.Init(Org.BouncyCastle.Crypto.Internal.ICipherParameters)">
            <summary>
            Initialises the GMAC - requires a <see cref="T:Org.BouncyCastle.Crypto.Internal.Parameters.ParametersWithIV"/> 
            providing a <see cref="T:Org.BouncyCastle.Crypto.Internal.Parameters.KeyParameter"/> and a nonce.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Macs.HMac">
             HMAC implementation based on RFC2104
            
             H(K XOR opad, H(K XOR ipad, text))
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Macs.HMac.Reset">
            Reset the mac generator.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Macs.Poly1305">
            <summary>
            Poly1305 message authentication code, designed by D. J. Bernstein.
            </summary>
            <remarks>
            Poly1305 computes a 128-bit (16 bytes) authenticator, using a 128 bit nonce and a 256 bit key
            consisting of a 128 bit key applied to an underlying cipher, and a 128 bit key (with 106
            effective key bits) used in the authenticator.
            
            The polynomial calculation in this implementation is adapted from the public domain <a
            href="https://github.com/floodyberry/poly1305-donna">poly1305-donna-unrolled</a> C implementation
            by Andrew M (@floodyberry).
            </remarks>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Internal.Macs.Poly1305.r0">
            Polynomial key 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Internal.Macs.Poly1305.r1">
            Polynomial key 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Internal.Macs.Poly1305.r2">
            Polynomial key 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Internal.Macs.Poly1305.r3">
            Polynomial key 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Internal.Macs.Poly1305.r4">
            Polynomial key 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Internal.Macs.Poly1305.s1">
            Precomputed 5 * r[1..4] 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Internal.Macs.Poly1305.s2">
            Precomputed 5 * r[1..4] 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Internal.Macs.Poly1305.s3">
            Precomputed 5 * r[1..4] 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Internal.Macs.Poly1305.s4">
            Precomputed 5 * r[1..4] 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Internal.Macs.Poly1305.k0">
            Encrypted nonce 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Internal.Macs.Poly1305.k1">
            Encrypted nonce 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Internal.Macs.Poly1305.k2">
            Encrypted nonce 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Internal.Macs.Poly1305.k3">
            Encrypted nonce 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Internal.Macs.Poly1305.currentBlock">
            Current block of buffered input 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Internal.Macs.Poly1305.currentBlockOffset">
            Current offset in input buffer 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Internal.Macs.Poly1305.h0">
            Polynomial accumulator 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Internal.Macs.Poly1305.h1">
            Polynomial accumulator 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Internal.Macs.Poly1305.h2">
            Polynomial accumulator 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Internal.Macs.Poly1305.h3">
            Polynomial accumulator 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Internal.Macs.Poly1305.h4">
            Polynomial accumulator 
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Macs.Poly1305.#ctor">
            Constructs a Poly1305 MAC, where the key passed to init() will be used directly.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Macs.Poly1305.#ctor(Org.BouncyCastle.Crypto.Internal.IBlockCipher)">
            Constructs a Poly1305 MAC, using a 128 bit block cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Macs.Poly1305.Init(Org.BouncyCastle.Crypto.Internal.ICipherParameters)">
            <summary>
            Initialises the Poly1305 MAC.
            </summary>
            <param name="parameters">a {@link ParametersWithIV} containing a 128 bit nonce and a {@link KeyParameter} with
                     a 256 bit key complying to the {@link Poly1305KeyGenerator Poly1305 key format}.</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Modes.CbcBlockCipher">
            implements Cipher-Block-Chaining (CBC) mode on top of a simple cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.CbcBlockCipher.#ctor(Org.BouncyCastle.Crypto.Internal.IBlockCipher)">
             Basic constructor.
            
             @param cipher the block cipher to be used as the basis of chaining.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.CbcBlockCipher.GetUnderlyingCipher">
             return the underlying block cipher that we are wrapping.
            
             @return the underlying block cipher that we are wrapping.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.CbcBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.Internal.ICipherParameters)">
             Initialise the cipher and, possibly, the initialisation vector (IV).
             If an IV isn't passed as part of the parameter, the IV will be all zeros.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param param the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Internal.Modes.CbcBlockCipher.AlgorithmName">
             return the algorithm name and mode.
            
             @return the name of the underlying algorithm followed by "/CBC".
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.CbcBlockCipher.GetBlockSize">
             return the block size of the underlying cipher.
            
             @return the block size of the underlying cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.CbcBlockCipher.ProcessBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Process one block of input from the array in and write it to
             the out array.
            
             @param in the array containing the input data.
             @param inOff offset into the in array the data starts at.
             @param out the array the output data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @exception DataLengthException if there isn't enough data in in, or
             space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
             @return the number of bytes processed and produced.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.CbcBlockCipher.Reset">
            reset the chaining vector back to the IV and reset the underlying
            cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.CbcBlockCipher.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Do the appropriate chaining step for CBC mode encryption.
            
             @param in the array containing the data to be encrypted.
             @param inOff offset into the in array the data starts at.
             @param out the array the encrypted data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @exception DataLengthException if there isn't enough data in in, or
             space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
             @return the number of bytes processed and produced.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.CbcBlockCipher.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Do the appropriate chaining step for CBC mode decryption.
            
             @param in the array containing the data to be decrypted.
             @param inOff offset into the in array the data starts at.
             @param out the array the decrypted data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @exception DataLengthException if there isn't enough data in in, or
             space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
             @return the number of bytes processed and produced.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Modes.CcmBlockCipher">
            Implements the Counter with Cipher Block Chaining mode (CCM) detailed in
            NIST Special Publication 800-38C.
            <p>
            <b>Note</b>: this mode is a packet mode - it needs all the data up front.
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.CcmBlockCipher.#ctor(Org.BouncyCastle.Crypto.Internal.IBlockCipher)">
             Basic constructor.
            
             @param cipher the block cipher to be used.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.CcmBlockCipher.GetUnderlyingCipher">
             return the underlying block cipher that we are wrapping.
            
             @return the underlying block cipher that we are wrapping.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.CcmBlockCipher.GetMac">
             Returns a byte array containing the mac calculated as part of the
             last encrypt or decrypt operation.
            
             @return the last mac calculated.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.CcmBlockCipher.ProcessPacket(System.Byte[],System.Int32,System.Int32)">
             Process a packet of data for either CCM decryption or encryption.
            
             @param in data for processing.
             @param inOff offset at which data starts in the input array.
             @param inLen length of the data in the input array.
             @return a byte array containing the processed input..
             @throws IllegalStateException if the cipher is not appropriately set up.
             @throws InvalidCipherTextException if the input data is truncated or the mac check fails.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.CcmBlockCipher.ProcessPacket(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
             Process a packet of data for either CCM decryption or encryption.
            
             @param in data for processing.
             @param inOff offset at which data starts in the input array.
             @param inLen length of the data in the input array.
             @param output output array.
             @param outOff offset into output array to start putting processed bytes.
             @return the number of bytes added to output.
             @throws IllegalStateException if the cipher is not appropriately set up.
             @throws InvalidCipherTextException if the input data is truncated or the mac check fails.
             @throws DataLengthException if output buffer too short.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Modes.CfbBlockCipher">
            implements a Cipher-FeedBack (CFB) mode on top of a simple cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.CfbBlockCipher.#ctor(Org.BouncyCastle.Crypto.Internal.IBlockCipher,System.Int32)">
             Basic constructor.
            
             @param cipher the block cipher to be used as the basis of the
             feedback mode.
             @param blockSize the block size in bits (note: a multiple of 8)
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.CfbBlockCipher.GetUnderlyingCipher">
             return the underlying block cipher that we are wrapping.
            
             @return the underlying block cipher that we are wrapping.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.CfbBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.Internal.ICipherParameters)">
             Initialise the cipher and, possibly, the initialisation vector (IV).
             If an IV isn't passed as part of the parameter, the IV will be all zeros.
             An IV which is too short is handled in FIPS compliant fashion.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param param the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Internal.Modes.CfbBlockCipher.AlgorithmName">
             return the algorithm name and mode.
            
             @return the name of the underlying algorithm followed by "/CFB"
             and the block size in bits.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.CfbBlockCipher.GetBlockSize">
             return the block size we are operating at.
            
             @return the block size we are operating at (in bytes).
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.CfbBlockCipher.ProcessBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Process one block of input from the array in and write it to
             the out array.
            
             @param in the array containing the input data.
             @param inOff offset into the in array the data starts at.
             @param out the array the output data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @exception DataLengthException if there isn't enough data in in, or
             space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
             @return the number of bytes processed and produced.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.CfbBlockCipher.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Do the appropriate processing for CFB mode encryption.
            
             @param in the array containing the data to be encrypted.
             @param inOff offset into the in array the data starts at.
             @param out the array the encrypted data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @exception DataLengthException if there isn't enough data in in, or
             space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
             @return the number of bytes processed and produced.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.CfbBlockCipher.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Do the appropriate processing for CFB mode decryption.
            
             @param in the array containing the data to be decrypted.
             @param inOff offset into the in array the data starts at.
             @param out the array the encrypted data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @exception DataLengthException if there isn't enough data in in, or
             space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
             @return the number of bytes processed and produced.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.CfbBlockCipher.Reset">
            reset the chaining vector back to the IV and reset the underlying
            cipher.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Modes.EaxBlockCipher">
            A Two-Pass Authenticated-Encryption Scheme Optimized for Simplicity and 
            Efficiency - by M. Bellare, P. Rogaway, D. Wagner.
            
            http://www.cs.ucdavis.edu/~rogaway/papers/eax.pdf
            
            EAX is an AEAD scheme based on CTR and OMAC1/CMAC, that uses a single block 
            cipher to encrypt and authenticate data. It's on-line (the length of a 
            message isn't needed to begin processing it), has good performances, it's
            simple and provably secure (provided the underlying block cipher is secure).
            
            Of course, this implementations is NOT thread-safe.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.EaxBlockCipher.#ctor(Org.BouncyCastle.Crypto.Internal.IBlockCipher)">
             Constructor that accepts an instance of a block cipher engine.
            
             @param cipher the engine to use
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Modes.GcmBlockCipher">
            <summary>
            Implements the Galois/Counter mode (GCM) detailed in
            NIST Special Publication 800-38D.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.GcmBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.Internal.ICipherParameters)">
            <remarks>
            MAC sizes from 32 bits to 128 bits (must be a multiple of 8) are supported. The default is 128 bits.
            Sizes less than 96 are not recommended, but are supported for specialized applications.
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Modes.IAeadBlockCipher">
            <summary>
            A block cipher mode that includes authenticated encryption with a streaming mode
            and optional associated data.</summary>
            <see cref="T:Org.BouncyCastle.Crypto.Internal.Parameters.AeadParameters"/>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Internal.Modes.IAeadBlockCipher.AlgorithmName">
            <summary>The name of the algorithm this cipher implements.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.IAeadBlockCipher.GetUnderlyingCipher">
            <summary>The block cipher underlying this algorithm.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.IAeadBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.Internal.ICipherParameters)">
            <summary>Initialise the cipher.</summary>
            <remarks>Parameter can either be an AeadParameters or a ParametersWithIV object.</remarks>
            <param name="forEncryption">Initialise for encryption if true, for decryption if false.</param>
            <param name="parameters">The key or other data required by the cipher.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.IAeadBlockCipher.GetBlockSize">
            <returns>The block size for this cipher, in bytes.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.IAeadBlockCipher.ProcessAadByte(System.Byte)">
            <summary>Add a single byte to the associated data check.</summary>
            <remarks>If the implementation supports it, this will be an online operation and will not retain the associated data.</remarks>
            <param name="input">The byte to be processed.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.IAeadBlockCipher.ProcessAadBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>Add a sequence of bytes to the associated data check.</summary>
            <remarks>If the implementation supports it, this will be an online operation and will not retain the associated data.</remarks>
            <param name="inBytes">The input byte array.</param>
            <param name="inOff">The offset into the input array where the data to be processed starts.</param>
            <param name="len">The number of bytes to be processed.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.IAeadBlockCipher.ProcessByte(System.Byte,System.Byte[],System.Int32)">
             Encrypt/decrypt a single byte.
            
             @param input the byte to be processed.
             @param outBytes the output buffer the processed byte goes into.
             @param outOff the offset into the output byte array the processed data starts at.
             @return the number of bytes written to out.
             @exception DataLengthException if the output buffer is too small.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.IAeadBlockCipher.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
             Process a block of bytes from in putting the result into out.
            
             @param inBytes the input byte array.
             @param inOff the offset into the in array where the data to be processed starts.
             @param len the number of bytes to be processed.
             @param outBytes the output buffer the processed bytes go into.
             @param outOff the offset into the output byte array the processed data starts at.
             @return the number of bytes written to out.
             @exception DataLengthException if the output buffer is too small.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.IAeadBlockCipher.DoFinal(System.Byte[],System.Int32)">
             Finish the operation either appending or verifying the MAC at the end of the data.
            
             @param outBytes space for any resulting output data.
             @param outOff offset into out to start copying the data at.
             @return number of bytes written into out.
             @throws InvalidOperationException if the cipher is in an inappropriate state.
             @throws InvalidCipherTextException if the MAC fails to match.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.IAeadBlockCipher.GetMac">
             Return the value of the MAC associated with the last stream processed.
            
             @return MAC for plaintext data.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.IAeadBlockCipher.GetUpdateOutputSize(System.Int32)">
             Return the size of the output buffer required for a ProcessBytes
             an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to ProcessBytes
             with len bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.IAeadBlockCipher.GetOutputSize(System.Int32)">
             Return the size of the output buffer required for a ProcessBytes plus a
             DoFinal with an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to ProcessBytes and DoFinal
             with len bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.IAeadBlockCipher.Reset">
            <summary>
            Reset the cipher to the same state as it was after the last init (if there was one).
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Modes.NistCtsBlockCipher">
            A Cipher Text Stealing (CTS) mode cipher. CTS allows block ciphers to
            be used to produce cipher text which is the same length as the plain text.
            <p>
                This class implements the NIST version as documented in "Addendum to NIST SP 800-38A, Recommendation for Block Cipher Modes of Operation: Three Variants of Ciphertext Stealing for CBC Mode"
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.NistCtsBlockCipher.#ctor(System.Int32,Org.BouncyCastle.Crypto.Internal.IBlockCipher)">
             Create a buffered block cipher that uses NIST Cipher Text Stealing
            
             @param type type of CTS mode (CS1, CS2, or CS3)
             @param cipher the underlying block cipher used to create the CBC block cipher this cipher uses..
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.NistCtsBlockCipher.GetUpdateOutputSize(System.Int32)">
             return the size of the output buffer required for an update
             an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update
             with len bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.NistCtsBlockCipher.GetOutputSize(System.Int32)">
             return the size of the output buffer required for an update plus a
             doFinal with an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update and doFinal
             with len bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.NistCtsBlockCipher.ProcessByte(System.Byte,System.Byte[],System.Int32)">
             process a single byte, producing an output block if necessary.
            
             @param in the input byte.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception IllegalStateException if the cipher isn't initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.NistCtsBlockCipher.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
             process an array of bytes, producing output if necessary.
            
             @param in the input byte array.
             @param inOff the offset at which the input data starts.
             @param len the number of bytes to be copied out of the input array.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception IllegalStateException if the cipher isn't initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.NistCtsBlockCipher.DoFinal(System.Byte[],System.Int32)">
             Process the last block in the buffer.
            
             @param out the array the block currently being held is copied into.
             @param outOff the offset at which the copying starts.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there is insufficient space in out for
             the output.
             @exception IllegalStateException if the underlying cipher is not
             initialised.
             @exception org.bouncycastle.crypto.InvalidCipherTextException if cipher text decrypts wrongly (in
             case the exception will never get thrown).
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Modes.OfbBlockCipher">
            implements a Output-FeedBack (OFB) mode on top of a simple cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.OfbBlockCipher.#ctor(Org.BouncyCastle.Crypto.Internal.IBlockCipher,System.Int32)">
             Basic constructor.
            
             @param cipher the block cipher to be used as the basis of the
             feedback mode.
             @param blockSize the block size in bits (note: a multiple of 8)
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.OfbBlockCipher.GetUnderlyingCipher">
             return the underlying block cipher that we are wrapping.
            
             @return the underlying block cipher that we are wrapping.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.OfbBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.Internal.ICipherParameters)">
             Initialise the cipher and, possibly, the initialisation vector (IV).
             If an IV isn't passed as part of the parameter, the IV will be all zeros.
             An IV which is too short is handled in FIPS compliant fashion.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param param the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Internal.Modes.OfbBlockCipher.AlgorithmName">
             return the algorithm name and mode.
            
             @return the name of the underlying algorithm followed by "/OFB"
             and the block size in bits
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.OfbBlockCipher.GetBlockSize">
             return the block size we are operating at (in bytes).
            
             @return the block size we are operating at (in bytes).
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.OfbBlockCipher.ProcessBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Process one block of input from the array in and write it to
             the out array.
            
             @param in the array containing the input data.
             @param inOff offset into the in array the data starts at.
             @param out the array the output data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @exception DataLengthException if there isn't enough data in in, or
             space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
             @return the number of bytes processed and produced.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.OfbBlockCipher.Reset">
            reset the feedback vector back to the IV and reset the underlying
            cipher.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Modes.OpenPgpCfbBlockCipher">
                * Implements OpenPGP's rather strange version of Cipher-FeedBack (CFB) mode
                * on top of a simple cipher. This class assumes the IV has been prepended
                * to the data stream already, and just accomodates the reset after
                * (blockSize + 2) bytes have been read.
                * <p>
                * For further info see <a href="http://www.ietf.org/rfc/rfc2440.html">RFC 2440</a>.
            	* </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.OpenPgpCfbBlockCipher.#ctor(Org.BouncyCastle.Crypto.Internal.IBlockCipher)">
             Basic constructor.
            
             @param cipher the block cipher to be used as the basis of the
             feedback mode.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.OpenPgpCfbBlockCipher.GetUnderlyingCipher">
             return the underlying block cipher that we are wrapping.
            
             @return the underlying block cipher that we are wrapping.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Internal.Modes.OpenPgpCfbBlockCipher.AlgorithmName">
             return the algorithm name and mode.
            
             @return the name of the underlying algorithm followed by "/OpenPGPCFB"
             and the block size in bits.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.OpenPgpCfbBlockCipher.GetBlockSize">
             return the block size we are operating at.
            
             @return the block size we are operating at (in bytes).
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.OpenPgpCfbBlockCipher.ProcessBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Process one block of input from the array in and write it to
             the out array.
            
             @param in the array containing the input data.
             @param inOff offset into the in array the data starts at.
             @param out the array the output data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @exception DataLengthException if there isn't enough data in in, or
             space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
             @return the number of bytes processed and produced.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.OpenPgpCfbBlockCipher.Reset">
            reset the chaining vector back to the IV and reset the underlying
            cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.OpenPgpCfbBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.Internal.ICipherParameters)">
             Initialise the cipher and, possibly, the initialisation vector (IV).
             If an IV isn't passed as part of the parameter, the IV will be all zeros.
             An IV which is too short is handled in FIPS compliant fashion.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param parameters the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.OpenPgpCfbBlockCipher.EncryptByte(System.Byte,System.Int32)">
            Encrypt one byte of data according to CFB mode.
            @param data the byte to encrypt
            @param blockOff offset in the current block
            @returns the encrypted byte
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.OpenPgpCfbBlockCipher.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Do the appropriate processing for CFB IV mode encryption.
            
             @param in the array containing the data to be encrypted.
             @param inOff offset into the in array the data starts at.
             @param out the array the encrypted data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @exception DataLengthException if there isn't enough data in in, or
             space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
             @return the number of bytes processed and produced.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.OpenPgpCfbBlockCipher.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Do the appropriate processing for CFB IV mode decryption.
            
             @param in the array containing the data to be decrypted.
             @param inOff offset into the in array the data starts at.
             @param out the array the encrypted data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @exception DataLengthException if there isn't enough data in in, or
             space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
             @return the number of bytes processed and produced.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Modes.SicBlockCipher">
            Implements the Segmented Integer Counter (SIC) mode on top of a simple
            block cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.SicBlockCipher.#ctor(Org.BouncyCastle.Crypto.Internal.IBlockCipher)">
             Basic constructor.
            
             @param c the block cipher to be used.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Modes.SicBlockCipher.GetUnderlyingCipher">
             return the underlying block cipher that we are wrapping.
            
             @return the underlying block cipher that we are wrapping.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Parameters.AeadParameters.#ctor(Org.BouncyCastle.Crypto.Internal.Parameters.KeyParameter,System.Int32,System.Byte[])">
             Base constructor.
            
             @param key key to be used by underlying cipher
             @param macSize macSize in bits
             @param nonce nonce to be used
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Parameters.AeadParameters.#ctor(Org.BouncyCastle.Crypto.Internal.Parameters.KeyParameter,System.Int32,System.Byte[],System.Byte[])">
             Base constructor.
            
             @param key key to be used by underlying cipher
             @param macSize macSize in bits
             @param nonce nonce to be used
             @param associatedText associated text, if any
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Parameters.DesEdeParameters.IsWeakKey(System.Byte[],System.Int32,System.Int32)">
             return true if the passed in key is a DES-EDE weak key.
            
             @param key bytes making up the key
             @param offset offset into the byte array the key starts at
             @param length number of bytes making up the key
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Parameters.DesEdeParameters.IsWeakKey(System.Byte[],System.Int32)">
             return true if the passed in key is a DES-EDE weak key.
            
             @param key bytes making up the key
             @param offset offset into the byte array the key starts at
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Parameters.DesParameters.IsWeakKey(System.Byte[],System.Int32)">
            DES has 16 weak keys.  This method will check
            if the given DES key material is weak or semi-weak.
            Key material that is too short is regarded as weak.
            <p>
            See <a href="http://www.counterpane.com/applied.html">"Applied
            Cryptography"</a> by Bruce Schneier for more information.
            </p>
            @return true if the given DES key material is weak or semi-weak,
                false otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Parameters.DesParameters.SetOddParity(System.Byte[])">
             DES Keys use the LSB as the odd parity bit.  This can
             be used to check for corrupt keys.
            
             @param bytes the byte array to set the parity on.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Internal.Parameters.DHParameters.M">
            <summary>The minimum bitlength of the private value.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Internal.Parameters.DHParameters.L">
            <summary>The bitlength of the private value.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Parameters.DsaParameterGenerationParameters.#ctor(System.Int32,System.Int32,System.Int32,Org.BouncyCastle.Security.SecureRandom)">
             Construct without a usage index, this will do a random construction of G.
            
             @param L desired length of prime P in bits (the effective key size).
             @param N desired length of prime Q in bits.
             @param certainty certainty level for prime number generation.
             @param random the source of randomness to use.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Parameters.DsaParameterGenerationParameters.#ctor(System.Int32,System.Int32,System.Int32,Org.BouncyCastle.Security.SecureRandom,System.Int32)">
             Construct for a specific usage index - this has the effect of using verifiable canonical generation of G.
            
             @param L desired length of prime P in bits (the effective key size).
             @param N desired length of prime Q in bits.
             @param certainty certainty level for prime number generation.
             @param random the source of randomness to use.
             @param usageIndex a valid usage index.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Parameters.Iso18033KdfParameters">
            parameters for Key derivation functions for ISO-18033
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Parameters.KdfParameters">
            parameters for Key derivation functions for IEEE P1363a
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.PbeParametersGenerator">
            super class for all Password Based Encyrption (Pbe) parameter generator classes.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.PbeParametersGenerator.#ctor">
            base constructor.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.PbeParametersGenerator.Init(System.Byte[],System.Byte[],System.Int32)">
             initialise the Pbe generator.
            
             @param password the password converted into bytes (see below).
             @param salt the salt to be mixed with the password.
             @param iterationCount the number of iterations the "mixing" function
             is to be applied for.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Internal.PbeParametersGenerator.IterationCount">
             return the iteration count.
            
             @return the iteration count.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.PbeParametersGenerator.GenerateDerivedParameters(System.Int32)">
             Generate derived parameters for a key of length keySize.
            
             @param keySize the length, in bits, of the key required.
             @return a parameters object representing a key.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.PbeParametersGenerator.GenerateDerivedParameters(System.Int32,System.Int32)">
             Generate derived parameters for a key of length keySize, and
             an initialisation vector (IV) of length ivSize.
            
             @param keySize the length, in bits, of the key required.
             @param ivSize the length, in bits, of the iv required.
             @return a parameters object representing a key and an IV.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.PbeParametersGenerator.GenerateDerivedMacParameters(System.Int32)">
             Generate derived parameters for a key of length keySize, specifically
             for use with a MAC.
            
             @param keySize the length, in bits, of the key required.
             @return a parameters object representing a key.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.PbeParametersGenerator.Pkcs5PasswordToBytes(System.Char[])">
             converts a password to a byte array according to the scheme in
             Pkcs5 (ascii, no padding)
            
             @param password a character array representing the password.
             @return a byte array representing the password.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.PbeParametersGenerator.Pkcs5PasswordToUtf8Bytes(System.Char[])">
             converts a password to a byte array according to the scheme in
             PKCS5 (UTF-8, no padding)
            
             @param password a character array representing the password.
             @return a byte array representing the password.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.PbeParametersGenerator.Pkcs12PasswordToBytes(System.Char[])">
             converts a password to a byte array according to the scheme in
             Pkcs12 (unicode, big endian, 2 zero pad bytes at the end).
            
             @param password a character array representing the password.
             @return a byte array representing the password.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Pqc.Crypto.IMessageSigner.Init(System.Boolean,Org.BouncyCastle.Crypto.Internal.ICipherParameters)">
            <summary>
             initialise the signer for signature generation or signature verification.
            </summary>
            <param name="forSigning">true if we are generating a signature, false otherwise</param>
            <param name="param">key parameters for signature generation.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Pqc.Crypto.IMessageSigner.GenerateSignature(System.Byte[])">
            <summary>
            sign the passed in message (usually the output of a hash function).
            </summary>
            <param name="message">the message to be signed.</param>
            <returns>the signature of the message</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Pqc.Crypto.IMessageSigner.VerifySignature(System.Byte[],System.Byte[])">
            <summary>
            verify the message message against the signature value
            </summary>
            <param name="message">the message that was supposed to have been signed.</param>
            <param name="signature">the signature of the message.</param>
            <returns></returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Pqc.Crypto.Sphincs.Permute.permute(System.Int32,System.Int32[])">
            ChaCha core function
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Pqc.Crypto.Sphincs.Sphincs256Signer">
            SPHINCS-256 signer.
            <p>
            This implementation is heavily based on the reference implementation in SUPERCOP, the main difference being the digests used
            for message hashing and tree construction are now configurable (within limits...)
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Pqc.Crypto.Sphincs.Sphincs256Signer.#ctor(Org.BouncyCastle.Crypto.Internal.IDigest,Org.BouncyCastle.Crypto.Internal.IDigest)">
             Base constructor.
            
             @param nDigest  the "n-digest" must produce 32 bytes of output - used for tree construction.
             @param twoNDigest the "2n-digest" must produce 64 bytes of output - used for initial message/key/seed hashing.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Prng.CryptoApiRandomGenerator">
            <summary>
            Uses Microsoft's RNGCryptoServiceProvider
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Prng.DigestRandomGenerator">
            Random generation based on the digest with counter. Calling AddSeedMaterial will
            always increase the entropy of the hash.
            <p>
            Internal access to the digest is synchronized so a single one of these can be shared.
            </p>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Prng.IRandomGenerator">
            <remarks>Generic interface for objects generating random bytes.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Prng.IRandomGenerator.AddSeedMaterial(System.Byte[])">
            <summary>Add more seed material to the generator.</summary>
            <param name="seed">A byte array to be mixed into the generator's state.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Prng.IRandomGenerator.AddSeedMaterial(System.Int64)">
            <summary>Add more seed material to the generator.</summary>
            <param name="seed">A long value to be mixed into the generator's state.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Prng.IRandomGenerator.NextBytes(System.Byte[])">
            <summary>Fill byte array with random values.</summary>
            <param name="bytes">Array to be filled.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Prng.IRandomGenerator.NextBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>Fill byte array with random values.</summary>
            <param name="bytes">Array to receive bytes.</param>
            <param name="start">Index to start filling at.</param>
            <param name="len">Length of segment to fill.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Signers.DsaDigestSigner.Update(System.Byte)">
            update the internal digest with the byte b
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Signers.DsaDigestSigner.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            update the internal digest with the byte array in
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Signers.DsaDigestSigner.GenerateSignature">
            Generate a signature for the message we've been loaded with using
            the key we were initialised with.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Signers.DsaDigestSigner.VerifySignature(System.Byte[])">
            <returns>true if the internal state represents the signature described in the passed in array.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Signers.DsaDigestSigner.Reset">
            <summary>Reset the internal state</summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Signers.DsaSigner">
            The Digital Signature Algorithm - as described in "Handbook of Applied
            Cryptography", pages 452 - 453.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Signers.DsaSigner.#ctor">
            Default configuration, random K values.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Signers.DsaSigner.#ctor(Org.BouncyCastle.Crypto.Internal.Signers.IDsaKCalculator)">
             Configuration with an alternate, possibly deterministic calculator of K.
            
             @param kCalculator a K value calculator.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Signers.DsaSigner.GenerateSignature(System.Byte[])">
             Generate a signature for the given message using the key we were
             initialised with. For conventional DSA the message should be a SHA-1
             hash of the message of interest.
            
             @param message the message that will be verified later.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Signers.DsaSigner.VerifySignature(System.Byte[],Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            return true if the value r and s represent a DSA signature for
            the passed in message for standard DSA the message should be a
            SHA-1 hash of the real message to be verified.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Signers.ECDsaSigner">
            EC-DSA as described in X9.62
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Signers.ECDsaSigner.#ctor">
            Default configuration, random K values.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Signers.ECDsaSigner.#ctor(Org.BouncyCastle.Crypto.Internal.Signers.IDsaKCalculator)">
             Configuration with an alternate, possibly deterministic calculator of K.
            
             @param kCalculator a K value calculator.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Signers.ECDsaSigner.GenerateSignature(System.Byte[])">
             Generate a signature for the given message using the key we were
             initialised with. For conventional DSA the message should be a SHA-1
             hash of the message of interest.
            
             @param message the message that will be verified later.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Signers.ECDsaSigner.VerifySignature(System.Byte[],Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            return true if the value r and s represent a DSA signature for
            the passed in message (for standard DSA the message should be
            a SHA-1 hash of the real message to be verified).
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Signers.GenericSigner.Init(System.Boolean,Org.BouncyCastle.Crypto.Internal.ICipherParameters)">
             initialise the signer for signing or verification.
            
             @param forSigning
                        true if for signing, false otherwise
             @param parameters
                        necessary parameters.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Signers.GenericSigner.Update(System.Byte)">
            update the internal digest with the byte b
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Signers.GenericSigner.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            update the internal digest with the byte array in
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Signers.GenericSigner.GenerateSignature">
            Generate a signature for the message we've been loaded with using the key
            we were initialised with.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Signers.GenericSigner.VerifySignature(System.Byte[])">
            return true if the internal state represents the signature described in
            the passed in array.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Signers.HMacDsaKCalculator">
            <summary>
            A deterministic K calculator based on the algorithm in section 3.2 of RFC 6979.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Signers.HMacDsaKCalculator.#ctor(Org.BouncyCastle.Crypto.Internal.IMac)">
            <summary>
            Base constructor.
            </summary>
            <param name="hMac">The HMAC to use in the calculator.</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Signers.IDsaKCalculator">
            <summary>
            Interface defining calculators of K values for DSA/ECDSA.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Internal.Signers.IDsaKCalculator.IsDeterministic">
            <summary>
            Return true if this calculator is deterministic, false otherwise.
            </summary>
            <value>><c>true</c> if this instance is deterministic; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Signers.IDsaKCalculator.Init(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Non-deterministic initialiser.
            </summary>
            <param name="n">The order of the DSA group.</param>
            <param name="random">A source of randomness.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Signers.IDsaKCalculator.Init(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,System.Byte[])">
            <summary>
            Deterministic initialiser.
            </summary>
            <param name="n">The order of the DSA group.</param>
            <param name="d">The DSA private value.</param>
            <param name="message">The message being signed.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Signers.IDsaKCalculator.NextK">
            <summary>
            Return the next valid value of K.
            </summary>
            <returns>A K value.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Signers.PssSigner">
            <summary> RSA-PSS as described in Pkcs# 1 v 2.1.
            <p>
            Note: the usual value for the salt length is the number of
            bytes in the hash function.</p>
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Signers.PssSigner.#ctor(Org.BouncyCastle.Crypto.Internal.IAsymmetricBlockCipher,Org.BouncyCastle.Crypto.Internal.IDigest,System.Int32)">
            <summary>Basic constructor</summary>
            <param name="cipher">the asymmetric cipher to use.</param>
            <param name="digest">the digest to use.</param>
            <param name="saltLen">the length of the salt to use (in bytes).</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Signers.PssSigner.ClearBlock(System.Byte[])">
            <summary> clear possible sensitive data</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Signers.PssSigner.Update(System.Byte)">
            <summary> update the internal digest with the byte b</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Signers.PssSigner.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary> update the internal digest with the byte array in</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Signers.PssSigner.Reset">
            <summary> reset the internal state</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Signers.PssSigner.GenerateSignature">
            <summary> Generate a signature for the message we've been loaded with using
            the key we were initialised with.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Signers.PssSigner.VerifySignature(System.Byte[])">
            <summary> return true if the internal state represents the signature described
            in the passed in array.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Signers.PssSigner.ItoOSP(System.Int32,System.Byte[])">
            <summary> int to octet string.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Signers.PssSigner.MaskGeneratorFunction1(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary> mask generator function, as described in Pkcs1v2.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Signers.RsaDigestSigner.#cctor">
            <summary>
            Load oid table.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Signers.RsaDigestSigner.Init(System.Boolean,Org.BouncyCastle.Crypto.Internal.ICipherParameters)">
             Initialise the signer for signing or verification.
            
             @param forSigning true if for signing, false otherwise
             @param param necessary parameters.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Signers.RsaDigestSigner.Update(System.Byte)">
            update the internal digest with the byte b
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Signers.RsaDigestSigner.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            update the internal digest with the byte array in
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Signers.RsaDigestSigner.GenerateSignature">
            Generate a signature for the message we've been loaded with using
            the key we were initialised with.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Signers.RsaDigestSigner.VerifySignature(System.Byte[])">
            return true if the internal state represents the signature described
            in the passed in array.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Signers.X931Signer">
            X9.31-1998 - signing using a hash.
            <p>
            The message digest hash, H, is encapsulated to form a byte string as follows
            </p>
            <pre>
            EB = 06 || PS || 0xBA || H || TRAILER
            </pre>
            where PS is a string of bytes all of value 0xBB of length such that |EB|=|n|, and TRAILER is the ISO/IEC 10118 part number for the digest. The byte string, EB, is converted to an integer value, the message representative, f.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Signers.X931Signer.#ctor(Org.BouncyCastle.Crypto.Internal.IAsymmetricBlockCipher,Org.BouncyCastle.Crypto.Internal.IDigest,System.Boolean)">
             Generate a signer with either implicit or explicit trailers for X9.31.
            
             @param cipher base cipher to use for signature creation/verification
             @param digest digest to use.
             @param implicit whether or not the trailer is implicit or gives the hash.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Signers.X931Signer.#ctor(Org.BouncyCastle.Crypto.Internal.IAsymmetricBlockCipher,Org.BouncyCastle.Crypto.Internal.IDigest)">
             Constructor for a signer with an explicit digest trailer.
            
             @param cipher cipher to use.
             @param digest digest to sign with.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Signers.X931Signer.ClearBlock(System.Byte[])">
            <summary> clear possible sensitive data</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Signers.X931Signer.Update(System.Byte)">
            update the internal digest with the byte b
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Signers.X931Signer.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            update the internal digest with the byte array in
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Signers.X931Signer.Reset">
            reset the internal state
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Signers.X931Signer.GenerateSignature">
            generate a signature for the loaded message using the key we were
            initialised with.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Signers.X931Signer.VerifySignature(System.Byte[])">
            return true if the signature represents a ISO9796-2 signature
            for the passed in message.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Wrappers.SP80038FWrapEngine">
            an implementation of the AES Key Wrapper from the NIST Key Wrap
            Specification as described in RFC 3394/SP800-38F.
            <p/>
            For further details see: <a href="http://www.ietf.org/rfc/rfc3394.txt">http://www.ietf.org/rfc/rfc3394.txt</a>
            and  <a href="http://csrc.nist.gov/encryption/kms/key-wrap.pdf">http://csrc.nist.gov/encryption/kms/key-wrap.pdf</a>.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Wrappers.SP80038FWrapEngine.#ctor(Org.BouncyCastle.Crypto.Internal.IBlockCipher,System.Boolean)">
             Create a RFC 3394 WrapEngine specifying the direction for wrapping and unwrapping..
            
             @param engine the block cipher to be used for wrapping.
             @param useReverseDirection true if engine should be used in decryption mode for wrapping, false otherwise.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Internal.Wrappers.SP80038FWrapWithPaddingEngine">
            an implementation of the AES Key Wrapper from the NIST Key Wrap
            Specification as described in RFC 3394/SP800-38F.
            <p/>
            For further details see: <a href="http://www.ietf.org/rfc/rfc3394.txt">http://www.ietf.org/rfc/rfc3394.txt</a>
            and  <a href="http://csrc.nist.gov/encryption/kms/key-wrap.pdf">http://csrc.nist.gov/encryption/kms/key-wrap.pdf</a>.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Internal.Wrappers.SP80038FWrapWithPaddingEngine.#ctor(Org.BouncyCastle.Crypto.Internal.IBlockCipher,System.Boolean)">
             Create a RFC 3394 WrapEngine specifying the direction for wrapping and unwrapping..
            
             @param engine the block cipher to be used for wrapping.
             @param useReverseDirection true if engine should be used in decryption mode for wrapping, false otherwise.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.InvalidCipherTextException">
            <summary>
            This exception is thrown whenever we find something we don't expect in a message
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.InvalidCipherTextException.#ctor">
            <summary>
            Base constructor.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.InvalidCipherTextException.#ctor(System.String)">
            <summary>
            Create a InvalidCipherTextException with the given message.
            </summary>
            <param name="message">The message to be carried with the exception.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.InvalidCipherTextException.#ctor(System.String,System.Exception)">
            <summary>
            Create a InvalidCipherTextException with the given message and underlying cause.
            </summary>
            <param name="message">The message to be carried with the exception.</param>
            <param name="exception">The exception that caused this exception to be raised.</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IOaepParameters`3">
            <summary>
            Base interface for OAEP parameters.
            </summary>
            <typeparam name="TParam">The type of the implementing parameter.</typeparam>
            <typeparam name="TAlg">The algorithm type for the parameters.</typeparam>
            <typeparam name="DAlg">The digest algorithm type for the parameters.</typeparam>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IOaepParameters`3.DigestAlgorithm">
            <summary>
            Return the digest algorithm associated with these parameters.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IOaepParameters`3.MgfDigestAlgorithm">
            <summary>
            Return the digest algorithm used in the mask generation function associated with these parameters.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IOaepParameters`3.GetEncodingParams">
            <summary>
            Return the encoding parameters to be used in the padding created from these parameters.
            </summary>
            <returns>A copy of the encoding parameters.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IOaepParameters`3.WithDigest(`2)">
            <summary>
             Create a new parameter instance with the OAEP encoding configured with the passed in digest.
             Note: this will also set the MGF digest to the same algorithm.
            </summary>
            <param name="digestAlgorithm">The base digest function to use for the OAEP encoding.</param>
            <returns>A new instance of the parameter object configured for the new digest.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IOaepParameters`3.WithMgfDigest(`2)">
            <summary>
            Create a new parameter instance with the mask generation function configured with the passed in digest.
            </summary>
            <param name="digestAlgorithm">The digest algorithm to use with the MGF.</param>
            <returns>A new instance of the parameter object configured for the new MGF digest.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IOaepParameters`3.WithEncodingParams(System.Byte[])">
            <summary>
            Create a new parameter instance configured with the passed in salt.
            </summary>
            <param name="encodingParams">A specific encoding parameter to use with the OAEP encoding.</param>
            <returns>A new instance of the parameter object configured for the new encoding parameter.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IParameters`1">
            <summary>
            Base interface for operator parameters.
            </summary>
            <typeparam name="TAlg">The algorithm type for the parameters.</typeparam>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IParameters`1.Algorithm">
            <summary>
            Return the algorithm these parameters are associated with.
            </summary>
            <value>The algorithm these parameters are for.</value>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IParametersWithIV`2">
            <summary>
            Base interface for parameters with initialization vectors or nonces.
            </summary>
            <typeparam name="TParam">The type of the implementing parameter.</typeparam>
            <typeparam name="TAlg">The algorithm type for the parameters.</typeparam>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IParametersWithIV`2.GetIV">
            <summary>
            Return the initialization vector associated with this parameter set.
            </summary>
            <returns>the IV for these parameters.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IParametersWithIV`2.WithIV(System.Byte[])">
            <summary>
            Create a new parameter set with a different IV.
            </summary>
            <param name="iv">the IV to use.</param>
            <returns>A copy of the current parameter set with the new IV.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IParametersWithIV`2.WithIV(Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Create a new parameter set with a different IV based on the output of the passed in random.
            </summary>
            <param name="random">The SecureRandom to use as the source of IV data.</param>
            <returns>A copy of the current parameter set with the new IV.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IPasswordBasedDeriver`1">
            <summary>
            Base interface for password based key derivers.
            </summary>
            <typeparam name="A">Type for the deriver's configuration parameters.</typeparam>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IPasswordBasedDeriver`1.AlgorithmDetails">
            <summary>
            Return the parameters for this deriver.
            </summary>
            <returns>the deriver's parameters.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IPasswordBasedDeriver`1.DeriveKey(Org.BouncyCastle.Crypto.TargetKeyType,System.Int32)">
            <summary>
            Derive a key of the given keySizeInBytes length.
            </summary>
            <returns>A byte array containing the raw key data.</returns>
            <param name="keyType">Type of key to be calculated.</param>
            <param name="keySizeInBytes">The number of bytes to be produced.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IPasswordBasedDeriver`1.DeriveKeyAndIV(Org.BouncyCastle.Crypto.TargetKeyType,System.Int32,System.Int32)">
            <summary>
            Derive a key of the given keySizeInBytes length and an iv of ivSizeInBytes length.
            </summary>
            <returns>a 2 element byte[] array containing the raw key data in element 0, the iv in element 1.</returns>
            <param name="keyType">Type of key to be calculated.</param>
            <param name="keySizeInBytes">The number of bytes to be produced for the key data.</param>
            <param name="ivSizeInBytes">The number of bytes to be produced for the IV data.</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IPasswordBasedDeriverBuilder`1">
            <summary>
            Base interface for a builder of password derivers.
            </summary>
            <typeparam name="A">Type for the deriver builder's configuration parameters.</typeparam>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IPasswordBasedDeriverBuilder`1.WithPrf(Org.BouncyCastle.Crypto.DigestAlgorithm)">
            <summary>
            Return a new builder configured with the passed in digest as the pseudo random function for derivers produced.
            </summary>
            <param name="digestAlgorithm">The digest algorithm to use as a PRF.</param>
            <returns>A new builder.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IPasswordBasedDeriverBuilder`1.WithSalt(System.Byte[])">
            <summary>
            Return a new builder configured with the passed in salt for derivers it builds.
            </summary>
            <param name="salt">The salt to use with the PRF.</param>
            <returns>A new builder.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IPasswordBasedDeriverBuilder`1.WithIterationCount(System.Int32)">
            <summary>
            Return a new builder configured with the passed in iteration count for derivers it builds. 
            </summary>
            <param name="iterationCount">The iteration count to use with the PRF.</param>
            <returns>A new builder.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IPasswordBasedDeriverBuilder`1.Build">
            <summary>
            Build a key deriver based on the current configuration.
            </summary>
            <returns>a new password based key deriver.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IPasswordBasedDeriverBuilderService`1">
            <summary>
            Service interface for a password based key deriver builder.
            </summary>
            <typeparam name="A">Type for configuration parameters used to create derivers produced by this service.</typeparam>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IPasswordBasedDeriverBuilderService`1.From(System.Byte[])">
            <summary>
            Construct a builder from the passed in password encoding.
            </summary>
            <param name="password">a byte encoding of the password.</param>
            <returns></returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IPasswordBasedDeriverBuilderService`1.From(Org.BouncyCastle.Crypto.PasswordConverter,System.Char[])">
            <summary>
            Construct a builder from the passed in password as converted by converter.
            </summary>
            <param name="converter">a converter to use to convert the password into bytes.</param>
            <param name="password">a password as a char array.</param>
            <returns></returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IPasswordBasedDeriverProvider`1">
            <summary>
            Base interface for a provider to support the dynamic creation of password based derivers.
            </summary>
            <typeparam name="A">Type for configuration parameters used to create derivers produced by this provider.</typeparam>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IPasswordBasedDeriverProvider`1.CreateDeriver(`0)">
            <summary>
            Return a password based deriver for the algorithm details passed in.
            </summary>
            <param name="algorithmDetails">The details of the password to key derivation algorithm the deriver is for.</param>
            <returns>A new password based deriver.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IPssSignatureParameters`3">
            <summary>
            Base interface for PSS signature parameters.
            </summary>
            <typeparam name="TParam">The type of the implementing parameter.</typeparam>
            <typeparam name="TAlg">The algorithm type for the parameters.</typeparam>
            <typeparam name="DAlg">The digest algorithm type for the parameters.</typeparam>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IPssSignatureParameters`3.DigestAlgorithm">
            <summary>
            Return the digest algorithm for processing the message to be signed.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IPssSignatureParameters`3.MgfDigestAlgorithm">
            <summary>
            Return the digest algorithm to be used in the mask generation function.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IPssSignatureParameters`3.SaltLength">
            <summary>
            Return the length of the salt specified for these parameters.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IPssSignatureParameters`3.GetSalt">
            <summary>
            Return the fixed salt the parameters are configured with, if present.
            </summary>
            <returns>The fixed salt if available, null otherwise.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IPssSignatureParameters`3.WithDigest(`2)">
            <summary>
            Set the digest algorithm. Note: this will also set the MGF digest to the same algorithm.
            </summary>
            <param name="digestAlgorithm">The digest algorithm to use.</param>
            <returns>A new parameter set with the changed configuration.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IPssSignatureParameters`3.WithMgfDigest(`2)">
            <summary>
            Create a new parameter instance with the mask generation function configured with the passed in digest.
            </summary>
            <param name="digestAlgorithm">The digest algorithm to use with the MGF.</param>
            <returns>A new instance of the parameter object configured for the new MGF digest.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IPssSignatureParameters`3.WithSalt(System.Byte[])">
            <summary>
            Create a new parameter instance with a static salt configured for signatures generated.
            </summary>
            <param name="salt"></param>
            <returns>A new instance of the parameter object configured for the new salt.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IPssSignatureParameters`3.WithSaltLength(System.Int32)">
            <summary>
            Create a new parameter instance with a specific salt length configured for signatures generated.
            </summary>
            <param name="saltLength">The length of the salt to use, or assume.</param>
            <returns>A new instance of the parameter object configured for the new salt length.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IRecoveredMessage">
            <summary>
            Base interface for a recovered message object.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IRecoveredMessage.IsFullMessage">
            <summary>
            Return true if the full message has been recovered, false if only partially.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IRecoveredMessage.GetContent">
            <summary>
            Return a byte array representing the message data recovered.
            </summary>
            <returns>The recovered content.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.ISignatureFactory`1">
            <summary>
            Base interface for operator factories that create stream-based signature calculators.
            </summary>
            <typeparam name="A">Configuration parameters used to create the factory.</typeparam>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.ISignatureFactory`1.AlgorithmDetails">
            <summary>The algorithm details object for calculators made by this factory.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ISignatureFactory`1.CreateCalculator">
            <summary>
            Create a stream calculator for the signature algorithm associated with this factory. The stream
            calculator is used for the actual operation of entering the data to be signed
            and producing the signature block.
            </summary>
            <returns>A calculator producing an IBlockResult with the final signature in it.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.ISignatureFactoryService">
            <summary>
            Base interface for a service to support the creation of signature factories.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ISignatureFactoryService.CreateSignatureFactory``1(``0)">
            <summary>
            Return a signature factory for signature algorithm described in the passed in algorithm details object.
            </summary>
            <param name="algorithmDetails">The details of the signature algorithm verification is required for.</param>
            <returns>A new signature factory.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.ISignatureParameters`3">
            <summary>
            Base interface for signature parameters.
            </summary>
            <typeparam name="TParam">The type of the implementing parameter.</typeparam>
            <typeparam name="TAlg">The algorithm type for the parameters.</typeparam>
            <typeparam name="DAlg">The digest algorithm type for the parameters.</typeparam>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.ISignatureParameters`3.DigestAlgorithm">
            <summary>
            Return the digest algorithm for processing the message to be signed.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ISignatureParameters`3.WithDigest(`2)">
            <summary>
            Set the digest algorithm.
            </summary>
            <param name="digestAlgorithm">The digest algorithm to use.</param>
            <returns>A new parameter set with the changed configuration.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.ISignatureWithDigestFactory`1">
            <summary>
            Extension to ISignatureFactory which allows for recovery of the calculated message digest.
            </summary>
            <typeparam name="A">Configuration parameters used to create the factory.</typeparam>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ISignatureWithDigestFactory`1.CreateCalculatorWithDigest">
            <summary>
            Create a stream calculator for this signature factory. The stream
            calculator is used for the actual operation of entering the data to be signed
            and producing the signature block and its associated digest.
            </summary>
            <returns>A calculator producing an IBlockResultWithRecovered with a signature and the calculated digest in it.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.ISignatureWithRecoveredMessageFactory`1">
            <summary>
            An extension to ISignatureFactory which adds recovered messages.
            </summary>
            <typeparam name="A">Configuration parameters used to create the factory.</typeparam>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ISignatureWithRecoveredMessageFactory`1.CreateCalculatorWithRecoveredMessage">
            <summary>
            Create a stream calculator for this signature calculator. The stream
            calculator is used for the actual operation of entering the data to be signed
            and producing the signature block.
            </summary>
            <returns>A calculator producing an IBlockResultWithRecovered with a signature and the recovered message in it.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IStreamCalculator`1">
            <summary>
            Base interface for cryptographic operations such as Hashes, MACs, and Signatures which reduce a stream of data
            to a single value.
            </summary>
            <typeparam name="TResult">Type of the result produced by this calculator.</typeparam>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IStreamCalculator`1.Stream">
            <summary>Return a "sink" stream which only exists to update the implementing object.</summary>
            <returns>A stream to write to in order to update the implementing object.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IStreamCalculator`1.GetResult">
            <summary>
            Return the result of processing the stream. This value is only available once the stream
            has been closed.
            </summary>
            <returns>The result of processing the stream.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.ISymmetricKey">
            <summary>
            Interface describing a symmetric key.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ISymmetricKey.GetKeyBytes">
            <summary>
            Return the bytes associated with this key.
            </summary>
            <returns>Key bytes, null or exception if they are not available.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.ISymmetricKeyGenerator`1">
            <summary>
            Base interface for symmetric key generators.
            </summary>
            <typeparam name="A"></typeparam>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ISymmetricKeyGenerator`1.GenerateKey">
            <summary>
            Generate a new key.
            </summary>
            <returns>A new key.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IVariableStreamCalculator`1.GetResult(System.Int32)">
            <summary>
            Return a result of processing the stream with a specified length. This value is only available once the stream
            has been closed.
            </summary>
            <returns>The result.</returns>
            <param name="outputLength">The length of the result expected in the result object.</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IVerifier">
            <summary>
            Operators that reduce their input to the verification of a signature produce this type.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IVerifier.IsVerified(System.Byte[])">
            <summary>
            Return true if the passed in data matches what is expected by the verifier.
            </summary>
            <param name="data">The bytes representing the signature.</param>
            <returns>true if the signature verifies, false otherwise.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IVerifier.IsVerified(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Return true if the length bytes from off in the source array match the signature
            expected by the verifier.
            </summary>
            <param name="source">Byte array containing the signature.</param>
            <param name="off">The offset into the source array where the signature starts.</param>
            <param name="length">The number of bytes in source making up the signature.</param>
            <returns>true if the signature verifies, false otherwise.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IVerifierFactory`1">
            <summary>
            Base interface for factories that produce stream-based signature verifiers.
            </summary>
            <typeparam name="A">Configuration parameters type for the verifiers.</typeparam>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IVerifierFactory`1.AlgorithmDetails">
            <summary>The algorithm details object for this verifier.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IVerifierFactory`1.CreateCalculator">
            <summary>
            Create a stream calculator for this verifier. The stream
            calculator is used for the actual operation of entering the data to be verified
            and producing a result which can be used to verify the original signature.
            </summary>
            <returns>A calculator producing an IVerifier which can verify the signature.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IVerifierFactoryProvider`1">
            <summary>
            Base interface for a provider to support the dynamic creation of signature verifier factories.
            </summary>
            <typeparam name="A">Type for the configuration parameters for the verifier this provider produces.</typeparam>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IVerifierFactoryProvider`1.CreateVerifierFactory(`0)">
            <summary>
            Return a signature verifier factory for signature algorithm described in the passed in algorithm details object.
            </summary>
            <param name="algorithmDetails">The details of the signature algorithm verification is required for.</param>
            <returns>A new signature verifier factory.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IVerifierFactoryService">
            <summary>
            Service interface for creating verifier factory objects.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IVerifierFactoryService.CreateVerifierFactory``1(``0)">
            <summary>
            Return a new verifier factory configured according to the contents of algorithmDetails.
            </summary>
            <typeparam name="A">The type of the configuration parameters.</typeparam>
            <param name="algorithmDetails">The configuration parameters to use to configure the factory.</param>
            <returns>A new verifier factory.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IVerifierWithRecoveredMessage">
            <summary>
            Extension interface for a verifier which includes a recovered message.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IVerifierWithRecoveredMessage.GetRecoveredMessage">
            <summary>
            Return the recovered message picked up as a result of verification.
            </summary>
            <returns>The recovered message found in the verified signature.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IVerifierWithRecoveredMessageFactory">
            <summary>
            Factory for verifiers which include recovered messages.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IVerifierWithRecoveredMessageFactory.CreateCalculatorWithRecoveredMessage">
            <summary>
            Create a stream calculator for this signature calculator. The stream
            calculator is used for the actual operation of entering the data to be verified
            against a pre-existing signature.
            </summary>
            <returns>A calculator producing an IVerifierWithRecoveredMessage with a verifier and the recovered message in it.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IXofFactory`1">
            <summary>
            Base interface for operator factories that create eXpandable Output Functions (XOF).
            </summary>
            <typeparam name="A">Type for the configuration parameters for the verifier this provider produces.</typeparam>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IXofFactory`1.AlgorithmDetails">
            <summary>The algorithm details object for calculators made by this factory.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IXofFactory`1.CreateCalculator">
            <summary>
            Create a stream calculator for the XOF associated with this factory. The stream
            calculator is used for the actual operation of entering the data to be processed
            and producing the XOF output.
            </summary>
            <returns>A calculator producing an IBlockResult containing the output from the XOF.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IXofFactoryProvider`1">
            <summary>
            Provider interface for providers of XOF factory objects.
            </summary>
            <typeparam name="A">Type for the configuration parameters for the verifier this provider produces.</typeparam>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IXofFactoryProvider`1.CreateXofFactory(`0)">
            <summary>
            Create a new XOF factory using the passed in parameters.
            </summary>
            <param name="algorithmDetails">Configuration parameters for the XOF factory.</param>
            <returns>A new factory for producing XOFs</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.KdfAlgorithm">
            <summary>
            Specific Algorithm for representing pairing of a base algorithm and a PRF in a KDF.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.KdfAlgorithm.Kdf">
            <summary>
            Return the algorithm representing the KDF.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.KdfAlgorithm.Prf">
            <summary>
            Return an algorithm representing the PRF used by the KDF.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.MacFactory`1.AlgorithmDetails">
            <summary>The algorithm details object for calculators made by this factory.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.MacFactory`1.CreateCalculator">
            <summary>
            Create a stream calculator for the digest algorithm associated with this factory. The stream
            calculator is used for the actual operation of entering the data to be digested
            and producing the digest block.
            </summary>
            <returns>A calculator producing an IBlockResult with the final digest in it.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding">
            <summary>
            Block cipher padders are expected to conform to this interface
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding.PaddingName">
            <summary>
            Return the name of the algorithm the cipher implements.
            </summary>
            <returns>
            The name of the algorithm the cipher implements.
            </returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding.AddPadding(System.Byte[],System.Int32)">
            <summary>
            Add the pad bytes to the passed in block, returning the number of bytes added.
            </summary>
            <returns>
            The number of pad bytes added.
            </returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding.PadCount(System.Byte[])">
            <summary>
            Return the number of pad bytes present in the block.
            </summary>
            <returns>
            The number of pad bytes present in the block.
            </returns> 
            <exception cref="T:Org.BouncyCastle.Crypto.InvalidCipherTextException">If the padding is badly formed or invalid</exception>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Paddings.ISO10126d2Padding">
            <summary>
             A padder that adds ISO10126-2 padding to a block.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.ISO10126d2Padding.#ctor(Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Base constructor providing a source of randomness.
            </summary>
            <param name="random">A SecureRandom</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Paddings.ISO7816d4Padding">
            <summary>
            A padder that adds the padding according to the scheme referenced in
            ISO 7814-4 - scheme 2 from ISO 9797-1. The first byte is 0x80, rest is 0x00
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Paddings.Pkcs7Padding">
            <summary>
            A padder that adds Pkcs7/Pkcs5 padding to a block.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Paddings.TbcPadding">
            <summary>
             A padder that adds Trailing Bit Complement (TBC) padding to a block.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Paddings.X923Padding">
            <summary>
            A padder that adds X9.23 padding to a block - if a SecureRandom is
            passed in random padding is assumed, otherwise padding with zeros is used.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.X923Padding.#ctor(Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Base constructor providing a source of randomness or null if zero padding required.
            </summary>
            <param name="random">A SecureRandom (may be null)</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Parameters.AgreementParameters`4">
            <summary>
            Base class for key agreement parameters.
            </summary>
            <typeparam name="TAlg">Acceptable algorithm type.</typeparam>
            <typeparam name="TDigest">Acceptable digest algorithm type.</typeparam>
            <typeparam name="TPrf">Acceptable PRF type.</typeparam>
            <typeparam name="TKdf">Acceptable KDF type.</typeparam>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.AgreementParameters`4.#ctor(`0,`2,System.Byte[])">
            <summary>
            Constructor which specifies returning a MAC/HMAC of the raw secret on agreement calculation using one of the
            standard PRFs as described in SP800-56C.
            </summary>
            <param name="agreementAlgorithm">The agreement algorithm these parameters are for.</param>
            <param name="prfAlgorithm">The MAC/HMAC algorithm to use.</param>
            <param name="salt">The byte string to key the MAC/HMAC with.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.AgreementParameters`4.#ctor(`0,`3,System.Byte[],System.Int32)">
            <summary>
            Constructor with a KDF to process the Z value with. The outputSize parameter determines how many bytes
            will be generated.
            </summary>
            <param name="agreementAlgorithm">The agreement algorithm these parameters are for.</param>
            <param name="kdf">KDF algorithm type to use for parameter creation.</param>
            <param name="iv">The iv parameter for KDF initialization.</param>
            <param name="outputSize">The size of the output to be generated from the KDF.</param>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Parameters.AgreementParameters`4.Kdf">
            <summary>
            Return the KDF algorithm type.
            </summary>
            <value>The KDF algorithm, null if not present.</value>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Parameters.AgreementParameters`4.OutputSize">
            <summary>
            Return the size of the output required from the KDF.
            </summary>
            <value>The number of bytes to be generated by a KDF using these parameters.</value>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.AgreementParameters`4.GetSalt">
            <summary>
            Return the salt/iv associated with these parameters.
            </summary>
            <returns>The salt, null if not present.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Parameters.AuthenticationParameters`2.MacSizeInBits">
            <summary>
            Return the size of the MAC these parameters are for.
            </summary>
            <value>The MAC size in bits.</value>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.AuthenticationParameters`2.WithMacSize(System.Int32)">
            <summary>
            Create a new parameter set with the specified MAC size associated with it.
            </summary>
            <returns>The new parameter set.</returns>
            <param name="macSizeInBits">Mac size in bits.</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Parameters.AuthenticationParametersWithIV`2">
            <summary>
            Base class for authentications parameters with IVs associated with them (e.g. for CCM, etc)
            </summary>
            <typeparam name="TParam">Extending type.</typeparam>
            <typeparam name="TAlg">Algorithm type associated with extending class.</typeparam>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.AuthenticationParametersWithIV`2.GetIV">
            <summary>
            Return a copy of the IV, null if there isn't one.
            </summary>
            <returns>A copy of the IV.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.AuthenticationParametersWithIV`2.WithIV(System.Byte[])">
            <summary>
            Create a new parameter set with a different IV.
            </summary>
            <returns>A copy of the current parameter set with the new IV.</returns>
            <param name="iv">The IV to use.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.AuthenticationParametersWithIV`2.WithIV(Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Create a new parameter set with a different IV based on the output
            of the passed in random.
            </summary>
            <returns>A copy of the current parameter set with the new IV.</returns>
            <param name="random">A SecureRandom for deriving the IV.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.AuthenticationParametersWithIV`2.WithIV(Org.BouncyCastle.Security.SecureRandom,System.Int32)">
            <summary>
            Create a new parameter set with a different IV based on the output
            of the passed in random.
            </summary>
            <returns>A copy of the current parameter set with the new IV.</returns>
            <param name="random">A SecureRandom for deriving the IV.</param>
            <param name="ivLen">Length of the IV to generate.</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Parameters.OaepParameters`3">
            <summary>
            Base class for OAEP parameter objects.
            </summary>
            <typeparam name="TParam">The actual parameter type.</typeparam>
            <typeparam name="TAlg">The algorithm type for the parameters.</typeparam>
            <typeparam name="DAlg">The digest algorithm type for the parameters.</typeparam>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Parameters.OaepParameters`3.DigestAlgorithm">
            <summary>
            Return the digest algorithm associated with these parameters.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Parameters.OaepParameters`3.MgfDigestAlgorithm">
            <summary>
            Return the digest algorithm used in the mask generation function associated with these parameters.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.OaepParameters`3.GetEncodingParams">
            <summary>
            Return the encoding parameters to be used in the padding created from these parameters.
            </summary>
            <returns>A copy of the encoding parameters.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.OaepParameters`3.WithDigest(`2)">
            <summary>
            Return a new parameters object which uses the passed in digest algorithm in the OAEP padding.
            </summary>
            <param name="digestAlgorithm">A digest algorithm.</param>
            <returns>A new parameters object.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.OaepParameters`3.WithMgfDigest(`2)">
            <summary>
            Return a new parameters object which uses the passed in digest algorithm for its mask generation function.
            </summary>
            <param name="digestAlgorithm">The digest algorithm to be used in the MGF.</param>
            <returns>A new parameters object.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.OaepParameters`3.WithEncodingParams(System.Byte[])">
            <summary>
            Return a new parameters object which includes the passed in encoding parameters.
            </summary>
            <param name="encodingParams">The encoding parameters to be included.</param>
            <returns>A new parameters object.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.ParametersWithIV`2.WithIV(System.Byte[])">
            <summary>
            Create a new parameter set with a different IV.
            </summary>
            <returns>A copy of the current parameter set with the new IV.</returns>
            <param name="iv">The IV to use.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.ParametersWithIV`2.WithIV(Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Create a new parameter set with a different IV based on the output
            of the passed in random.
            </summary>
            <returns>A copy of the current parameter set with the new IV.</returns>
            <param name="random">A SecureRandom for deriving the IV.</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Parameters.PssSignatureParameters`3">
            <summary>
            Base class for PSS signature parameters.
            </summary>
            <typeparam name="TParam">Type extending this one.</typeparam>
            <typeparam name="TAlg">The type of algorithm the parameters are for.</typeparam>
            <typeparam name="DAlg">The type of digest the parameters are for.</typeparam>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Parameters.PssSignatureParameters`3.DigestAlgorithm">
            <summary>
            Return the digest algorithm for processing the message to be signed.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Parameters.PssSignatureParameters`3.MgfDigestAlgorithm">
            <summary>
            Return the digest algorithm to be used in the mask generation function.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Parameters.PssSignatureParameters`3.SaltLength">
            <summary>
            Return the length of the salt specified for these parameters.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.PssSignatureParameters`3.GetSalt">
            <summary>
            Return the fixed salt the parameters are configured with, if present.
            </summary>
            <returns>The fixed salt if available, null otherwise.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.PssSignatureParameters`3.WithDigest(`2)">
            <summary>
            Set the digest algorithm. Note: this will also set the MGF digest to the same algorithm.
            </summary>
            <param name="digestAlgorithm">The digest algorithm to use.</param>
            <returns>A new parameter set with the changed configuration.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.PssSignatureParameters`3.WithMgfDigest(`2)">
            <summary>
            Set the MGF digest algorithm explicitly.
            </summary>
            <param name="digestAlgorithm">The digest algorith to use for mask generation.</param>
            <returns>A new parameter set with the changed configuration.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.PssSignatureParameters`3.WithSalt(System.Byte[])">
            <summary>
            Provide a fixed salt value to use with the signature.
            </summary>
            <param name="salt">A fixed salt value to use.</param>
            <returns>A new parameter set with the changed configuration.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.PssSignatureParameters`3.WithSaltLength(System.Int32)">
            <summary>
            Specify a length for the salt value in the signature.
            </summary>
            <param name="saltLength">The length of the salt to use.</param>
            <returns>A new parameter set with the changed configuration.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.PrfAlgorithm">
            <summary>
            Specific type for representing algorithms which act as pseudo-random-functions. 
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.SelfTestFailedError.#ctor(System.String,Org.BouncyCastle.Crypto.Algorithm)">
            <summary>
            Base constructor.
            </summary>
            <param name="message">A message describing the error.</param>
            <param name="algorithm">The algorithm the failure was for.</param>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.SignatureFactory`1.AlgorithmDetails">
            <summary>The algorithm details object for calculators made by this factory.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.SignatureFactory`1.CreateCalculator">
            <summary>
            Create a stream calculator for the signature algorithm associated with this factory. The stream
            calculator is used for the actual operation of entering the data to be signed
            and producing the signature block.
            </summary>
            <returns>A calculator producing an IBlockResult with the final signature in it.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.SimpleBlockResult">
            <summary>
            A simple block result object which just carries a byte array.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.SimpleBlockResult.#ctor(System.Byte[])">
            <summary>
            Base constructor - a wrapper for the passed in byte array.
            </summary>
            <param name="result">The byte array to be wrapped.</param>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.SimpleBlockResult.Length">
            <summary>
            Return the number of bytes in the result
            </summary>
            <value>The length of the result in bytes.</value>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.SimpleBlockResult.Collect">
            <summary>
            Return the final result of the operation.
            </summary>
            <returns>A block of bytes, representing the result of an operation.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.SimpleBlockResult.Collect(System.Byte[],System.Int32)">
            <summary>
            Store the final result of the operation by copying it into the destination array.
            </summary>
            <returns>The number of bytes copied into destination.</returns>
            <param name="destination">The byte array to copy the result into.</param>
            <param name="offset">The offset into destination to start copying the result at.</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.SymmetricSecretKey">
            <summary>
            Base class for symmetric secret keys.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.SymmetricSecretKey.#ctor(Org.BouncyCastle.Crypto.Algorithm,System.Byte[])">
            <summary>
            Base constructor.
            </summary>
            <param name="algorithm">The algorithm this secret key is associated with.</param>
            <param name="bytes">The bytes representing the key's value.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.SymmetricSecretKey.#ctor(Org.BouncyCastle.Crypto.IParameters{Org.BouncyCastle.Crypto.Algorithm},System.Byte[])">
            <summary>
            Base constructor for a specific algorithm associated with a parameter set.
            </summary>
            <param name="parameterSet">The parameter set with the algorithm this secret key is associated with.</param>
            <param name="bytes">The bytes representing the key's value.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.SymmetricSecretKey.#ctor(Org.BouncyCastle.Crypto.Fips.FipsShs.AuthenticationParameters,System.Byte[])">
            <summary>
            Specific constructor for a SHS authentication parameters.
            </summary>
            <param name="parameterSet">The parameter set with the algorithm this secret key is associated with.</param>
            <param name="bytes">The bytes representing the key's value.</param>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.SymmetricSecretKey.Algorithm">
            <summary>
            Return the algorithm this secret key is for.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.SymmetricSecretKey.GetKeyBytes">
            <summary>
            Return the bytes representing this keys value.
            </summary>
            <returns>The bytes making up this key.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.TargetKeyType">
            <summary>
            The target key type a deriver is trying to produce a key for.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.TargetKeyType.CIPHER">
            <summary>
            Target key for a symmetric cipher.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.TargetKeyType.MAC">
            <summary>
            Target key for a MAC.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Utilities.BasicEntropySourceProvider">
            <summary>
            An EntropySourceProvider where entropy generation is based on a SecureRandom output using SecureRandom.generateSeed().
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Utilities.BasicEntropySourceProvider.#ctor(Org.BouncyCastle.Security.SecureRandom,System.Boolean)">
            <summary>
            Create a entropy source provider based on the passed in SecureRandom.
            </summary>
            <param name="random">The SecureRandom to base EntropySource construction on.</param>
            <param name="isPredictionResistant">Boolean indicating if the SecureRandom is based on prediction resistant entropy or not (true if it is)</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Utilities.BasicEntropySourceProvider.Get(System.Int32)">
            <summary>
            Return an entropy source that will create bitsRequired bits of entropy on each invocation of getEntropy().
            </summary>
            <param name="bitsRequired">Size (in bits) of entropy to be created by the provided source.</param>
            <returns>An EntropySource that generates bitsRequired bits of entropy on each call to its getEntropy() method.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Utilities.ByteMacData">
            <summary>
            Builder and holder class for preparing SP 800-56A/56B compliant MacData. Elements in the data are copied in
            directly as byte arrays.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Utilities.ByteMacData.Type">
            <summary>
            Standard type strings for the headers of KAS/KTS MAC calculations.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Utilities.ByteMacData.Builder">
            <summary>
            Builder to create OtherInfo
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Utilities.ByteMacData.Builder.#ctor(Org.BouncyCastle.Crypto.Utilities.ByteMacData.Type,System.Byte[],System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Create a basic builder with just the compulsory fields.
            </summary>
            <param name="type">the MAC header</param>
            <param name="idU">sender party ID.</param>
            <param name="idV">receiver party ID.</param>
            <param name="ephemDataU">ephemeral data from sender.</param>
            <param name="ephemDataV">ephemeral data from receiver.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Utilities.ByteMacData.Builder.WithText(System.Byte[])">
            <summary>
            Add optional text.
            </summary>
            <param name="text">optional agreed text to add to the MAC.</param>
            <returns>the current builder instance.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Utilities.ByteMacData.Builder.Build">
            <summary>
            Build the MacData from the inputs.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.VerifierFactory`1.AlgorithmDetails">
            <summary>The algorithm details object for calculators made by this factory.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.VerifierFactory`1.CreateCalculator">
            <summary>
            Create a stream calculator for the signature algorithm associated with this factory. The stream
            calculator is used for the actual operation of entering the data to be signed
            and producing the signature block.
            </summary>
            <returns>A calculator producing an IBlockResult with the final signature in it.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.XofCalculator.GetResult">
            <summary>
            Gets the result.
            </summary>
            <returns>The result.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.XofCalculator.GetResult(System.Int32)">
            <summary>
            Gets the result.
            </summary>
            <returns>The result.</returns>
            <param name="outputLength">The length (in bytes) of the output wanted from the XOF.</param>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.XofFactory`1.AlgorithmDetails">
            <summary>The algorithm details object for calculators made by this factory.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.XofFactory`1.CreateCalculator">
            <summary>
            Create a stream calculator for the XOF associated with this factory. The stream
            calculator is used for the actual operation of entering the data to be processed
            and producing the XOF output.
            </summary>
            <returns>A calculator producing an StreamResult which can be used to read the output from the XOF.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.AddMagnitudes(System.Int32[],System.Int32[])">
            return a = a + b - b preserved.
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.CompareTo(System.Int32,System.Int32[],System.Int32,System.Int32[])">
            unsigned comparison on two arrays - note the arrays may
            start with leading zeros.
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.Divide(System.Int32[],System.Int32[])">
            return z = x / y - done in place (z value preserved, x contains the
            remainder)
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.IsProbablePrime(System.Int32)">
            return whether or not a BigInteger is probably prime with a
            probability of 1 - (1/2)**certainty.
            <p>From Knuth Vol 2, pg 395.</p>
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.ExtEuclid(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger@)">
             Calculate the numbers u1, u2, and u3 such that:
            
             u1 * a + u2 * b = u3
            
             where u3 is the greatest common divider of a and b.
             a and b using the extended Euclid algorithm (refer p. 323
             of The Art of Computer Programming vol 2, 2nd ed).
             This also seems to have the side effect of calculating
             some form of multiplicative inverse.
            
             @param a    First number to calculate gcd for
             @param b    Second number to calculate gcd for
             @param u1Out      the return object for the u1 value
             @return     The greatest common divisor of a and b
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.Square(System.Int32[],System.Int32[])">
            return w with w = x * x - w is assumed to have enough space.
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.Multiply(System.Int32[],System.Int32[],System.Int32[])">
            return x with x = y * z - x is assumed to have enough space.
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.GetMQuote">
            Calculate mQuote = -m^(-1) mod b with b = 2^32 (32 = word size)
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.MultiplyMonty(System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.UInt32,System.Boolean)">
            Montgomery multiplication: a = x * y * R^(-1) mod m
            <br/>
            Based algorithm 14.36 of Handbook of Applied Cryptography.
            <br/>
            <li> m, x, y should have length n </li>
            <li> a should have length (n + 1) </li>
            <li> b = 2^32, R = b^n </li>
            <br/>
            The result is put in x
            <br/>
            NOTE: the indices of x, y, m, a different in HAC and in Java
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.Remainder(System.Int32[],System.Int32[])">
            return x = x % y - done in place (y value preserved)
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.ShiftLeft(System.Int32[],System.Int32)">
            do a left shift - this returns a new array.
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.ShiftRightInPlace(System.Int32,System.Int32[],System.Int32)">
            do a right shift - this does it in place.
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.ShiftRightOneInPlace(System.Int32,System.Int32[])">
            do a right shift by one - this does it in place.
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.Subtract(System.Int32,System.Int32[],System.Int32,System.Int32[])">
            returns x = x - y - we assume x is >= y
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Abc.SimpleBigDecimal">
            Class representing a simple version of a big decimal. A
            <code>SimpleBigDecimal</code> is basically a
            {@link java.math.BigInteger BigInteger} with a few digits on the right of
            the decimal point. The number of (binary) digits on the right of the decimal
            point is called the <code>scale</code> of the <code>SimpleBigDecimal</code>.
            Unlike in {@link java.math.BigDecimal BigDecimal}, the scale is not adjusted
            automatically, but must be set manually. All <code>SimpleBigDecimal</code>s
            taking part in the same arithmetic operation must have equal scale. The
            result of a multiplication of two <code>SimpleBigDecimal</code>s returns a
            <code>SimpleBigDecimal</code> with double scale.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.SimpleBigDecimal.GetInstance(Org.BouncyCastle.Math.BigInteger,System.Int32)">
            Returns a <code>SimpleBigDecimal</code> representing the same numerical
            value as <code>value</code>.
            @param value The value of the <code>SimpleBigDecimal</code> to be
            created. 
            @param scale The scale of the <code>SimpleBigDecimal</code> to be
            created. 
            @return The such created <code>SimpleBigDecimal</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.SimpleBigDecimal.#ctor(Org.BouncyCastle.Math.BigInteger,System.Int32)">
            Constructor for <code>SimpleBigDecimal</code>. The value of the
            constructed <code>SimpleBigDecimal</code> Equals <code>bigInt / 
            2<sup>scale</sup></code>.
            @param bigInt The <code>bigInt</code> value parameter.
            @param scale The scale of the constructed <code>SimpleBigDecimal</code>.
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Abc.Tnaf">
            Class holding methods for point multiplication based on the window
            &#964;-adic nonadjacent form (WTNAF). The algorithms are based on the
            paper "Improved Algorithms for Arithmetic on Anomalous Binary Curves"
            by Jerome A. Solinas. The paper first appeared in the Proceedings of
            Crypto 1997.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Abc.Tnaf.Width">
            The window width of WTNAF. The standard value of 4 is slightly less
            than optimal for running time, but keeps space requirements for
            precomputation low. For typical curves, a value of 5 or 6 results in
            a better running time. When changing this value, the
            <code>&#945;<sub>u</sub></code>'s must be computed differently, see
            e.g. "Guide to Elliptic Curve Cryptography", Darrel Hankerson,
            Alfred Menezes, Scott Vanstone, Springer-Verlag New York Inc., 2004,
            p. 121-122
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Abc.Tnaf.Pow2Width">
            2<sup>4</sup>
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Abc.Tnaf.Alpha0">
            The <code>&#945;<sub>u</sub></code>'s for <code>a=0</code> as an array
            of <code>ZTauElement</code>s.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Abc.Tnaf.Alpha0Tnaf">
            The <code>&#945;<sub>u</sub></code>'s for <code>a=0</code> as an array
            of TNAFs.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Abc.Tnaf.Alpha1">
            The <code>&#945;<sub>u</sub></code>'s for <code>a=1</code> as an array
            of <code>ZTauElement</code>s.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Abc.Tnaf.Alpha1Tnaf">
            The <code>&#945;<sub>u</sub></code>'s for <code>a=1</code> as an array
            of TNAFs.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.Norm(System.SByte,Org.BouncyCastle.Math.EC.Abc.ZTauElement)">
            Computes the norm of an element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code>.
            @param mu The parameter <code>&#956;</code> of the elliptic curve.
            @param lambda The element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code>.
            @return The norm of <code>&#955;</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.Norm(System.SByte,Org.BouncyCastle.Math.EC.Abc.SimpleBigDecimal,Org.BouncyCastle.Math.EC.Abc.SimpleBigDecimal)">
            Computes the norm of an element <code>&#955;</code> of
            <code><b>R</b>[&#964;]</code>, where <code>&#955; = u + v&#964;</code>
            and <code>u</code> and <code>u</code> are real numbers (elements of
            <code><b>R</b></code>). 
            @param mu The parameter <code>&#956;</code> of the elliptic curve.
            @param u The real part of the element <code>&#955;</code> of
            <code><b>R</b>[&#964;]</code>.
            @param v The <code>&#964;</code>-adic part of the element
            <code>&#955;</code> of <code><b>R</b>[&#964;]</code>.
            @return The norm of <code>&#955;</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.Round(Org.BouncyCastle.Math.EC.Abc.SimpleBigDecimal,Org.BouncyCastle.Math.EC.Abc.SimpleBigDecimal,System.SByte)">
            Rounds an element <code>&#955;</code> of <code><b>R</b>[&#964;]</code>
            to an element of <code><b>Z</b>[&#964;]</code>, such that their difference
            has minimal norm. <code>&#955;</code> is given as
            <code>&#955; = &#955;<sub>0</sub> + &#955;<sub>1</sub>&#964;</code>.
            @param lambda0 The component <code>&#955;<sub>0</sub></code>.
            @param lambda1 The component <code>&#955;<sub>1</sub></code>.
            @param mu The parameter <code>&#956;</code> of the elliptic curve. Must
            equal 1 or -1.
            @return The rounded element of <code><b>Z</b>[&#964;]</code>.
            @throws ArgumentException if <code>lambda0</code> and
            <code>lambda1</code> do not have same scale.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.ApproximateDivisionByN(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,System.SByte,System.Int32,System.Int32)">
            Approximate division by <code>n</code>. For an integer
            <code>k</code>, the value <code>&#955; = s k / n</code> is
            computed to <code>c</code> bits of accuracy.
            @param k The parameter <code>k</code>.
            @param s The curve parameter <code>s<sub>0</sub></code> or
            <code>s<sub>1</sub></code>.
            @param vm The Lucas Sequence element <code>V<sub>m</sub></code>.
            @param a The parameter <code>a</code> of the elliptic curve.
            @param m The bit length of the finite field
            <code><b>F</b><sub>m</sub></code>.
            @param c The number of bits of accuracy, i.e. the scale of the returned
            <code>SimpleBigDecimal</code>.
            @return The value <code>&#955; = s k / n</code> computed to
            <code>c</code> bits of accuracy.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.TauAdicNaf(System.SByte,Org.BouncyCastle.Math.EC.Abc.ZTauElement)">
            Computes the <code>&#964;</code>-adic NAF (non-adjacent form) of an
            element <code>&#955;</code> of <code><b>Z</b>[&#964;]</code>.
            @param mu The parameter <code>&#956;</code> of the elliptic curve.
            @param lambda The element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code>.
            @return The <code>&#964;</code>-adic NAF of <code>&#955;</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.Tau(Org.BouncyCastle.Math.EC.AbstractF2mPoint)">
            Applies the operation <code>&#964;()</code> to an
            <code>AbstractF2mPoint</code>. 
            @param p The AbstractF2mPoint to which <code>&#964;()</code> is applied.
            @return <code>&#964;(p)</code>
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.GetMu(Org.BouncyCastle.Math.EC.AbstractF2mCurve)">
            Returns the parameter <code>&#956;</code> of the elliptic curve.
            @param curve The elliptic curve from which to obtain <code>&#956;</code>.
            The curve must be a Koblitz curve, i.e. <code>a</code> Equals
            <code>0</code> or <code>1</code> and <code>b</code> Equals
            <code>1</code>. 
            @return <code>&#956;</code> of the elliptic curve.
            @throws ArgumentException if the given ECCurve is not a Koblitz
            curve.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.GetLucas(System.SByte,System.Int32,System.Boolean)">
            Calculates the Lucas Sequence elements <code>U<sub>k-1</sub></code> and
            <code>U<sub>k</sub></code> or <code>V<sub>k-1</sub></code> and
            <code>V<sub>k</sub></code>.
            @param mu The parameter <code>&#956;</code> of the elliptic curve.
            @param k The index of the second element of the Lucas Sequence to be
            returned.
            @param doV If set to true, computes <code>V<sub>k-1</sub></code> and
            <code>V<sub>k</sub></code>, otherwise <code>U<sub>k-1</sub></code> and
            <code>U<sub>k</sub></code>.
            @return An array with 2 elements, containing <code>U<sub>k-1</sub></code>
            and <code>U<sub>k</sub></code> or <code>V<sub>k-1</sub></code>
            and <code>V<sub>k</sub></code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.GetTw(System.SByte,System.Int32)">
            Computes the auxiliary value <code>t<sub>w</sub></code>. If the width is
            4, then for <code>mu = 1</code>, <code>t<sub>w</sub> = 6</code> and for
            <code>mu = -1</code>, <code>t<sub>w</sub> = 10</code> 
            @param mu The parameter <code>&#956;</code> of the elliptic curve.
            @param w The window width of the WTNAF.
            @return the auxiliary value <code>t<sub>w</sub></code>
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.GetSi(Org.BouncyCastle.Math.EC.AbstractF2mCurve)">
            Computes the auxiliary values <code>s<sub>0</sub></code> and
            <code>s<sub>1</sub></code> used for partial modular reduction. 
            @param curve The elliptic curve for which to compute
            <code>s<sub>0</sub></code> and <code>s<sub>1</sub></code>.
            @throws ArgumentException if <code>curve</code> is not a
            Koblitz curve (Anomalous Binary Curve, ABC).
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.PartModReduction(Org.BouncyCastle.Math.BigInteger,System.Int32,System.SByte,Org.BouncyCastle.Math.BigInteger[],System.SByte,System.SByte)">
            Partial modular reduction modulo
            <code>(&#964;<sup>m</sup> - 1)/(&#964; - 1)</code>.
            @param k The integer to be reduced.
            @param m The bitlength of the underlying finite field.
            @param a The parameter <code>a</code> of the elliptic curve.
            @param s The auxiliary values <code>s<sub>0</sub></code> and
            <code>s<sub>1</sub></code>.
            @param mu The parameter &#956; of the elliptic curve.
            @param c The precision (number of bits of accuracy) of the partial
            modular reduction.
            @return <code>&#961; := k partmod (&#964;<sup>m</sup> - 1)/(&#964; - 1)</code>
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.MultiplyRTnaf(Org.BouncyCastle.Math.EC.AbstractF2mPoint,Org.BouncyCastle.Math.BigInteger)">
            Multiplies a {@link org.bouncycastle.math.ec.AbstractF2mPoint AbstractF2mPoint}
            by a <code>BigInteger</code> using the reduced <code>&#964;</code>-adic
            NAF (RTNAF) method.
            @param p The AbstractF2mPoint to Multiply.
            @param k The <code>BigInteger</code> by which to Multiply <code>p</code>.
            @return <code>k * p</code>
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.MultiplyTnaf(Org.BouncyCastle.Math.EC.AbstractF2mPoint,Org.BouncyCastle.Math.EC.Abc.ZTauElement)">
            Multiplies a {@link org.bouncycastle.math.ec.AbstractF2mPoint AbstractF2mPoint}
            by an element <code>&#955;</code> of <code><b>Z</b>[&#964;]</code>
            using the <code>&#964;</code>-adic NAF (TNAF) method.
            @param p The AbstractF2mPoint to Multiply.
            @param lambda The element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code>.
            @return <code>&#955; * p</code>
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.MultiplyFromTnaf(Org.BouncyCastle.Math.EC.AbstractF2mPoint,System.SByte[])">
            Multiplies a {@link org.bouncycastle.math.ec.AbstractF2mPoint AbstractF2mPoint}
            by an element <code>&#955;</code> of <code><b>Z</b>[&#964;]</code>
            using the <code>&#964;</code>-adic NAF (TNAF) method, given the TNAF
            of <code>&#955;</code>.
            @param p The AbstractF2mPoint to Multiply.
            @param u The the TNAF of <code>&#955;</code>..
            @return <code>&#955; * p</code>
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.TauAdicWNaf(System.SByte,Org.BouncyCastle.Math.EC.Abc.ZTauElement,System.SByte,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.EC.Abc.ZTauElement[])">
            Computes the <code>[&#964;]</code>-adic window NAF of an element
            <code>&#955;</code> of <code><b>Z</b>[&#964;]</code>.
            @param mu The parameter &#956; of the elliptic curve.
            @param lambda The element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code> of which to compute the
            <code>[&#964;]</code>-adic NAF.
            @param width The window width of the resulting WNAF.
            @param pow2w 2<sup>width</sup>.
            @param tw The auxiliary value <code>t<sub>w</sub></code>.
            @param alpha The <code>&#945;<sub>u</sub></code>'s for the window width.
            @return The <code>[&#964;]</code>-adic window NAF of
            <code>&#955;</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.GetPreComp(Org.BouncyCastle.Math.EC.AbstractF2mPoint,System.SByte)">
            Does the precomputation for WTNAF multiplication.
            @param p The <code>ECPoint</code> for which to do the precomputation.
            @param a The parameter <code>a</code> of the elliptic curve.
            @return The precomputation array for <code>p</code>. 
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Abc.ZTauElement">
            Class representing an element of <code><b>Z</b>[&#964;]</code>. Let
            <code>&#955;</code> be an element of <code><b>Z</b>[&#964;]</code>. Then
            <code>&#955;</code> is given as <code>&#955; = u + v&#964;</code>. The
            components <code>u</code> and <code>v</code> may be used directly, there
            are no accessor methods.
            Immutable class.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Abc.ZTauElement.u">
            The &quot;real&quot; part of <code>&#955;</code>.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Abc.ZTauElement.v">
            The &quot;<code>&#964;</code>-adic&quot; part of <code>&#955;</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.ZTauElement.#ctor(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            Constructor for an element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code>.
            @param u The &quot;real&quot; part of <code>&#955;</code>.
            @param v The &quot;<code>&#964;</code>-adic&quot; part of
            <code>&#955;</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP128R1FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP160R1FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP160R2FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP192K1FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP192R1FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP224K1FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP224R1FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP256K1FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP256R1FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP384R1FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP521R1FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.ECAlgorithms.ReferenceMultiply(Org.BouncyCastle.Math.EC.ECPoint,Org.BouncyCastle.Math.BigInteger)">
            Simple shift-and-add multiplication. Serves as reference implementation
            to verify (possibly faster) implementations, and for very small scalars.
            
            @param p
                       The point to multiply.
            @param k
                       The multiplier.
            @return The result of the point multiplication <code>kP</code>.
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.ECCurve">
            <remarks>Base class for an elliptic curve.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.ECCurve.SetPreCompInfo(Org.BouncyCastle.Math.EC.ECPoint,System.String,Org.BouncyCastle.Math.EC.Multiplier.PreCompInfo)">
            Adds <code>PreCompInfo</code> for a point on this curve, under a given name. Used by
            <code>ECMultiplier</code>s to save the precomputation for this <code>ECPoint</code> for use
            by subsequent multiplication.
            
            @param point
                       The <code>ECPoint</code> to store precomputations for.
            @param name
                       A <code>String</code> used to index precomputations of different types.
            @param preCompInfo
                       The values precomputed by the <code>ECMultiplier</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.ECCurve.NormalizeAll(Org.BouncyCastle.Math.EC.ECPoint[])">
            Normalization ensures that any projective coordinate is 1, and therefore that the x, y
            coordinates reflect those of the equivalent point in an affine coordinate system. Where more
            than one point is to be normalized, this method will generally be more efficient than
            normalizing each point separately.
            
            @param points
                       An array of points that will be updated in place with their normalized versions,
                       where necessary
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.ECCurve.NormalizeAll(Org.BouncyCastle.Math.EC.ECPoint[],System.Int32,System.Int32,Org.BouncyCastle.Math.EC.ECFieldElement)">
            Normalization ensures that any projective coordinate is 1, and therefore that the x, y
            coordinates reflect those of the equivalent point in an affine coordinate system. Where more
            than one point is to be normalized, this method will generally be more efficient than
            normalizing each point separately. An (optional) z-scaling factor can be applied; effectively
            each z coordinate is scaled by this value prior to normalization (but only one
            actual multiplication is needed).
            
            @param points
                       An array of points that will be updated in place with their normalized versions,
                       where necessary
            @param off
                       The start of the range of points to normalize
            @param len
                       The length of the range of points to normalize
            @param iso
                       The (optional) z-scaling factor - can be null
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.ECCurve.GetMultiplier">
            Sets the default <code>ECMultiplier</code>, unless already set. 
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.ECCurve.DecodePoint(System.Byte[])">
            Decode a point on this curve from its ASN.1 encoding. The different
            encodings are taken account of, including point compression for
            <code>F<sub>p</sub></code> (X9.62 s 4.2.1 pg 17).
            @return The decoded point.
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.FpCurve">
            Elliptic curve over Fp
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.AbstractF2mCurve.si">
            The auxiliary values <code>s<sub>0</sub></code> and
            <code>s<sub>1</sub></code> used for partial modular reduction for
            Koblitz curves.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.AbstractF2mCurve.SolveQuadradicEquation(Org.BouncyCastle.Math.EC.ECFieldElement)">
             Solves a quadratic equation <code>z<sup>2</sup> + z = beta</code>(X9.62
             D.1.6) The other solution is <code>z + 1</code>.
            
             @param beta
                        The value to solve the qradratic equation for.
             @return the solution for <code>z<sup>2</sup> + z = beta</code> or
                     <code>null</code> if no solution exists.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.AbstractF2mCurve.GetSi">
            @return the auxiliary values <code>s<sub>0</sub></code> and
            <code>s<sub>1</sub></code> used for partial modular reduction for
            Koblitz curves.
        </member>
        <member name="P:Org.BouncyCastle.Math.EC.AbstractF2mCurve.IsKoblitz">
            Returns true if this is a Koblitz curve (ABC curve).
            @return true if this is a Koblitz curve (ABC curve), false otherwise
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.F2mCurve">
            Elliptic curves over F2m. The Weierstrass equation is given by
            <code>y<sup>2</sup> + xy = x<sup>3</sup> + ax<sup>2</sup> + b</code>.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mCurve.m">
            The exponent <code>m</code> of <code>F<sub>2<sup>m</sup></sub></code>.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mCurve.k1">
            TPB: The integer <code>k</code> where <code>x<sup>m</sup> +
            x<sup>k</sup> + 1</code> represents the reduction polynomial
            <code>f(z)</code>.<br/>
            PPB: The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mCurve.k2">
            TPB: Always set to <code>0</code><br/>
            PPB: The integer <code>k2</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mCurve.k3">
            TPB: Always set to <code>0</code><br/>
            PPB: The integer <code>k3</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mCurve.m_infinity">
            The point at infinity on this curve.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mCurve.#ctor(System.Int32,System.Int32,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            Constructor for Trinomial Polynomial Basis (TPB).
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k The integer <code>k</code> where <code>x<sup>m</sup> +
            x<sup>k</sup> + 1</code> represents the reduction
            polynomial <code>f(z)</code>.
            @param a The coefficient <code>a</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param b The coefficient <code>b</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mCurve.#ctor(System.Int32,System.Int32,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            Constructor for Trinomial Polynomial Basis (TPB).
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k The integer <code>k</code> where <code>x<sup>m</sup> +
            x<sup>k</sup> + 1</code> represents the reduction
            polynomial <code>f(z)</code>.
            @param a The coefficient <code>a</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param b The coefficient <code>b</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param order The order of the main subgroup of the elliptic curve.
            @param cofactor The cofactor of the elliptic curve, i.e.
            <code>#E<sub>a</sub>(F<sub>2<sup>m</sup></sub>) = h * n</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mCurve.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            Constructor for Pentanomial Polynomial Basis (PPB).
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k1 The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k2 The integer <code>k2</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k3 The integer <code>k3</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param a The coefficient <code>a</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param b The coefficient <code>b</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mCurve.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            Constructor for Pentanomial Polynomial Basis (PPB).
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k1 The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k2 The integer <code>k2</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k3 The integer <code>k3</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param a The coefficient <code>a</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param b The coefficient <code>b</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param order The order of the main subgroup of the elliptic curve.
            @param cofactor The cofactor of the elliptic curve, i.e.
            <code>#E<sub>a</sub>(F<sub>2<sup>m</sup></sub>) = h * n</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mCurve.IsTrinomial">
             Return true if curve uses a Trinomial basis.
            
             @return true if curve Trinomial, false otherwise.
        </member>
        <member name="P:Org.BouncyCastle.Math.EC.FpFieldElement.FieldName">
             return the field name for this field.
            
             @return the string "Fp".
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.FpFieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation
            returns the right value - if none exists it returns null.
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.F2mFieldElement">
            Class representing the Elements of the finite field
            <code>F<sub>2<sup>m</sup></sub></code> in polynomial basis (PB)
            representation. Both trinomial (Tpb) and pentanomial (Ppb) polynomial
            basis representations are supported. Gaussian normal basis (GNB)
            representation is not supported.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mFieldElement.Gnb">
            Indicates gaussian normal basis representation (GNB). Number chosen
            according to X9.62. GNB is not implemented at present.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mFieldElement.Tpb">
            Indicates trinomial basis representation (Tpb). Number chosen
            according to X9.62.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mFieldElement.Ppb">
            Indicates pentanomial basis representation (Ppb). Number chosen
            according to X9.62.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mFieldElement.representation">
            Tpb or Ppb.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mFieldElement.m">
            The exponent <code>m</code> of <code>F<sub>2<sup>m</sup></sub></code>.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mFieldElement.x">
            The <code>LongArray</code> holding the bits.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mFieldElement.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,Org.BouncyCastle.Math.BigInteger)">
            Constructor for Ppb.
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k1 The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k2 The integer <code>k2</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k3 The integer <code>k3</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param x The BigInteger representing the value of the field element.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mFieldElement.#ctor(System.Int32,System.Int32,Org.BouncyCastle.Math.BigInteger)">
            Constructor for Tpb.
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k The integer <code>k</code> where <code>x<sup>m</sup> +
            x<sup>k</sup> + 1</code> represents the reduction
            polynomial <code>f(z)</code>.
            @param x The BigInteger representing the value of the field element.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mFieldElement.CheckFieldElements(Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            Checks, if the ECFieldElements <code>a</code> and <code>b</code>
            are elements of the same field <code>F<sub>2<sup>m</sup></sub></code>
            (having the same representation).
            @param a field element.
            @param b field element to be compared.
            @throws ArgumentException if <code>a</code> and <code>b</code>
            are not elements of the same field
            <code>F<sub>2<sup>m</sup></sub></code> (having the same
            representation).
        </member>
        <member name="P:Org.BouncyCastle.Math.EC.F2mFieldElement.Representation">
            @return the representation of the field
            <code>F<sub>2<sup>m</sup></sub></code>, either of
            {@link F2mFieldElement.Tpb} (trinomial
            basis representation) or
            {@link F2mFieldElement.Ppb} (pentanomial
            basis representation).
        </member>
        <member name="P:Org.BouncyCastle.Math.EC.F2mFieldElement.M">
            @return the degree <code>m</code> of the reduction polynomial
            <code>f(z)</code>.
        </member>
        <member name="P:Org.BouncyCastle.Math.EC.F2mFieldElement.K1">
            @return Tpb: The integer <code>k</code> where <code>x<sup>m</sup> +
            x<sup>k</sup> + 1</code> represents the reduction polynomial
            <code>f(z)</code>.<br/>
            Ppb: The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="P:Org.BouncyCastle.Math.EC.F2mFieldElement.K2">
            @return Tpb: Always returns <code>0</code><br/>
            Ppb: The integer <code>k2</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="P:Org.BouncyCastle.Math.EC.F2mFieldElement.K3">
            @return Tpb: Always set to <code>0</code><br/>
            Ppb: The integer <code>k3</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.ECPoint">
            base class for points on elliptic curves.
        </member>
        <member name="P:Org.BouncyCastle.Math.EC.ECPoint.AffineXCoord">
            Returns the affine x-coordinate after checking that this point is normalized.
            
            @return The affine x-coordinate of this point
            @throws IllegalStateException if the point is not normalized
        </member>
        <member name="P:Org.BouncyCastle.Math.EC.ECPoint.AffineYCoord">
            Returns the affine y-coordinate after checking that this point is normalized
            
            @return The affine y-coordinate of this point
            @throws IllegalStateException if the point is not normalized
        </member>
        <member name="P:Org.BouncyCastle.Math.EC.ECPoint.XCoord">
            Returns the x-coordinate.
            
            Caution: depending on the curve's coordinate system, this may not be the same value as in an
            affine coordinate system; use Normalize() to get a point where the coordinates have their
            affine values, or use AffineXCoord if you expect the point to already have been normalized.
            
            @return the x-coordinate of this point
        </member>
        <member name="P:Org.BouncyCastle.Math.EC.ECPoint.YCoord">
            Returns the y-coordinate.
            
            Caution: depending on the curve's coordinate system, this may not be the same value as in an
            affine coordinate system; use Normalize() to get a point where the coordinates have their
            affine values, or use AffineYCoord if you expect the point to already have been normalized.
            
            @return the y-coordinate of this point
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.ECPoint.Normalize">
            Normalization ensures that any projective coordinate is 1, and therefore that the x, y
            coordinates reflect those of the equivalent point in an affine coordinate system.
            
            @return a new ECPoint instance representing the same point, but with normalized coordinates
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.ECPointBase.GetEncoded(System.Boolean)">
            return the field element encoded with point compression. (S 4.3.6)
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.ECPointBase.Multiply(Org.BouncyCastle.Math.BigInteger)">
            Multiplies this <code>ECPoint</code> by the given number.
            @param k The multiplicator.
            @return <code>k * this</code>.
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.FpPoint">
            Elliptic curve points over Fp
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.FpPoint.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
             Create a point which encodes without point compression.
            
             @param curve the curve to use
             @param x affine x co-ordinate
             @param y affine y co-ordinate
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.F2mPoint">
            Elliptic curve points over F2m
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mPoint.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            @param curve base curve
            @param x x point
            @param y y point
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.DoubleAddMultiplier.MultiplyPositive(Org.BouncyCastle.Math.EC.ECPoint,Org.BouncyCastle.Math.BigInteger)">
            Joye's double-add algorithm.
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Multiplier.ECMultiplier">
            Interface for classes encapsulating a point multiplication algorithm
            for <code>ECPoint</code>s.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.ECMultiplier.Multiply(Org.BouncyCastle.Math.EC.ECPoint,Org.BouncyCastle.Math.BigInteger)">
            Multiplies the <code>ECPoint p</code> by <code>k</code>, i.e.
            <code>p</code> is added <code>k</code> times to itself.
            @param p The <code>ECPoint</code> to be multiplied.
            @param k The factor by which <code>p</code> is multiplied.
            @return <code>p</code> multiplied by <code>k</code>.
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Multiplier.FixedPointPreCompInfo">
            Class holding precomputation data for fixed-point multiplications.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Multiplier.FixedPointPreCompInfo.m_preComp">
            Array holding the precomputed <code>ECPoint</code>s used for a fixed
            point multiplication.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Multiplier.FixedPointPreCompInfo.m_width">
            The width used for the precomputation. If a larger width precomputation
            is already available this may be larger than was requested, so calling
            code should refer to the actual width.
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Multiplier.MixedNafR2LMultiplier">
            Class implementing the NAF (Non-Adjacent Form) multiplication algorithm (right-to-left) using
            mixed coordinates.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.MixedNafR2LMultiplier.#ctor">
            By default, addition will be done in Jacobian coordinates, and doubling will be done in
            Modified Jacobian coordinates (independent of the original coordinate system of each point).
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.MontgomeryLadderMultiplier.MultiplyPositive(Org.BouncyCastle.Math.EC.ECPoint,Org.BouncyCastle.Math.BigInteger)">
            Montgomery ladder.
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Multiplier.NafL2RMultiplier">
            Class implementing the NAF (Non-Adjacent Form) multiplication algorithm (left-to-right).
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Multiplier.NafR2LMultiplier">
            Class implementing the NAF (Non-Adjacent Form) multiplication algorithm (right-to-left).
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Multiplier.PreCompInfo">
            Interface for classes storing precomputation data for multiplication
            algorithms. Used as a Memento (see GOF patterns) for
            <code>WNafMultiplier</code>.
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Multiplier.WNafL2RMultiplier">
            Class implementing the WNAF (Window Non-Adjacent Form) multiplication
            algorithm.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.WNafL2RMultiplier.MultiplyPositive(Org.BouncyCastle.Math.EC.ECPoint,Org.BouncyCastle.Math.BigInteger)">
            Multiplies <code>this</code> by an integer <code>k</code> using the
            Window NAF method.
            @param k The integer by which <code>this</code> is multiplied.
            @return A new <code>ECPoint</code> which equals <code>this</code>
            multiplied by <code>k</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.WNafL2RMultiplier.GetWindowSize(System.Int32)">
            Determine window width to use for a scalar multiplication of the given size.
            
            @param bits the bit-length of the scalar to multiply by
            @return the window size to use
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Multiplier.WNafPreCompInfo">
            Class holding precomputation data for the WNAF (Window Non-Adjacent Form)
            algorithm.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Multiplier.WNafPreCompInfo.m_preComp">
            Array holding the precomputed <code>ECPoint</code>s used for a Window
            NAF multiplication.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Multiplier.WNafPreCompInfo.m_preCompNeg">
            Array holding the negations of the precomputed <code>ECPoint</code>s used
            for a Window NAF multiplication.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Multiplier.WNafPreCompInfo.m_twice">
            Holds an <code>ECPoint</code> representing Twice(this). Used for the
            Window NAF multiplication to create or extend the precomputed values.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.WNafUtilities.GenerateWindowNaf(System.Int32,Org.BouncyCastle.Math.BigInteger)">
            Computes the Window NAF (non-adjacent Form) of an integer.
            @param width The width <code>w</code> of the Window NAF. The width is
            defined as the minimal number <code>w</code>, such that for any
            <code>w</code> consecutive digits in the resulting representation, at
            most one is non-zero.
            @param k The integer of which the Window NAF is computed.
            @return The Window NAF of the given width, such that the following holds:
            <code>k = &amp;sum;<sub>i=0</sub><sup>l-1</sup> k<sub>i</sub>2<sup>i</sup>
            </code>, where the <code>k<sub>i</sub></code> denote the elements of the
            returned <code>byte[]</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.WNafUtilities.GetWindowSize(System.Int32)">
            Determine window width to use for a scalar multiplication of the given size.
            
            @param bits the bit-length of the scalar to multiply by
            @return the window size to use
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.WNafUtilities.GetWindowSize(System.Int32,System.Int32[])">
            Determine window width to use for a scalar multiplication of the given size.
            
            @param bits the bit-length of the scalar to multiply by
            @param windowSizeCutoffs a monotonically increasing list of bit sizes at which to increment the window width
            @return the window size to use
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Multiplier.WTauNafMultiplier">
            Class implementing the WTNAF (Window
            <code>&#964;</code>-adic Non-Adjacent Form) algorithm.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.WTauNafMultiplier.MultiplyPositive(Org.BouncyCastle.Math.EC.ECPoint,Org.BouncyCastle.Math.BigInteger)">
            Multiplies a {@link org.bouncycastle.math.ec.AbstractF2mPoint AbstractF2mPoint}
            by <code>k</code> using the reduced <code>&#964;</code>-adic NAF (RTNAF)
            method.
            @param p The AbstractF2mPoint to multiply.
            @param k The integer by which to multiply <code>k</code>.
            @return <code>p</code> multiplied by <code>k</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.WTauNafMultiplier.MultiplyWTnaf(Org.BouncyCastle.Math.EC.AbstractF2mPoint,Org.BouncyCastle.Math.EC.Abc.ZTauElement,Org.BouncyCastle.Math.EC.Multiplier.PreCompInfo,System.SByte,System.SByte)">
            Multiplies a {@link org.bouncycastle.math.ec.AbstractF2mPoint AbstractF2mPoint}
            by an element <code>&#955;</code> of <code><b>Z</b>[&#964;]</code> using
            the <code>&#964;</code>-adic NAF (TNAF) method.
            @param p The AbstractF2mPoint to multiply.
            @param lambda The element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code> of which to compute the
            <code>[&#964;]</code>-adic NAF.
            @return <code>p</code> multiplied by <code>&#955;</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.WTauNafMultiplier.MultiplyFromWTnaf(Org.BouncyCastle.Math.EC.AbstractF2mPoint,System.SByte[],Org.BouncyCastle.Math.EC.Multiplier.PreCompInfo)">
            Multiplies a {@link org.bouncycastle.math.ec.AbstractF2mPoint AbstractF2mPoint}
            by an element <code>&#955;</code> of <code><b>Z</b>[&#964;]</code>
            using the window <code>&#964;</code>-adic NAF (TNAF) method, given the
            WTNAF of <code>&#955;</code>.
            @param p The AbstractF2mPoint to multiply.
            @param u The the WTNAF of <code>&#955;</code>..
            @return <code>&#955; * p</code>
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Multiplier.WTauNafPreCompInfo">
            Class holding precomputation data for the WTNAF (Window
            <code>&#964;</code>-adic Non-Adjacent Form) algorithm.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Multiplier.WTauNafPreCompInfo.m_preComp">
            Array holding the precomputed <code>AbstractF2mPoint</code>s used for the
            WTNAF multiplication in <code>
            {@link org.bouncycastle.math.ec.multiplier.WTauNafMultiplier.multiply()
            WTauNafMultiplier.multiply()}</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.ZSignedDigitL2RMultiplier.MultiplyPositive(Org.BouncyCastle.Math.EC.ECPoint,Org.BouncyCastle.Math.BigInteger)">
            'Zeroless' Signed Digit Left-to-Right.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.ZSignedDigitR2LMultiplier.MultiplyPositive(Org.BouncyCastle.Math.EC.ECPoint,Org.BouncyCastle.Math.BigInteger)">
            'Zeroless' Signed Digit Right-to-Left.
        </member>
        <member name="T:Org.BouncyCastle.Math.Primes">
            Utility methods for generating primes and testing for primality.
        </member>
        <member name="T:Org.BouncyCastle.Math.Primes.MROutput">
            Used to return the output from the
            {@linkplain Primes#enhancedMRProbablePrimeTest(BigInteger, SecureRandom, int) Enhanced
            Miller-Rabin Probabilistic Primality Test}
        </member>
        <member name="T:Org.BouncyCastle.Math.Primes.STOutput">
            Used to return the output from the {@linkplain Primes#generateSTRandomPrime(Digest, int, byte[]) Shawe-Taylor Random_Prime Routine} 
        </member>
        <member name="M:Org.BouncyCastle.Math.Primes.GenerateSTRandomPrime(Org.BouncyCastle.Crypto.Internal.IDigest,System.Int32,System.Byte[])">
            FIPS 186-4 C.6 Shawe-Taylor Random_Prime Routine
            
            Construct a provable prime number using a hash function.
            
            @param hash
                       the {@link Digest} instance to use (as "Hash()"). Cannot be null.
            @param length
                       the length (in bits) of the prime to be generated. Must be at least 2.
            @param inputSeed
                       the seed to be used for the generation of the requested prime. Cannot be null or
                       empty.
            @return an {@link STOutput} instance containing the requested prime.
        </member>
        <member name="M:Org.BouncyCastle.Math.Primes.EnhancedMRProbablePrimeTest(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Security.SecureRandom,System.Int32)">
            FIPS 186-4 C.3.2 Enhanced Miller-Rabin Probabilistic Primality Test
            
            Run several iterations of the Miller-Rabin algorithm with randomly-chosen bases. This is an
            alternative to {@link #isMRProbablePrime(BigInteger, SecureRandom, int)} that provides more
            information about a composite candidate, which may be useful when generating or validating
            RSA moduli.
            
            @param candidate
                       the {@link BigInteger} instance to test for primality.
            @param random
                       the source of randomness to use to choose bases.
            @param iterations
                       the number of randomly-chosen bases to perform the test for.
            @return an {@link MROutput} instance that can be further queried for details.
        </member>
        <member name="M:Org.BouncyCastle.Math.Primes.HasAnySmallFactors(Org.BouncyCastle.Math.BigInteger)">
            A fast check for small divisors, up to some implementation-specific limit.
            
            @param candidate
                       the {@link BigInteger} instance to test for division by small factors.
            
            @return <code>true</code> if the candidate is found to have any small factors,
                    <code>false</code> otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Math.Primes.IsMRProbablePrime(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Security.SecureRandom,System.Int32)">
            FIPS 186-4 C.3.1 Miller-Rabin Probabilistic Primality Test
            
            Run several iterations of the Miller-Rabin algorithm with randomly-chosen bases.
            
            @param candidate
                       the {@link BigInteger} instance to test for primality.
            @param random
                       the source of randomness to use to choose bases.
            @param iterations
                       the number of randomly-chosen bases to perform the test for.
            @return <code>false</code> if any witness to compositeness is found amongst the chosen bases
                    (so <code>candidate</code> is definitely NOT prime), or else <code>true</code>
                    (indicating primality with some probability dependent on the number of iterations
                    that were performed).
        </member>
        <member name="M:Org.BouncyCastle.Math.Primes.IsMRProbablePrimeToBase(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            FIPS 186-4 C.3.1 Miller-Rabin Probabilistic Primality Test (to a fixed base).
            
            Run a single iteration of the Miller-Rabin algorithm against the specified base.
            
            @param candidate
                       the {@link BigInteger} instance to test for primality.
            @param baseValue
                       the base value to use for this iteration.
            @return <code>false</code> if the specified base is a witness to compositeness (so
                    <code>candidate</code> is definitely NOT prime), or else <code>true</code>.
        </member>
        <member name="M:Org.BouncyCastle.Security.SecureRandom.GetInstance(System.String)">
            <summary>
            Create and auto-seed an instance based on the given algorithm.
            </summary>
            <remarks>Equivalent to GetInstance(algorithm, true)</remarks>
            <param name="algorithm">e.g. "SHA256PRNG"</param>
        </member>
        <member name="M:Org.BouncyCastle.Security.SecureRandom.GetInstance(System.String,System.Boolean)">
            <summary>
            Create an instance based on the given algorithm, with optional auto-seeding
            </summary>
            <param name="algorithm">e.g. "SHA256PRNG"</param>
            <param name="autoSeed">If true, the instance will be auto-seeded.</param>
        </member>
        <member name="M:Org.BouncyCastle.Security.SecureRandom.#ctor(System.Byte[])">
            <remarks>
            To replicate existing predictable output, replace with GetInstance("SHA1PRNG", false), followed by SetSeed(seed)
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Security.SecureRandom.#ctor(Org.BouncyCastle.Crypto.Internal.Prng.IRandomGenerator)">
            <summary>Use the specified instance of IRandomGenerator as random source.</summary>
            <remarks>
            This constructor performs no seeding of either the <c>IRandomGenerator</c> or the
            constructed <c>SecureRandom</c>. It is the responsibility of the client to provide
            proper seed material as necessary/appropriate for the given <c>IRandomGenerator</c>
            implementation.
            </remarks>
            <param name="generator">The source to generate all random bytes from.</param>
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Arrays">
            <summary> General array utilities.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Arrays.AreEqual(System.Byte[],System.Byte[])">
            <summary>
            Are two arrays equal.
            </summary>
            <param name="a">Left side.</param>
            <param name="b">Right side.</param>
            <returns>True if equal.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Arrays.AreEqual(System.Int16[],System.Int16[])">
            <summary>
            Are two arrays equal.
            </summary>
            <param name="a">Left side.</param>
            <param name="b">Right side.</param>
            <returns>True if equal.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Arrays.ConstantTimeAreEqual(System.Byte[],System.Byte[])">
            <summary>
            A constant time equals comparison - does not terminate early if
            test will fail.
            </summary>
            <param name="a">first array</param>
            <param name="b">second array</param>
            <returns>true if arrays equal, false otherwise.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Arrays.CopyOfRange(System.Byte[],System.Int32,System.Int32)">
             Make a copy of a range of bytes from the passed in data array. The range can
             extend beyond the end of the input array, in which case the return array will
             be padded with zeroes.
            
             @param data the array from which the data is to be copied.
             @param from the start index at which the copying should take place.
             @param to the final index of the range (exclusive).
            
             @return a new byte array containing the range given.
        </member>
        <member name="T:Org.BouncyCastle.Utilities.BigIntegers">
            BigInteger utilities.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.BigIntegers.AsUnsignedByteArray(Org.BouncyCastle.Math.BigInteger)">
             Return the passed in value as an unsigned byte array.
            
             @param value value to be converted.
             @return a byte array without a leading zero byte if present in the signed encoding.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.BigIntegers.AsUnsignedByteArray(System.Int32,Org.BouncyCastle.Math.BigInteger)">
             Return the passed in value as an unsigned byte array of specified length, zero-extended as necessary.
            
             @param length desired length of result array.
             @param n value to be converted.
             @return a byte array of specified length, with leading zeroes as necessary given the size of n.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.BigIntegers.CreateRandomInRange(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Security.SecureRandom)">
            Return a random BigInteger not less than 'min' and not greater than 'max'
            
            @param min the least value that may be generated
            @param max the greatest value that may be generated
            @param random the source of randomness
            @return a random BigInteger value in the range [min,max]
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Date.DateTimeUtilities.DateTimeToUnixMs(System.DateTime)">
            <summary>
            Return the number of milliseconds since the Unix epoch (1 Jan., 1970 UTC) for a given DateTime value.
            </summary>
            <param name="dateTime">A UTC DateTime value not before epoch.</param>
            <returns>Number of whole milliseconds after epoch.</returns>
            <exception cref="T:System.ArgumentException">'dateTime' is before epoch.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Date.DateTimeUtilities.UnixMsToDateTime(System.Int64)">
            <summary>
            Create a DateTime value from the number of milliseconds since the Unix epoch (1 Jan., 1970 UTC).
            </summary>
            <param name="unixMs">Number of milliseconds since the epoch.</param>
            <returns>A UTC DateTime value</returns>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Date.DateTimeUtilities.CurrentUnixMs">
            <summary>
            Return the current number of milliseconds since the Unix epoch (1 Jan., 1970 UTC).
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Base64.Encode(System.Byte[])">
             encode the input data producing a base 64 encoded byte array.
            
             @return a byte array containing the base 64 encoded data.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Base64.Encode(System.Byte[],System.Int32,System.Int32)">
             encode the input data producing a base 64 encoded byte array.
            
             @return a byte array containing the base 64 encoded data.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Base64.Encode(System.Byte[],System.IO.Stream)">
             Encode the byte data to base 64 writing it to the given output stream.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Base64.Encode(System.Byte[],System.Int32,System.Int32,System.IO.Stream)">
             Encode the byte data to base 64 writing it to the given output stream.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Base64.Decode(System.Byte[])">
             decode the base 64 encoded input data. It is assumed the input data is valid.
            
             @return a byte array representing the decoded data.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Base64.Decode(System.String)">
             decode the base 64 encoded string data - whitespace will be ignored.
            
             @return a byte array representing the decoded data.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Base64.Decode(System.String,System.IO.Stream)">
             decode the base 64 encoded string data writing it to the given output stream,
             whitespace characters will be ignored.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Base64Encoder.Encode(System.Byte[],System.Int32,System.Int32,System.IO.Stream)">
             encode the input data producing a base 64 output stream.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Base64Encoder.Decode(System.Byte[],System.Int32,System.Int32,System.IO.Stream)">
             decode the base 64 encoded byte data writing it to the given output stream,
             whitespace characters will be ignored.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Base64Encoder.DecodeString(System.String,System.IO.Stream)">
             decode the base 64 encoded string data writing it to the given output stream,
             whitespace characters will be ignored.
            
             @return the number of bytes produced.
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Encoders.BufferedDecoder">
            <summary>
             A buffering class to allow translation from one format to another to
                be done in discrete chunks.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.BufferedDecoder.#ctor(Org.BouncyCastle.Utilities.Encoders.ITranslator,System.Int32)">
            <summary>
            Create a buffered Decoder.
            </summary>
            <param name="translator">The translater to use.</param>
            <param name="bufferSize">The size of the buffer.</param>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.BufferedDecoder.ProcessByte(System.Byte,System.Byte[],System.Int32)">
            <summary>
            Process one byte of data.
            </summary>
            <param name="input">Data in.</param>
            <param name="output">Byte array for the output.</param>
            <param name="outOff">The offset in the output byte array to start writing from.</param>
            <returns>The amount of output bytes.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.BufferedDecoder.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Process data from a byte array.
            </summary>
            <param name="input">The input data.</param>
            <param name="inOff">Start position within input data array.</param>
            <param name="len">Amount of data to process from input data array.</param>
            <param name="outBytes">Array to store output.</param>
            <param name="outOff">Position in output array to start writing from.</param>
            <returns>The amount of output bytes.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Encoders.BufferedEncoder">
            <summary>
            A class that allows encoding of data using a specific encoder to be processed in chunks.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.BufferedEncoder.#ctor(Org.BouncyCastle.Utilities.Encoders.ITranslator,System.Int32)">
            <summary>
            Create.
            </summary>
            <param name="translator">The translator to use.</param>
            <param name="bufferSize">Size of the chunks.</param>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.BufferedEncoder.ProcessByte(System.Byte,System.Byte[],System.Int32)">
            <summary>
            Process one byte of data.
            </summary>
            <param name="input">The byte.</param>
            <param name="outBytes">An array to store output in.</param>
            <param name="outOff">Offset within output array to start writing from.</param>
            <returns></returns>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.BufferedEncoder.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Process data from a byte array.
            </summary>
            <param name="input">Input data Byte array containing data to be processed.</param>
            <param name="inOff">Start position within input data array.</param>
            <param name="len">Amount of input data to be processed.</param>
            <param name="outBytes">Output data array.</param>
            <param name="outOff">Offset within output data array to start writing to.</param>
            <returns>The amount of data written.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Encoders.Hex">
            <summary>
            Class to decode and encode Hex.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Hex.Encode(System.Byte[])">
             encode the input data producing a Hex encoded byte array.
            
             @return a byte array containing the Hex encoded data.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Hex.Encode(System.Byte[],System.Int32,System.Int32)">
             encode the input data producing a Hex encoded byte array.
            
             @return a byte array containing the Hex encoded data.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Hex.Encode(System.Byte[],System.IO.Stream)">
             Hex encode the byte data writing it to the given output stream.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Hex.Encode(System.Byte[],System.Int32,System.Int32,System.IO.Stream)">
             Hex encode the byte data writing it to the given output stream.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Hex.Decode(System.Byte[])">
             decode the Hex encoded input data. It is assumed the input data is valid.
            
             @return a byte array representing the decoded data.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Hex.Decode(System.String)">
             decode the Hex encoded string data - whitespace will be ignored.
            
             @return a byte array representing the decoded data.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Hex.Decode(System.String,System.IO.Stream)">
             decode the Hex encoded string data writing it to the given output stream,
             whitespace characters will be ignored.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.HexEncoder.Encode(System.Byte[],System.Int32,System.Int32,System.IO.Stream)">
             encode the input data producing a Hex output stream.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.HexEncoder.Decode(System.Byte[],System.Int32,System.Int32,System.IO.Stream)">
             decode the Hex encoded byte data writing it to the given output stream,
             whitespace characters will be ignored.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.HexEncoder.DecodeString(System.String,System.IO.Stream)">
             decode the Hex encoded string data writing it to the given output stream,
             whitespace characters will be ignored.
            
             @return the number of bytes produced.
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Encoders.HexTranslator">
            <summary>
            A hex translator.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.HexTranslator.GetEncodedBlockSize">
            <summary>
            Return encoded block size.
            </summary>
            <returns>2</returns>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.HexTranslator.Encode(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encode some data.
            </summary>
            <param name="input">Input data array.</param>
            <param name="inOff">Start position within input data array.</param>
            <param name="length">The amount of data to process.</param>
            <param name="outBytes">The output data array.</param>
            <param name="outOff">The offset within the output data array to start writing from.</param>
            <returns>Amount of data encoded.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.HexTranslator.GetDecodedBlockSize">
            <summary>
            Returns the decoded block size.
            </summary>
            <returns>1</returns>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.HexTranslator.Decode(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Decode data from a byte array.
            </summary>
            <param name="input">The input data array.</param>
            <param name="inOff">Start position within input data array.</param>
            <param name="length">The amounty of data to process.</param>
            <param name="outBytes">The output data array.</param>
            <param name="outOff">The position within the output data array to start writing from.</param>
            <returns>The amount of data written.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Encoders.IEncoder">
            Encode and decode byte arrays (typically from binary to 7-bit ASCII
            encodings).
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Encoders.ITranslator">
            <summary>
            Translator interface.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Encoders.UrlBase64">
            Convert binary data to and from UrlBase64 encoding.  This is identical to
            Base64 encoding, except that the padding character is "." and the other 
            non-alphanumeric characters are "-" and "_" instead of "+" and "/".
            <p>
            The purpose of UrlBase64 encoding is to provide a compact encoding of binary
            data that is safe for use as an URL parameter. Base64 encoding does not
            produce encoded values that are safe for use in URLs, since "/" can be 
            interpreted as a path delimiter; "+" is the encoded form of a space; and
            "=" is used to separate a name from the corresponding value in an URL 
            parameter.
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.UrlBase64.Encode(System.Byte[])">
             Encode the input data producing a URL safe base 64 encoded byte array.
            
             @return a byte array containing the URL safe base 64 encoded data.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.UrlBase64.Encode(System.Byte[],System.IO.Stream)">
             Encode the byte data writing it to the given output stream.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.UrlBase64.Decode(System.Byte[])">
             Decode the URL safe base 64 encoded input data - white space will be ignored.
            
             @return a byte array representing the decoded data.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.UrlBase64.Decode(System.Byte[],System.IO.Stream)">
             decode the URL safe base 64 encoded byte data writing it to the given output stream,
             whitespace characters will be ignored.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.UrlBase64.Decode(System.String)">
             decode the URL safe base 64 encoded string data - whitespace will be ignored.
            
             @return a byte array representing the decoded data.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.UrlBase64.Decode(System.String,System.IO.Stream)">
             Decode the URL safe base 64 encoded string data writing it to the given output stream,
             whitespace characters will be ignored.
            
             @return the number of bytes produced.
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Encoders.UrlBase64Encoder">
            Convert binary data to and from UrlBase64 encoding.  This is identical to
            Base64 encoding, except that the padding character is "." and the other 
            non-alphanumeric characters are "-" and "_" instead of "+" and "/".
            <p>
            The purpose of UrlBase64 encoding is to provide a compact encoding of binary
            data that is safe for use as an URL parameter. Base64 encoding does not
            produce encoded values that are safe for use in URLs, since "/" can be 
            interpreted as a path delimiter; "+" is the encoded form of a space; and
            "=" is used to separate a name from the corresponding value in an URL 
            parameter.
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.IMemoable.Copy">
            <summary>
            Produce a copy of this object with its configuration and in its current state.
            </summary>
            <remarks>
            The returned object may be used simply to store the state, or may be used as a similar object
            starting from the copied state.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.IMemoable.Reset(Org.BouncyCastle.Utilities.IMemoable)">
            <summary>
            Restore a copied object state into this object.
            </summary>
            <remarks>
            Implementations of this method <em>should</em> try to avoid or minimise memory allocation to perform the reset.
            </remarks>
            <param name="other">an object originally {@link #copy() copied} from an object of the same type as this instance.</param>
            <exception cref="T:System.InvalidCastException">if the provided object is not of the correct type.</exception>
            <exception cref="T:Org.BouncyCastle.Utilities.MemoableResetException">if the <b>other</b> parameter is in some other way invalid.</exception>
        </member>
        <member name="T:Org.BouncyCastle.Utilities.IO.Pem.PemObject">
            <summary>
            A generic PEM object type.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.IO.Pem.PemObject.#ctor(System.String,System.Byte[])">
            <summary>
            Base constructor.
            </summary>
            <param name="type">The type of the PEM object.</param>
            <param name="content">The byte content it contains.</param>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.IO.Pem.PemObject.#ctor(System.String,System.Collections.IList,System.Byte[])">
            <summary>
            Constructor with headers.
            </summary>
            <param name="type">The type of the PEM object.</param>
            <param name="headers">A list of headers in the object.</param>
            <param name="content">The byte content it contains.</param>
        </member>
        <member name="P:Org.BouncyCastle.Utilities.IO.Pem.PemObject.Type">
            <summary>
            Return the type of the PEM object.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Utilities.IO.Pem.PemObject.Headers">
            <summary>
            Return a list of the headers in the PEM object.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.IO.Pem.PemObject.GetContent">
            <summary>
            Return the raw content in the object.
            </summary>
            <returns>The content of the PEM object.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.IO.Pem.PemObject.Generate">
            <summary>
            Generate a PemObject from this one.
            </summary>
            <returns>this</returns>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.IO.Pem.PemObjectGenerator.Generate">
            <returns>
            A <see cref="T:Org.BouncyCastle.Utilities.IO.Pem.PemObject"/>
            </returns>
            <exception cref="T:Org.BouncyCastle.Utilities.IO.Pem.PemGenerationException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.IO.Pem.PemObjectParser.ParseObject(Org.BouncyCastle.Utilities.IO.Pem.PemObject)">
            <param name="obj">
            A <see cref="T:Org.BouncyCastle.Utilities.IO.Pem.PemObject"/>
            </param>
            <returns>
            A <see cref="T:System.Object"/>
            </returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.IO.Pem.PemReader.ReadPemObject">
            <returns>
            A <see cref="T:Org.BouncyCastle.Utilities.IO.Pem.PemObject"/>
            </returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:Org.BouncyCastle.Utilities.IO.Pem.PemWriter">
            A generic PEM writer, based on RFC 1421
        </member>
        <member name="M:Org.BouncyCastle.Utilities.IO.Pem.PemWriter.#ctor(System.IO.TextWriter)">
             Base constructor.
            
             @param out output stream to use.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.IO.Pem.PemWriter.GetOutputSize(Org.BouncyCastle.Utilities.IO.Pem.PemObject)">
             Return the number of bytes or characters required to contain the
             passed in object if it is PEM encoded.
            
             @param obj pem object to be output
             @return an estimate of the number of bytes
        </member>
        <member name="M:Org.BouncyCastle.Utilities.IO.Streams.PipeAllLimited(System.IO.Stream,System.Int64,System.IO.Stream)">
            <summary>
            Pipe all bytes from <c>inStr</c> to <c>outStr</c>, throwing <c>StreamFlowException</c> if greater
            than <c>limit</c> bytes in <c>inStr</c>.
            </summary>
            <param name="inStr">
            A <see cref="T:System.IO.Stream"/>
            </param>
            <param name="limit">
            A <see cref="T:System.Int64"/>
            </param>
            <param name="outStr">
            A <see cref="T:System.IO.Stream"/>
            </param>
            <returns>The number of bytes actually transferred, if not greater than <c>limit</c></returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:Org.BouncyCastle.Utilities.ISelector`1">
            <summary>
            Interface a selector from a store should conform to.
            </summary>
            <typeparam name="TSelect">the type stored in the store.</typeparam>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.ISelector`1.Match(`0)">
            <summary>
            Match the passed in object, returning true if it would be selected by this selector, false otherwise.
            </summary>
            <param name="obj">the object to be matched.</param>
            <returns>if the object is a match for this selector, false otherwise.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Utilities.IStore`1">
            <summary>
            A generic interface describing a simple store of objects.
            </summary>
            <typeparam name="TStored">the object type stored.</typeparam>
        </member>
        <member name="T:Org.BouncyCastle.Utilities.MemoableResetException">
            Exception to be thrown on a failure to reset an object implementing Memoable.
            <p>
            The exception extends InvalidCastException to enable users to have a single handling case,
            only introducing specific handling of this one if required.
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.MemoableResetException.#ctor(System.String)">
             Basic Constructor.
            
             @param msg message to be associated with this exception.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Net.IPAddress.IsValid(System.String)">
             Validate the given IPv4 or IPv6 address.
            
             @param address the IP address as a string.
            
             @return true if a valid address, false otherwise
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Net.IPAddress.IsValidWithNetMask(System.String)">
             Validate the given IPv4 or IPv6 address and netmask.
            
             @param address the IP address as a string.
            
             @return true if a valid address with netmask, false otherwise
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Net.IPAddress.IsValidIPv4(System.String)">
             Validate the given IPv4 address.
             
             @param address the IP address as a string.
            
             @return true if a valid IPv4 address, false otherwise
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Net.IPAddress.IsValidIPv6(System.String)">
             Validate the given IPv6 address.
            
             @param address the IP address as a string.
            
             @return true if a valid IPv4 address, false otherwise
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Properties">
            <summary>Utility method for accessing system properties.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Properties.IsOverrideSet(System.String)">
            <summary>
            Return true if the environment variable propertyName has the value "true".
            </summary>
            <param name="propertyName">The name of the property to check</param>
            <returns>true if the environment variable propertyName is "true", false otherwise.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Strings">
            <summary> General string utilities.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Test.FixedSecureRandom">
            <summary>
             A secure random that returns pre-seeded data to calls of NextBytes() or GenerateSeed().
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Test.FixedSecureRandom.Source">
            <summary>
            Base class for sources of fixed "Randomness".
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Test.FixedSecureRandom.Data">
            <summary>
            Data Source - in this case we just expect requests for byte arrays.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Test.FixedSecureRandom.BigInteger">
            <summary>
            BigInteger Source - in this case we expect requests for data that will be used
            for BigIntegers. The FixedSecureRandom will attempt to compensate for platform differences here.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Test.TestRandomBigInteger">
            <summary>
            A fixed secure random designed to return data for someone needing to create a single BigInteger.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Test.TestRandomBigInteger.#ctor(System.String)">
            <summary>
            Constructor from a base 10 represention of a BigInteger.
            </summary>
            <param name="encoding">A base 10 represention of a BigInteger.</param>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Test.TestRandomBigInteger.#ctor(System.String,System.Int32)">
            <summary>
            Constructor from a base radix represention of a BigInteger.
            </summary>
            <param name="encoding">A String BigInteger of base radix.</param>
            <param name="radix">The radix to use.</param>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Test.TestRandomBigInteger.#ctor(System.Byte[])">
            <summary>
            Constructor based on a byte array.
            </summary>
            <param name="encoding">A 2's complement representation of the BigInteger.</param>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Test.TestRandomData.#ctor(System.String)">
             Constructor from a Hex encoding of the data.
            
             @param encoding a Hex encoding of the data to be returned.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Test.TestRandomData.#ctor(System.Byte[])">
             Constructor from an array of bytes.
            
             @param encoding a byte array representing the data to be returned.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Test.TestRandomEntropySourceProvider.#ctor(System.Boolean)">
             Create a test entropy source provider.
            
             @param isPredictionResistant boolean indicating if the SecureRandom is based on prediction resistant entropy or not (true if it is).
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Test.TestRandomEntropySourceProvider.Get(System.Int32)">
             Return an entropy source that will create bitsRequired bits of entropy on
             each invocation of getEntropy().
            
             @param bitsRequired size (in bits) of entropy to be created by the provided source.
             @return an EntropySource that generates bitsRequired bits of entropy on each call to its getEntropy() method.
        </member>
    </members>
</doc>
